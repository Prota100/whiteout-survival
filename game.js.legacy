// Whiteout Survival v2.1 - ULTIMATE with Sound FX
// All feedback applied: mobile, balance, visuals, campfire, buildings, SOUND

// ‚ïê‚ïê‚ïê üîä SOUND ENGINE (ElevenLabs + Web Audio + Procedural BGM/Ambience) ‚ïê‚ïê‚ïê
let audioCtx=null,soundEnabled=true,fireAmbSrc=null;
const _sfxCache={};const _sfxPool={};
let _bgm=null,_bgmStarted=false;
let _proBGM=null; // procedural BGM state
let _windAmb=null; // wind ambience state
let _bgmMode='normal'; // 'normal','blizzard','boss','gameover'

function initAudio(){
  try{audioCtx=new(window.AudioContext||window.webkitAudioContext)()}catch(e){soundEnabled=false}
  const sounds=['bgm','slash','hit','kill','coin','chop','build','craft','hire','hurt','eat','quest','death','upgrade_select','box_appear','epic_card'];
  sounds.forEach(name=>{
    fetch('sounds/'+name+'.mp3').then(r=>r.arrayBuffer()).then(buf=>{
      if(audioCtx)audioCtx.decodeAudioData(buf,decoded=>{_sfxCache[name]=decoded;},()=>{});
    }).catch(()=>{});
  });
}

function resumeAudio(){
  if(audioCtx&&audioCtx.state==='suspended')audioCtx.resume();
  if(!_bgmStarted&&soundEnabled){_bgmStarted=true;startBGM();startWindAmbience();}
}

// ‚ïê‚ïê‚ïê Procedural BGM System ‚ïê‚ïê‚ïê
function startBGM(){
  if(!audioCtx||!soundEnabled||_proBGM)return;
  // Try file-based BGM first, fallback to procedural
  if(_sfxCache.bgm){
    const src=audioCtx.createBufferSource();
    const gain=audioCtx.createGain();
    src.buffer=_sfxCache.bgm;src.loop=true;gain.gain.value=0.15;
    src.connect(gain).connect(audioCtx.destination);src.start(0);
    _bgm={src,gain};
  }
  // Always start procedural BGM layer
  _startProceduralBGM();
}

function _startProceduralBGM(){
  if(!audioCtx||!soundEnabled||_proBGM)return;
  const t=audioCtx.currentTime;
  // Master gain for procedural BGM
  const master=audioCtx.createGain();
  master.gain.value=0.12;
  // Lowpass filter (tighten during blizzard)
  const lp=audioCtx.createBiquadFilter();
  lp.type='lowpass';lp.frequency.value=2000;lp.Q.value=0.7;
  lp.connect(master).connect(audioCtx.destination);
  // Drone: low C2 sine
  const drone=audioCtx.createOscillator();
  const droneG=audioCtx.createGain();
  drone.type='sine';drone.frequency.value=65.41;droneG.gain.value=0.3;
  drone.connect(droneG).connect(lp);drone.start(t);
  // Drone2: C3 triangle (subtle)
  const drone2=audioCtx.createOscillator();
  const drone2G=audioCtx.createGain();
  drone2.type='triangle';drone2.frequency.value=130.81;drone2G.gain.value=0.08;
  drone2.connect(drone2G).connect(lp);drone2.start(t);
  // Pad: Eb3 (minor third) soft pad
  const pad=audioCtx.createOscillator();
  const padG=audioCtx.createGain();
  pad.type='sine';pad.frequency.value=155.56;padG.gain.value=0.06;
  pad.connect(padG).connect(lp);pad.start(t);
  // Melody sequencer (interval-based, C minor scale notes)
  const melodyNotes=[261.63,293.66,311.13,349.23,392,415.30,466.16,523.25]; // C4 Cm scale
  let melodyOsc=null,melodyGain=null;
  const melodyInterval=setInterval(()=>{
    if(!audioCtx||!soundEnabled||!_proBGM)return;
    if(Math.random()>0.4)return; // 40% chance each beat
    const ct=audioCtx.currentTime;
    const freq=melodyNotes[Math.floor(Math.random()*melodyNotes.length)];
    const o=audioCtx.createOscillator();const g=audioCtx.createGain();
    o.type='triangle';o.frequency.value=freq;
    g.gain.setValueAtTime(0.08,ct);
    g.gain.exponentialRampToValueAtTime(0.001,ct+1.5);
    o.connect(g).connect(lp);o.start(ct);o.stop(ct+1.5);
  },2000);
  // Boss rhythm sequencer
  let bossInterval=null;
  _proBGM={master,lp,drone,droneG,drone2,drone2G,pad,padG,melodyInterval,bossInterval,
    setBossMode:function(){
      if(bossInterval)return;
      _bgmMode='boss';
      lp.frequency.setValueAtTime(3000,audioCtx.currentTime);
      droneG.gain.setValueAtTime(0.4,audioCtx.currentTime);
      drone.frequency.setValueAtTime(55,audioCtx.currentTime);
      // Fast rhythmic pulse
      bossInterval=setInterval(()=>{
        if(!audioCtx||!soundEnabled||!_proBGM)return;
        const ct=audioCtx.currentTime;
        const o=audioCtx.createOscillator();const g=audioCtx.createGain();
        o.type='square';o.frequency.value=110;
        g.gain.setValueAtTime(0.15,ct);g.gain.exponentialRampToValueAtTime(0.001,ct+0.1);
        o.connect(g).connect(lp);o.start(ct);o.stop(ct+0.12);
      },300);
    },
    clearBossMode:function(){
      if(bossInterval){clearInterval(bossInterval);bossInterval=null;}
      _bgmMode='normal';
      lp.frequency.setValueAtTime(2000,audioCtx.currentTime);
      droneG.gain.setValueAtTime(0.3,audioCtx.currentTime);
      drone.frequency.setValueAtTime(65.41,audioCtx.currentTime);
    },
    setBlizzardMode:function(){
      _bgmMode='blizzard';
      const ct=audioCtx.currentTime;
      lp.frequency.linearRampToValueAtTime(600,ct+1);
      padG.gain.linearRampToValueAtTime(0.15,ct+1);
      pad.frequency.linearRampToValueAtTime(138.59,ct+1); // Eb lowered
      master.gain.linearRampToValueAtTime(0.08,ct+1);
    },
    clearBlizzardMode:function(){
      if(_bgmMode!=='blizzard')return;
      _bgmMode='normal';
      const ct=audioCtx.currentTime;
      lp.frequency.linearRampToValueAtTime(2000,ct+2);
      padG.gain.linearRampToValueAtTime(0.06,ct+2);
      pad.frequency.linearRampToValueAtTime(155.56,ct+2);
      master.gain.linearRampToValueAtTime(0.12,ct+2);
    },
    fadeOut:function(){
      const ct=audioCtx.currentTime;
      master.gain.linearRampToValueAtTime(0,ct+3);
      setTimeout(()=>{stopBGM();},3500);
    }
  };
}

function stopBGM(){
  if(_bgm){try{_bgm.src.stop();}catch(e){}_bgm=null;}
  if(_proBGM){
    try{
      clearInterval(_proBGM.melodyInterval);
      if(_proBGM.bossInterval)clearInterval(_proBGM.bossInterval);
      _proBGM.drone.stop();_proBGM.drone2.stop();_proBGM.pad.stop();
      _proBGM.master.disconnect();
    }catch(e){}
    _proBGM=null;
  }
  _bgmMode='normal';
  _bgmStarted=false;
}

// ‚ïê‚ïê‚ïê Wind Ambience System ‚ïê‚ïê‚ïê
function startWindAmbience(){
  if(!audioCtx||!soundEnabled||_windAmb)return;
  const bs=Math.floor(audioCtx.sampleRate*4);
  const buf=audioCtx.createBuffer(1,bs,audioCtx.sampleRate);
  const d=buf.getChannelData(0);
  for(let i=0;i<bs;i++)d[i]=(Math.random()*2-1);
  const src=audioCtx.createBufferSource();src.buffer=buf;src.loop=true;
  const bp=audioCtx.createBiquadFilter();bp.type='bandpass';bp.frequency.value=350;bp.Q.value=1.5;
  const gain=audioCtx.createGain();gain.gain.value=0.04; // very subtle
  src.connect(bp).connect(gain).connect(audioCtx.destination);
  src.start();
  _windAmb={src,bp,gain,baseVol:0.04};
}
function stopWindAmbience(){
  if(_windAmb){try{_windAmb.src.stop();}catch(e){}_windAmb=null;}
}
function setWindIntensity(level){ // 0=calm, 1=normal, 2=extreme zone, 3=blizzard
  if(!_windAmb||!audioCtx)return;
  const ct=audioCtx.currentTime;
  const vols=[0.02,0.04,0.1,0.2];
  const freqs=[300,350,500,700];
  const qs=[1,1.5,2,3];
  _windAmb.gain.gain.linearRampToValueAtTime(vols[level]||0.04,ct+0.5);
  _windAmb.bp.frequency.linearRampToValueAtTime(freqs[level]||350,ct+0.5);
  _windAmb.bp.Q.linearRampToValueAtTime(qs[level]||1.5,ct+0.5);
}

function _playSFX(name,vol=0.5,distance=0,maxDistance=0){
  if(!audioCtx||!soundEnabled||!_sfxCache[name])return;
  const src=audioCtx.createBufferSource();
  const gain=audioCtx.createGain();
  src.buffer=_sfxCache[name];
  let finalVol = vol;
  if(maxDistance > 0 && distance > 0) {
    const attenuation = Math.max(0.1, 1 - (distance / maxDistance));
    finalVol = vol * attenuation;
  }
  finalVol = Math.min(0.5, Math.max(0.3, finalVol));
  gain.gain.value=finalVol;
  src.connect(gain).connect(audioCtx.destination);
  src.start(0);
  return src;
}

// ‚ïê‚ïê‚ïê Legacy-compatible sound functions ‚ïê‚ïê‚ïê
function playSlash(){_playSFX('slash',0.35)}
function playHit(){_playSFX('hit',0.4)}
function playKill(){_playSFX('kill',0.4)}
function playCoin(){_playSFX('coin',0.3)}
function playChop(){_playSFX('chop',0.35)}
function playBuild(){_playSFX('build',0.4)}
function playCraft(){_playSFX('craft',0.35)}
function playHire(){_playSFX('hire',0.4)}
function playHurt(){_playSFX('hurt',0.45)}
function playEat(){_playSFX('eat',0.3)}
function playQuest(){_playSFX('quest',0.4)}
function playDeath(){_playSFX('death',0.45)}
function playWhiff(){_playSFX('slash',0.08)}

// ‚ïê‚ïê‚ïê Enhanced SFX (Procedural) ‚ïê‚ïê‚ïê
function playLevelUp(){
  if(!audioCtx||!soundEnabled)return;
  // Triumphant 3-note fanfare (C-E-G ascending)
  const notes=[523.25,659.25,783.99];
  notes.forEach((freq,i)=>{
    const osc=audioCtx.createOscillator();const g=audioCtx.createGain();
    osc.type='triangle';osc.frequency.value=freq;
    g.gain.setValueAtTime(0.3,audioCtx.currentTime+i*0.12);
    g.gain.exponentialRampToValueAtTime(0.01,audioCtx.currentTime+i*0.12+0.5);
    osc.connect(g).connect(audioCtx.destination);
    osc.start(audioCtx.currentTime+i*0.12);osc.stop(audioCtx.currentTime+i*0.12+0.5);
  });
  // Shimmer on top
  const sh=audioCtx.createOscillator();const sg=audioCtx.createGain();
  sh.type='sine';sh.frequency.value=1046.5;
  sg.gain.setValueAtTime(0.15,audioCtx.currentTime+0.36);
  sg.gain.exponentialRampToValueAtTime(0.001,audioCtx.currentTime+1.2);
  sh.connect(sg).connect(audioCtx.destination);
  sh.start(audioCtx.currentTime+0.36);sh.stop(audioCtx.currentTime+1.2);
}
function playUpgradeSelect(){
  // Chime/sparkle effect
  if(!audioCtx||!soundEnabled)return;
  const ct=audioCtx.currentTime;
  [1318.5,1760,2093].forEach((f,i)=>{
    const o=audioCtx.createOscillator();const g=audioCtx.createGain();
    o.type='sine';o.frequency.value=f;
    g.gain.setValueAtTime(0.12,ct+i*0.05);
    g.gain.exponentialRampToValueAtTime(0.001,ct+i*0.05+0.3);
    o.connect(g).connect(audioCtx.destination);
    o.start(ct+i*0.05);o.stop(ct+i*0.05+0.35);
  });
  _playSFX('upgrade_select',0.4);
}
function playBoxAppear(){_playSFX('box_appear',0.5)}
function playEpicCard(){_playSFX('epic_card',0.7)}

// ‚ïê‚ïê‚ïê Enemy-type hit sounds ‚ïê‚ïê‚ïê
function playHitEnemy(enemyType){
  if(!audioCtx||!soundEnabled)return;
  const ct=audioCtx.currentTime;
  if(enemyType==='boss'){
    // Deep, long rumble hit
    const o=audioCtx.createOscillator();const g=audioCtx.createGain();
    o.type='sawtooth';o.frequency.value=60;
    o.frequency.exponentialRampToValueAtTime(30,ct+0.6);
    g.gain.setValueAtTime(0.3,ct);g.gain.exponentialRampToValueAtTime(0.01,ct+0.6);
    o.connect(g).connect(audioCtx.destination);o.start(ct);o.stop(ct+0.65);
  } else if(enemyType==='elite'){
    // Heavy thud
    const o=audioCtx.createOscillator();const g=audioCtx.createGain();
    o.type='square';o.frequency.value=100;
    o.frequency.exponentialRampToValueAtTime(50,ct+0.2);
    g.gain.setValueAtTime(0.25,ct);g.gain.exponentialRampToValueAtTime(0.01,ct+0.25);
    o.connect(g).connect(audioCtx.destination);o.start(ct);o.stop(ct+0.3);
  } else {
    // Normal: short beep (existing hit + synth layer)
    _playSFX('hit',0.3);
  }
}

// ‚ïê‚ïê‚ïê Critical hit: metallic clang ‚ïê‚ïê‚ïê
function playCriticalHit(){
  if(!audioCtx||!soundEnabled)return;
  const ct=audioCtx.currentTime;
  // Metallic ring (high freq + fast decay)
  [2400,3200,4000].forEach((f,i)=>{
    const o=audioCtx.createOscillator();const g=audioCtx.createGain();
    o.type='square';o.frequency.value=f;
    g.gain.setValueAtTime(0.12,ct);g.gain.exponentialRampToValueAtTime(0.001,ct+0.15);
    o.connect(g).connect(audioCtx.destination);o.start(ct);o.stop(ct+0.2);
  });
  // Impact thump
  const sub=audioCtx.createOscillator();const sg=audioCtx.createGain();
  sub.type='sine';sub.frequency.value=80;
  sg.gain.setValueAtTime(0.2,ct);sg.gain.exponentialRampToValueAtTime(0.001,ct+0.1);
  sub.connect(sg).connect(audioCtx.destination);sub.start(ct);sub.stop(ct+0.12);
}

// ‚ïê‚ïê‚ïê Item pickup: bright jingle ‚ïê‚ïê‚ïê
function playItemPickup(){
  if(!audioCtx||!soundEnabled)return;
  const ct=audioCtx.currentTime;
  [880,1108.7,1318.5].forEach((f,i)=>{
    const o=audioCtx.createOscillator();const g=audioCtx.createGain();
    o.type='sine';o.frequency.value=f;
    g.gain.setValueAtTime(0.15,ct+i*0.06);
    g.gain.exponentialRampToValueAtTime(0.001,ct+i*0.06+0.25);
    o.connect(g).connect(audioCtx.destination);
    o.start(ct+i*0.06);o.stop(ct+i*0.06+0.3);
  });
}

// ‚ïê‚ïê‚ïê Revival scroll: mystical shimmer ‚ïê‚ïê‚ïê
function playRevival(){
  if(!audioCtx||!soundEnabled)return;
  const ct=audioCtx.currentTime;
  // Ascending ethereal tones
  [330,440,554.37,659.25,880].forEach((f,i)=>{
    const o=audioCtx.createOscillator();const g=audioCtx.createGain();
    o.type='sine';o.frequency.value=f;
    o.frequency.linearRampToValueAtTime(f*1.02,ct+i*0.15+0.8); // slight vibrato
    g.gain.setValueAtTime(0,ct+i*0.15);
    g.gain.linearRampToValueAtTime(0.12,ct+i*0.15+0.1);
    g.gain.exponentialRampToValueAtTime(0.001,ct+i*0.15+0.8);
    o.connect(g).connect(audioCtx.destination);
    o.start(ct+i*0.15);o.stop(ct+i*0.15+0.85);
  });
  // Shimmer noise
  const bs=Math.floor(audioCtx.sampleRate*1.5);
  const buf=audioCtx.createBuffer(1,bs,audioCtx.sampleRate);
  const d=buf.getChannelData(0);for(let i=0;i<bs;i++)d[i]=(Math.random()*2-1);
  const src=audioCtx.createBufferSource();src.buffer=buf;
  const hp=audioCtx.createBiquadFilter();hp.type='highpass';hp.frequency.value=4000;
  const ng=audioCtx.createGain();ng.gain.setValueAtTime(0,ct);
  ng.gain.linearRampToValueAtTime(0.06,ct+0.3);
  ng.gain.exponentialRampToValueAtTime(0.001,ct+1.5);
  src.connect(hp).connect(ng).connect(audioCtx.destination);
  src.start(ct);src.stop(ct+1.5);
}

// ‚ïê‚ïê‚ïê UI Sounds ‚ïê‚ïê‚ïê
function playUITick(){
  if(!audioCtx||!soundEnabled)return;
  const o=audioCtx.createOscillator();const g=audioCtx.createGain();
  o.type='sine';o.frequency.value=1800;
  g.gain.setValueAtTime(0.06,audioCtx.currentTime);
  g.gain.exponentialRampToValueAtTime(0.001,audioCtx.currentTime+0.04);
  o.connect(g).connect(audioCtx.destination);
  o.start();o.stop(audioCtx.currentTime+0.05);
}
function playUISwing(){
  if(!audioCtx||!soundEnabled)return;
  const ct=audioCtx.currentTime;
  const o=audioCtx.createOscillator();const g=audioCtx.createGain();
  o.type='sine';o.frequency.setValueAtTime(600,ct);
  o.frequency.exponentialRampToValueAtTime(300,ct+0.15);
  g.gain.setValueAtTime(0.08,ct);g.gain.exponentialRampToValueAtTime(0.001,ct+0.15);
  o.connect(g).connect(audioCtx.destination);o.start(ct);o.stop(ct+0.18);
}
function playAchievement(){
  if(!audioCtx||!soundEnabled)return;
  const ct=audioCtx.currentTime;
  // Victory fanfare: C-E-G-C (octave)
  [523.25,659.25,783.99,1046.5].forEach((f,i)=>{
    const o=audioCtx.createOscillator();const g=audioCtx.createGain();
    o.type='triangle';o.frequency.value=f;
    g.gain.setValueAtTime(0.2,ct+i*0.15);
    g.gain.exponentialRampToValueAtTime(0.01,ct+i*0.15+0.6);
    o.connect(g).connect(audioCtx.destination);
    o.start(ct+i*0.15);o.stop(ct+i*0.15+0.65);
  });
}

// ‚ïê‚ïê‚ïê Existing procedural SFX (enhanced) ‚ïê‚ïê‚ïê
function playBossSpawn(){
  if(!audioCtx||!soundEnabled)return;
  // Activate boss BGM mode
  if(_proBGM)_proBGM.setBossMode();
  // Deep threatening bass rumble + horn
  [55, 65, 82.4].forEach((freq,i)=>{
    const osc=audioCtx.createOscillator();const g=audioCtx.createGain();
    osc.type='sawtooth';osc.frequency.value=freq;
    osc.frequency.linearRampToValueAtTime(freq*0.7,audioCtx.currentTime+1.5);
    g.gain.setValueAtTime(0.25,audioCtx.currentTime+i*0.15);
    g.gain.exponentialRampToValueAtTime(0.01,audioCtx.currentTime+1.8);
    osc.connect(g).connect(audioCtx.destination);
    osc.start(audioCtx.currentTime+i*0.15);osc.stop(audioCtx.currentTime+2);
  });
  const sub=audioCtx.createOscillator();const sg=audioCtx.createGain();
  sub.type='sine';sub.frequency.value=35;
  sg.gain.setValueAtTime(0.3,audioCtx.currentTime);
  sg.gain.exponentialRampToValueAtTime(0.01,audioCtx.currentTime+2);
  sub.connect(sg).connect(audioCtx.destination);
  sub.start();sub.stop(audioCtx.currentTime+2);
}

function playWinSound(){if(!audioCtx||!soundEnabled)return;const o=audioCtx.createOscillator();const g=audioCtx.createGain();o.type='triangle';o.frequency.setValueAtTime(440,audioCtx.currentTime);g.gain.setValueAtTime(0.5,audioCtx.currentTime);o.connect(g);g.connect(audioCtx.destination);o.start();g.gain.exponentialRampToValueAtTime(0.001,audioCtx.currentTime+1);o.stop(audioCtx.currentTime+1)}

function playGameOverSound(){
  if(!audioCtx||!soundEnabled)return;
  // Fade out BGM
  if(_proBGM)_proBGM.fadeOut();
  // Sad descending melody
  const notes=[659.25,587.33,523.25,493.88,440];
  notes.forEach((freq,i)=>{
    const osc=audioCtx.createOscillator();const g=audioCtx.createGain();
    osc.type='sine';osc.frequency.value=freq;
    g.gain.setValueAtTime(0.2,audioCtx.currentTime+i*0.5);
    g.gain.exponentialRampToValueAtTime(0.01,audioCtx.currentTime+i*0.5+0.6);
    osc.connect(g).connect(audioCtx.destination);
    osc.start(audioCtx.currentTime+i*0.5);osc.stop(audioCtx.currentTime+i*0.5+0.7);
  });
}

function playBlizzardStart(){
  if(!audioCtx||!soundEnabled)return;
  // Activate blizzard BGM mode
  if(_proBGM)_proBGM.setBlizzardMode();
  setWindIntensity(3);
  // Wind howl effect using filtered noise
  const bs=audioCtx.sampleRate*3,buf=audioCtx.createBuffer(1,bs,audioCtx.sampleRate);
  const d=buf.getChannelData(0);
  for(let i=0;i<bs;i++)d[i]=(Math.random()*2-1);
  const src=audioCtx.createBufferSource();src.buffer=buf;
  const bp=audioCtx.createBiquadFilter();bp.type='bandpass';bp.frequency.value=400;bp.Q.value=2;
  bp.frequency.linearRampToValueAtTime(800,audioCtx.currentTime+1.5);
  bp.frequency.linearRampToValueAtTime(300,audioCtx.currentTime+3);
  const g=audioCtx.createGain();
  g.gain.setValueAtTime(0,audioCtx.currentTime);
  g.gain.linearRampToValueAtTime(0.3,audioCtx.currentTime+0.5);
  g.gain.linearRampToValueAtTime(0.15,audioCtx.currentTime+2);
  g.gain.exponentialRampToValueAtTime(0.01,audioCtx.currentTime+3);
  src.connect(bp).connect(g).connect(audioCtx.destination);
  src.start();src.stop(audioCtx.currentTime+3);
}

function playBlizzardEnd(){
  if(_proBGM)_proBGM.clearBlizzardMode();
  setWindIntensity(1);
}

function playBossDefeated(){
  if(_proBGM)_proBGM.clearBossMode();
}

// Fire ambient
function startFire(){if(!audioCtx||!soundEnabled||fireAmbSrc)return;const bs=Math.floor(audioCtx.sampleRate*2),b=audioCtx.createBuffer(1,bs,audioCtx.sampleRate),d=b.getChannelData(0);for(let i=0;i<bs;i++){d[i]=(Math.random()*2-1)*0.03;if(Math.random()<0.002)d[i]*=8}const s=audioCtx.createBufferSource(),g=audioCtx.createGain();s.buffer=b;s.loop=true;g.gain.value=0.12;s.connect(g).connect(audioCtx.destination);s.start();fireAmbSrc={s,g}}
function stopFire(){if(fireAmbSrc){try{fireAmbSrc.s.stop()}catch(e){}fireAmbSrc=null}}
// ‚ïê‚ïê‚ïê Pitched SFX helper ‚ïê‚ïê‚ïê
function _playSFXPitched(name, vol, pitchRate) {
  if (!audioCtx || !soundEnabled || !_sfxCache[name]) return;
  const src = audioCtx.createBufferSource();
  const gain = audioCtx.createGain();
  src.buffer = _sfxCache[name];
  src.playbackRate.value = pitchRate || 1;
  gain.gain.value = Math.min(0.5, Math.max(0.05, vol));
  src.connect(gain).connect(audioCtx.destination);
  src.start(0);
  return src;
}
function playColdWarning() { _playSFXPitched('hurt', 0.3, 0.6); }
function playClassSkill() { _playSFXPitched('slash', 0.35, 1.3); }
function playHellSelect() { _playSFXPitched('death', 0.35, 0.5); }

// ‚ïê‚ïê‚ïê Game Tips ‚ïê‚ïê‚ïê
const GAME_TIPS = [
  // ‚öîÔ∏è Ï†ÑÌà¨
  "‚öîÔ∏è Í∞ôÏùÄ Îì±Í∏â Ïû•ÎπÑ 3Í∞úÎ•º Î™®ÏúºÎ©¥ Ìï©ÏÑ±Ìï† Ïàò ÏûàÏñ¥Ïöî!",
  "‚öîÔ∏è ÏΩ§Î≥¥ 20ÌÇ¨ Ïù¥ÏÉÅÏù¥Î©¥ Í¥ëÏ†ÑÏÇ¨ Î™®Îìú Î∞úÎèô!",
  "‚öîÔ∏è Ïä§ÌÇ¨ ÏãúÎÑàÏßÄÎ•º ÎÖ∏Î†§Î≥¥ÏÑ∏Ïöî. Ï°∞Ìï©Ïóê Îî∞Îùº Ïà®Í≤®ÏßÑ Ìö®Í≥ºÍ∞Ä ÏûàÏñ¥Ïöî!",
  "‚öîÔ∏è Î≥¥Ïä§Îäî Ìå®ÌÑ¥Ïù¥ ÏûàÏñ¥Ïöî. Í¥ÄÏ∞∞Ìïú Îí§ Í≥µÍ≤©ÌïòÏÑ∏Ïöî!",
  "‚öîÔ∏è Í≥∞ÏùÄ Í∞ïÌïòÏßÄÎßå ÎäêÎ¶ΩÎãàÎã§. ÏòÜÏúºÎ°ú ÌîºÌïòÎ©¥ÏÑú Í≥µÍ≤©ÌïòÏÑ∏Ïöî!",
  // ‚ùÑÔ∏è ÏÉùÏ°¥
  "‚ùÑÔ∏è ÌïúÌååÍ∞Ä Ïã¨Ìï† ÎïåÎäî Ï∫†ÌîÑÌååÏù¥Ïñ¥ Í∑ºÏ≤òÏóê ÏûàÏúºÎ©¥ HPÍ∞Ä ÌöåÎ≥µÎèºÏöî",
  "‚ùÑÔ∏è ÎÇòÎ¨¥ÏôÄ ÎèåÏùÑ Î™®ÏïÑ Í±¥Î¨ºÏùÑ ÏßÄÏúºÎ©¥ ÏÉùÏ°¥Ïóê Ïú†Î¶¨Ìï¥Ïöî",
  "‚ùÑÔ∏è Ïò®ÎèÑÍ∞Ä 0 Ïù¥ÌïòÎ°ú Îñ®Ïñ¥ÏßÄÎ©¥ HPÍ∞Ä Í∞êÏÜåÌï©ÎãàÎã§!",
  "‚ùÑÔ∏è ÌïúÌååÎ•º Í≤¨ÎîîÎ©¥ Î≥¥ÏÉÅÏù¥ ÏûàÏñ¥Ïöî. Ìè¨Í∏∞ÌïòÏßÄ ÎßàÏÑ∏Ïöî!",
  // üéØ Ï†ÑÎûµ
  "üéØ Î†àÎ≤®ÏóÖ Ïãú Ïπ¥ÎìúÎ•º Ïã†Ï§ëÌïòÍ≤å Í≥®ÎùºÎ≥¥ÏÑ∏Ïöî!",
  "üéØ ÏßÄÏò• ÎÇúÏù¥ÎèÑ ÌÅ¥Î¶¨Ïñ¥ Ïãú 50Ìè¨Ïù∏Ìä∏ Î≥¥ÎÑàÏä§!",
  "üéØ ÌÅ¥ÎûòÏä§ÎßàÎã§ Ìå®ÏãúÎ∏åÍ∞Ä Îã§Î¶ÖÎãàÎã§. Ï†ÑÎûµÏóê ÎßûÎäî ÌÅ¥ÎûòÏä§Î•º ÏÑ†ÌÉùÌïòÏÑ∏Ïöî!",
  "üéØ Î¨¥Ìïú Î™®ÎìúÏóêÏÑúÎäî 60Î∂Ñ Ïù¥ÌõÑÏóêÎèÑ Í≥ÑÏÜç ÌîåÎ†àÏù¥Ìï† Ïàò ÏûàÏñ¥Ïöî!",
  "üéØ Ïû•ÎπÑ Ïä¨Î°ØÏùÑ Î™®Îëê ÏóêÌîΩÏúºÎ°ú Ï±ÑÏö∞Î©¥ ÌäπÎ≥ÑÌïú ÏÑ±Ï∑®Î•º Îã¨ÏÑ±Ìï©ÎãàÎã§!",
  // üèÜ ÎπÑÎ∞Ä
  "üèÜ ÏΩòÏïÑÎØ∏ ÏΩîÎìúÎ•º ÏïåÍ≥† ÏûàÎÇòÏöî? Î≤ÑÏ†Ñ ÌÖçÏä§Ìä∏Î•º 5Î≤à ÌÅ¥Î¶≠Ìï¥Î≥¥ÏÑ∏Ïöî...",
  "üèÜ Î∞±ÏÉâ Íµ∞Ï£ºÎäî 20Î∂Ñ Ïù¥ÌõÑ Í∑πÌïú Íµ¨Ïó≠ÏóêÏÑú ÎÇòÌÉÄÎÇúÎã§Îäî ÏÜåÎ¨∏Ïù¥...",
  "üèÜ Î≥¥Ïä§ Îü¨Ïãú Î™®ÎìúÏóêÏÑú Î™®Îì† Î≥¥Ïä§Î•º Ïì∞Îü¨Îú®Î¶¨Î©¥ Ïà®Í≤®ÏßÑ ÏóîÎî©Ïù¥!",
  "üèÜ Ïä§ÌîºÎìúÎü∞ 30Î∂Ñ Ïù¥ÎÇ¥ ÌÅ¥Î¶¨Ïñ¥ Ïãú ÌäπÎ≥Ñ Ïπ≠Ìò∏Î•º ÏñªÏùÑ Ïàò ÏûàÏñ¥Ïöî!",
];

// ‚ïê‚ïê‚ïê FTUE (First Time User Experience) Manager ‚ïê‚ïê‚ïê
const FTUEManager = {
  KEY: 'whiteout_firstplay',
  isFirstPlay() { return localStorage.getItem(this.KEY) !== 'done'; },
  markDone() { try { localStorage.setItem(this.KEY, 'done'); } catch(e) {} },
  _shown: {},
  showOnce(scene, id, text, duration) {
    if (!this.isFirstPlay()) return false;
    if (this._shown[id]) return false;
    this._shown[id] = true;
    duration = duration || 3000;
    const cam = scene.cameras.main;
    const bg = scene.add.graphics().setScrollFactor(0).setDepth(500);
    const txt = scene.add.text(cam.width / 2, cam.height * 0.15, text, {
      fontSize: '16px', fontFamily: 'monospace', color: '#FFD700',
      backgroundColor: 'rgba(0,0,0,0.8)', padding: { x: 20, y: 12 },
      stroke: '#000', strokeThickness: 2, wordWrap: { width: cam.width * 0.8 }, align: 'center'
    }).setOrigin(0.5).setScrollFactor(0).setDepth(501).setAlpha(0);
    scene.tweens.add({ targets: txt, alpha: 1, duration: 400 });
    scene.time.delayedCall(duration, () => {
      scene.tweens.add({ targets: txt, alpha: 0, duration: 400, onComplete: () => { txt.destroy(); bg.destroy(); } });
    });
    return true;
  },
  reset() { this._shown = {}; }
};

// ‚ïê‚ïê‚ïê Mobile helpers ‚ïê‚ïê‚ïê
function isMobileLayout() { return window.innerWidth < 768; }
function mobileFS(desktop, mobile) { return isMobileLayout() ? mobile : desktop; }

// ‚ïê‚ïê‚ïê END SOUND ‚ïê‚ïê‚ïê

// ‚ïê‚ïê‚ïê üíæ SAVE MANAGER ‚ïê‚ïê‚ïê
class SaveManager {
  static SAVE_KEY = 'whiteout_save';
  
  static save(scene) {
    try {
      const saveData = {
        version: '2.1',
        timestamp: Date.now(),
        player: {
          x: scene.player ? scene.player.x : WORLD_W / 2,
          y: scene.player ? scene.player.y : WORLD_H / 2,
          hp: scene.playerHP,
          maxHP: scene.playerMaxHP,
          damage: scene.playerDamage,
          speed: scene.playerSpeed,
          baseSpeed: scene.playerBaseSpeed,
          warmthResist: scene.warmthResist,
          woodBonus: scene.woodBonus,
          stoneBonus: scene.stoneBonus,
          baseAttackSpeed: scene.baseAttackSpeed,
          facingRight: scene.facingRight,
        },
        resources: { ...scene.res },
        temperature: scene.temperature,
        maxTemp: scene.maxTemp,
        hunger: scene.hunger,
        maxHunger: scene.maxHunger,
        storageCapacity: scene.storageCapacity,
        stats: JSON.parse(JSON.stringify(scene.stats)),
        questCompleted: [...scene.questCompleted],
        questIndex: scene.questIndex,
        buildings: scene.placedBuildings.map(b => ({ type: b.type, x: b.x, y: b.y })),
        npcs: scene.npcsOwned.map(n => ({ type: n.npcType, x: n.x, y: n.y })),
        upgrades: scene.upgradeManager.toJSON(),
        synergies: scene.synergyManager.toJSON(),
        playerXP: scene.playerXP,
        playerLevel: scene.playerLevel,
        gameElapsed: scene.gameElapsed,
        coldWaveCount: scene.coldWaveCount,
        nextColdWaveTime: scene.nextColdWaveTime,
        boss1Spawned: scene.boss1Spawned,
        boss2Spawned: scene.boss2Spawned,
        act2MinibossSpawned: scene.act2MinibossSpawned,
        act4MinibossSpawned: scene.act4MinibossSpawned,
        waveNumber: scene.waveNumber,
      };
      localStorage.setItem(SaveManager.SAVE_KEY, JSON.stringify(saveData));
      return true;
    } catch (e) {
      console.error('Save failed:', e);
      return false;
    }
  }
  
  static load() {
    try {
      const saved = localStorage.getItem(SaveManager.SAVE_KEY);
      return saved ? JSON.parse(saved) : null;
    } catch (e) {
      console.error('Load failed:', e);
      return null;
    }
  }
  
  static exists() {
    try {
      const raw = localStorage.getItem(SaveManager.SAVE_KEY);
      if (!raw) return false;
      const parsed = JSON.parse(raw);
      return parsed && typeof parsed === 'object';
    } catch (e) {
      // Corrupt data - clean it up
      localStorage.removeItem(SaveManager.SAVE_KEY);
      return false;
    }
  }
  
  static delete() {
    localStorage.removeItem(SaveManager.SAVE_KEY);
  }
}
// ‚ïê‚ïê‚ïê END SAVE MANAGER ‚ïê‚ïê‚ïê

// ‚ïê‚ïê‚ïê üí´ META PROGRESSION ‚ïê‚ïê‚ïê
class MetaManager {
  static META_KEY = 'whiteout_meta';
  
  static getDefault() {
    return {
      version: '2.1',
      totalPoints: 0,
      spentPoints: 0,
      bestTime: 0,
      totalRuns: 0,
      upgrades: {
        startHP: 0,
        startTempResist: 0,
        startWood: 0,
        extraCard: 0,
        revival_scroll: 0
      }
    };
  }
  
  static load() {
    try {
      const raw = localStorage.getItem(MetaManager.META_KEY);
      return raw ? JSON.parse(raw) : MetaManager.getDefault();
    } catch (e) {
      return MetaManager.getDefault();
    }
  }
  
  static save(meta) {
    try { localStorage.setItem(MetaManager.META_KEY, JSON.stringify(meta)); } catch(e) { console.error('Meta save failed:', e); }
  }
  
  static earnPoints(survivalSeconds, totalKills, maxCombo) {
    return Math.floor(survivalSeconds / 10) + totalKills + (maxCombo * 2);
  }
  
  static getAvailablePoints() {
    const meta = MetaManager.load();
    return meta.totalPoints - meta.spentPoints;
  }
  
  static getUpgradeCost(type, level) {
    const costs = {
      startHP: [100, 200, 400, 800, 1600],
      startTempResist: [100, 200, 400, 800, 1600],
      startWood: [50, 100, 200, 400, 800],
      extraCard: [500, 1000, 2000],
      revival_scroll: [20]
    };
    return costs[type]?.[level] || 9999;
  }
  
  static getMaxLevel(type) {
    return type === 'extraCard' ? 3 : type === 'revival_scroll' ? 1 : 5;
  }
  
  static canUpgrade(type) {
    const meta = MetaManager.load();
    const level = meta.upgrades[type];
    if (level >= MetaManager.getMaxLevel(type)) return false;
    return MetaManager.getAvailablePoints() >= MetaManager.getUpgradeCost(type, level);
  }
  
  static doUpgrade(type) {
    const meta = MetaManager.load();
    const level = meta.upgrades[type];
    const cost = MetaManager.getUpgradeCost(type, level);
    if (MetaManager.getAvailablePoints() < cost) return false;
    
    meta.spentPoints += cost;
    meta.upgrades[type]++;
    MetaManager.save(meta);
    return true;
  }
  
  static recordRun(survivalSeconds, totalKills, maxCombo) {
    const meta = MetaManager.load();
    const earned = MetaManager.earnPoints(survivalSeconds, totalKills, maxCombo);
    meta.totalPoints += earned;
    meta.bestTime = Math.max(meta.bestTime, survivalSeconds);
    meta.totalRuns++;
    MetaManager.save(meta);
    return earned;
  }
  
  static getBonusStats() {
    const meta = MetaManager.load();
    return {
      bonusHP: meta.upgrades.startHP * 20,
      bonusTempResist: meta.upgrades.startTempResist * 0.05,
      bonusWood: meta.upgrades.startWood * 3,
      extraCardChoices: meta.upgrades.extraCard
    };
  }
  
  static reset() {
    try { localStorage.removeItem(MetaManager.META_KEY); } catch(e) {}
  }
}
// ‚ïê‚ïê‚ïê END META PROGRESSION ‚ïê‚ïê‚ïê

// ‚ïê‚ïê‚ïê üé¥ UPGRADE SYSTEM (Î±ÄÏÑú Ïä§ÌÉÄÏùº) ‚ïê‚ïê‚ïê
const UPGRADE_CATEGORIES = {
  combat: { color: '#EF5350', bgColor: 0xC62828, borderColor: '#EF5350', icon: '‚öîÔ∏è', name: 'Ï†ÑÌà¨' },
  survival: { color: '#42A5F5', bgColor: 0x1565C0, borderColor: '#42A5F5', icon: 'üõ°Ô∏è', name: 'ÏÉùÏ°¥' },
  economy: { color: '#FFD700', bgColor: 0xF9A825, borderColor: '#FFD700', icon: 'üí∞', name: 'Í≤ΩÏ†ú' },
  special: { color: '#CE93D8', bgColor: 0x7B1FA2, borderColor: '#CE93D8', icon: '‚ú®', name: 'ÌäπÏàò' },
};

const UPGRADES = {
  // Ï†ÑÌà¨ (Îπ®Í∞ï)
  DAMAGE_UP:    { name: 'Í∞ïÎ†•Ìïú ÏùºÍ≤©', desc: '+25% Í≥µÍ≤©Î†•', icon: 'üó°Ô∏è', category: 'combat', maxLevel: 5, rarity: 'common' },
  ATTACK_SPEED: { name: 'Îπ†Î•∏ ÏÜêÎÜÄÎ¶º', desc: '+20% Í≥µÍ≤©ÏÜçÎèÑ', icon: '‚ö°', category: 'combat', maxLevel: 4, rarity: 'common' },
  CRITICAL:     { name: 'ÏπòÎ™ÖÌÉÄ', desc: '+10% ÌÅ¨Î¶¨Ìã∞Ïª¨', icon: 'üí•', category: 'combat', maxLevel: 3, rarity: 'rare' },
  LIFESTEAL:    { name: 'ÏÉùÎ™Ö Ìù°Ïàò', desc: 'Í≥µÍ≤© Ïãú Ï≤¥Î†• +1', icon: 'ü©∏', category: 'combat', maxLevel: 3, rarity: 'rare' },
  KNOCKBACK:    { name: 'Í∞ïÌÉÄ', desc: '+ÎÑâÎ∞± Í±∞Î¶¨', icon: 'üí®', category: 'combat', maxLevel: 2, rarity: 'epic' },
  // ÏÉùÏ°¥ (ÌååÎûë)
  MAX_HP:       { name: 'ÌäºÌäºÌï®', desc: '+20 ÏµúÎåÄ Ï≤¥Î†•', icon: '‚ù§Ô∏è', category: 'survival', maxLevel: 5, rarity: 'common' },
  WARMTH:       { name: 'Î∞©ÌïúÎ≥µ', desc: '+Ï≤¥Ïò® Ï†ÄÌï≠', icon: 'üß•', category: 'survival', maxLevel: 4, rarity: 'common' },
  REGEN:        { name: 'ÏûêÏó∞ ÌöåÎ≥µ', desc: '+Ï¥àÎãπ Ï≤¥Î†• ÌöåÎ≥µ', icon: 'üíö', category: 'survival', maxLevel: 3, rarity: 'rare' },
  MOVEMENT:     { name: 'ÎÇ†Î†µÌï®', desc: '+15% Ïù¥ÎèôÏÜçÎèÑ', icon: 'üëü', category: 'survival', maxLevel: 4, rarity: 'common' },
  DODGE:        { name: 'ÌöåÌîº', desc: '+10% ÌöåÌîºÏú®', icon: 'üåÄ', category: 'survival', maxLevel: 2, rarity: 'epic' },
  // Í≤ΩÏ†ú (ÎÖ∏Îûë)
  LOOT_BONUS:   { name: 'ÌñâÏö¥', desc: '+50% ÎìúÎ°≠Î•†', icon: 'üçÄ', category: 'economy', maxLevel: 4, rarity: 'common' },
  WOOD_BONUS:   { name: 'Î≤åÎ™©Íæº', desc: '+ÎÇòÎ¨¥ ÌöçÎìùÎüâ', icon: 'ü™ì', category: 'economy', maxLevel: 3, rarity: 'common' },
  STONE_BONUS:  { name: 'Ï±ÑÍµ¥Íæº', desc: '+Îèå ÌöçÎìùÎüâ', icon: '‚õèÔ∏è', category: 'economy', maxLevel: 3, rarity: 'common' },
  STORAGE:      { name: 'ÌÅ∞ Í∞ÄÎ∞©', desc: '+25 Î≥¥Í¥ÄÌï®', icon: 'üéí', category: 'economy', maxLevel: 4, rarity: 'common' },
  SELL_BONUS:   { name: 'ÏÉÅÏà†', desc: '+ÌåêÎß§ Í∞ÄÍ≤©', icon: 'üè∑Ô∏è', category: 'economy', maxLevel: 3, rarity: 'rare' },
  // ÌäπÏàò (Î≥¥Îùº)
  MAGNET:       { name: 'ÏûêÏÑù', desc: 'ÏïÑÏù¥ÌÖú ÏûêÎèô ÏàòÏßë Î≤îÏúÑ+', icon: 'üß≤', category: 'special', maxLevel: 2, rarity: 'epic' },
  MULTI_HIT:    { name: 'Í¥ÄÌÜµ', desc: 'Ï†Å 2Î™ÖÍπåÏßÄ Í≥µÍ≤©', icon: 'üî±', category: 'special', maxLevel: 2, rarity: 'epic' },
  EXPLOSION:    { name: 'Ìè≠Î∞ú', desc: 'Ï≤òÏπò Ïãú Ìè≠Î∞ú Îç∞ÎØ∏ÏßÄ', icon: 'üí£', category: 'special', maxLevel: 2, rarity: 'epic' },
  CAMPFIRE_BOOST:{ name: 'ÌôîÎçï ÎßàÏä§ÌÑ∞', desc: 'ÌôîÎçï Ìö®Í≥º +50%', icon: 'üî•', category: 'special', maxLevel: 2, rarity: 'rare' },
  TIME_BONUS:   { name: 'ÏãúÍ∞Ñ Ï°∞Ïûë', desc: 'Ïø®Îã§Ïö¥ -20%', icon: '‚è±Ô∏è', category: 'special', maxLevel: 2, rarity: 'rare' },
  // === Ï∂îÍ∞Ä 10Ï¢Ö ===
  FROST_RESISTANCE: { name: 'ÎèôÏÉÅ Ï†ÄÌï≠', desc: 'ÌïúÌåå Ïò®ÎèÑ Í∞êÏÜå -30%', icon: 'üßä', category: 'survival', maxLevel: 3, rarity: 'rare' },
  BERSERKER:        { name: 'Í¥ëÏ†ÑÏÇ¨', desc: 'HP 50% Ïù¥Ìïò Ïãú Í≥µÍ≤©Î†• +50%', icon: 'üò§', category: 'combat', maxLevel: 2, rarity: 'epic' },
  CHAIN_ATTACK:     { name: 'Ïó∞ÏáÑ Í≥µÍ≤©', desc: 'Ï≤òÏπò Ïãú Ïù∏Ï†ë Ï†ÅÏóêÍ≤å 50% Îç∞ÎØ∏ÏßÄ', icon: '‚õìÔ∏è', category: 'combat', maxLevel: 2, rarity: 'epic' },
  TREASURE_HUNTER:  { name: 'Î≥¥Î¨º ÏÇ¨ÎÉ•Íæº', desc: 'ÏÉÅÏûê ÎìúÎ°≠ ÌôïÎ•† +40%', icon: 'üó∫Ô∏è', category: 'economy', maxLevel: 3, rarity: 'rare' },
  SWIFT_STRIKE:     { name: 'Ïó∞ÏÜç ÏùºÍ≤©', desc: 'Ï≤´ Î≤àÏß∏ Í≥µÍ≤© Ïø®Îã§Ïö¥ Ï¶âÏãú', icon: 'üå™Ô∏è', category: 'combat', maxLevel: 2, rarity: 'rare' },
  FROST_WALKER:     { name: 'ÏÑúÎ¶¨ Î∞úÍ±∏Ïùå', desc: 'Ïù¥Îèô Ïãú Ï£ºÎ≥Ä Ï†Å Ïä¨Î°úÏö∞ 10%', icon: '‚ùÑÔ∏è', category: 'special', maxLevel: 2, rarity: 'rare' },
  VAMPIRE:          { name: 'Ìù°ÌòàÍ∑Ä', desc: 'Ï≤òÏπò Ïãú Ï≤¥Î†• +5 ÌöåÎ≥µ', icon: 'üßõ', category: 'combat', maxLevel: 3, rarity: 'rare' },
  ARMOR:            { name: 'Î∞©Ïñ¥Íµ¨', desc: 'Î∞õÎäî Îç∞ÎØ∏ÏßÄ -20%', icon: 'üõ°Ô∏è', category: 'survival', maxLevel: 3, rarity: 'common' },
  WINTER_HEART:     { name: 'Í≤®Ïö∏ Ïã¨Ïû•', desc: 'ÌïúÌåå Ï§ë Í≥µÍ≤©Î†• +20%', icon: 'üíô', category: 'special', maxLevel: 2, rarity: 'epic' },
  SCAVENGER:        { name: 'ÏïΩÌÉàÏûê', desc: 'ÏûêÏõê Ï±ÑÏ∑® ÏÜçÎèÑ +30%', icon: 'ü¶Ö', category: 'economy', maxLevel: 3, rarity: 'common' },
  // === Ï∂îÍ∞Ä 10Ï¢Ö (Phase 2) ===
  CHAIN_LIGHTNING:   { name: 'Ïó∞ÏáÑ Î≤àÍ∞ú', desc: 'Í≥µÍ≤©Ïù¥ 2ÎßàÎ¶¨ÏóêÍ≤å Ïó∞ÏáÑ (30% Îç∞ÎØ∏ÏßÄ)', icon: '‚ö°', category: 'combat', maxLevel: 2, rarity: 'epic' },
  ICE_AURA:          { name: 'ÏñºÏùå Ïò§Îùº', desc: 'Ï£ºÎ≥Ä 100px Ï†Å Ïù¥ÎèôÏÜçÎèÑ -30%', icon: '‚ùÑÔ∏è', category: 'special', maxLevel: 2, rarity: 'rare' },
  LIFE_STEAL_PCT:    { name: 'ÏÉùÎ™Ö Ìù°Ïàò%', desc: 'Îç∞ÎØ∏ÏßÄÏùò 10%Î•º HPÎ°ú ÌöåÎ≥µ', icon: 'ü©∏', category: 'survival', maxLevel: 3, rarity: 'rare' },
  SHIELD_BASH:       { name: 'Î∞©Ìå® Í∞ïÌÉÄ', desc: '5Ï¥àÎßàÎã§ Îã§Ïùå Í≥µÍ≤©Ïù¥ Ïä§ÌÑ¥(0.5Ï¥à)', icon: 'üõ°Ô∏è', category: 'combat', maxLevel: 2, rarity: 'rare' },
  DOUBLE_SHOT:       { name: 'ÎçîÎ∏îÏÉ∑', desc: '30% ÌôïÎ•†Î°ú Í≥µÍ≤© 2Ìöå Î∞úÏÇ¨', icon: 'üéØ', category: 'combat', maxLevel: 2, rarity: 'epic' },
  THORNS:            { name: 'Í∞ÄÏãú Í∞ëÏò∑', desc: 'ÌîºÍ≤© Ïãú Í≥µÍ≤©ÏûêÏóêÍ≤å 5 Î∞òÏÇ¨ Îç∞ÎØ∏ÏßÄ', icon: 'üåµ', category: 'survival', maxLevel: 3, rarity: 'common' },
  TIME_WARP:         { name: 'ÏãúÍ∞Ñ ÏôúÍ≥°', desc: '15Ï¥àÎßàÎã§ Ï£ºÎ≥Ä Ï†Å 1Ï¥à ÎèôÍ≤∞', icon: '‚è∞', category: 'special', maxLevel: 2, rarity: 'epic' },
  XP_SCAVENGER:      { name: 'ÏàòÏßëÍ∞Ä', desc: 'XP ÌöçÎìù Î≤îÏúÑ +50%', icon: 'üß≤', category: 'economy', maxLevel: 2, rarity: 'common' },
  ADRENALINE:        { name: 'ÏïÑÎìúÎ†àÎÇ†Î¶∞', desc: 'HP 30% Ïù¥Ìïò Ïãú Í≥µÍ≤©ÏÜçÎèÑ +50%', icon: 'üíâ', category: 'combat', maxLevel: 2, rarity: 'rare' },
  BLIZZARD_CLOAK:    { name: 'ÏÑ§Ïõê ÎßùÌÜ†', desc: 'ÌïúÌåå Ï§ë Ïù¥ÎèôÏÜçÎèÑ Ìå®ÎÑêÌã∞ ÏóÜÏùå', icon: 'üß•', category: 'survival', maxLevel: 1, rarity: 'rare' },
  // ‚ïê‚ïê‚ïê ÌÅ¥ÎûòÏä§ Í≥†Ïú† ÏóÖÍ∑∏Î†àÏù¥Îìú ‚ïê‚ïê‚ïê
  CLASS_WARRIOR_ROAR: { name: 'Ï†ÑÏÇ¨Ïùò Ìè¨Ìö®', desc: 'Ï£ºÎ≥Ä 100px Ï†Å 2Ï¥à Í≥µÌè¨(Ïù¥ÎèôÏ†ïÏßÄ)', icon: 'ü™ì', category: 'combat', maxLevel: 1, rarity: 'legendary', classOnly: 'warrior' },
  CLASS_MAGE_BLIZZARD: { name: 'ÏñºÏùå Ìè≠Ìíç', desc: 'Ï†ÑÏ≤¥ Ï†Å 1Ï¥à ÎèôÍ≤∞ (Ïø®Îã§Ïö¥ 30Ï¥à)', icon: 'üßä', category: 'special', maxLevel: 1, rarity: 'legendary', classOnly: 'mage' },
  CLASS_SURVIVOR_SPRINT: { name: 'ÏßàÏ£º', desc: '3Ï¥àÍ∞Ñ Ïù¥ÏÜç 3Î∞∞+Î¨¥Ï†Å (Ïø®Îã§Ïö¥ 20Ï¥à)', icon: 'üèÉ', category: 'survival', maxLevel: 1, rarity: 'legendary', classOnly: 'survivor' },
  CLASS_SHAMAN_SPIRIT: { name: 'Ï†ïÎ†π ÏÜåÌôò', desc: 'Ï†ïÎ†πÏù¥ 10Ï¥àÍ∞Ñ Ï†ÅÏóê Ï¥àÎãπ 15 Îç∞ÎØ∏ÏßÄ+XP ÏûêÎèô ÏàòÏßë (Ïø®Îã§Ïö¥ 30Ï¥à)', icon: 'üîÆ', category: 'special', maxLevel: 1, rarity: 'legendary', classOnly: 'shaman' },
  CLASS_SHAMAN_STORM: { name: 'Ï†ïÎ†πÏùò Ìè≠Ìíç', desc: 'Ï†ïÎ†πÏù¥ 30Ï¥àÍ∞Ñ ÌôîÎ©¥ Ï†ÑÏ≤¥Î•º ÎèåÎ©∞ 50 Îç∞ÎØ∏ÏßÄ Í¥ëÏó≠ Í≥µÍ≤© (Ïø®Îã§Ïö¥ 45Ï¥à)', icon: 'üåÄ', category: 'special', maxLevel: 1, rarity: 'legendary', classOnly: 'shaman' },
  CLASS_HUNTER_VOLLEY: { name: 'ÏßëÏ§ë ÏÇ¨Í≤©', desc: 'Í∞ÄÏû• Í∞ÄÍπåÏö¥ Ï†Å 5ÎßàÎ¶¨ÏóêÍ≤å 3Ï¥àÍ∞Ñ Ïó∞ÏÜç ÌôîÏÇ¥ Î∞úÏÇ¨ (Ïø®Îã§Ïö¥ 25Ï¥à)', icon: 'üèπ', category: 'combat', maxLevel: 1, rarity: 'legendary', classOnly: 'hunter' },
  CLASS_HUNTER_POISON: { name: 'ÎèÖÌôîÏÇ¥', desc: 'Í≥µÍ≤©Ïù¥ DoT ÎèÖ Ìö®Í≥º (Ï¥àÎãπ 10 Îç∞ÎØ∏ÏßÄ, 5Ï¥à, Ï§ëÏ≤© Í∞ÄÎä•)', icon: '‚ò†Ô∏è', category: 'combat', maxLevel: 1, rarity: 'legendary', classOnly: 'hunter' },
  // ‚ïê‚ïê‚ïê ÏóîÎìúÍ≤åÏûÑ Ï†ÑÏö© ÏóÖÍ∑∏Î†àÏù¥Îìú (60Î∂Ñ Ïù¥ÌõÑ Î¨¥Ìïú Î™®Îìú) ‚ïê‚ïê‚ïê
  GODLIKE_POWER:     { name: 'Ïã†Ïùò Ï∂ïÎ≥µ', desc: 'Î™®Îì† Ïä§ÌÉØ +50%', icon: 'üëë', category: 'special', maxLevel: 1, rarity: 'unique', endgameOnly: true },
  IMMORTAL_WILL:     { name: 'Î∂àÎ©∏Ïùò ÏùòÏßÄ', desc: 'HP+200, HPÌöåÎ≥µ +5/s', icon: 'üíñ', category: 'survival', maxLevel: 1, rarity: 'unique', endgameOnly: true },
  TIME_WARP_ULTRA:   { name: 'ÏãúÍ∞Ñ Í∞ÄÏÜç', desc: 'Í≥µÍ≤©ÏÜçÎèÑ +100%, Ïø®Îã§Ïö¥ -50%', icon: '‚è©', category: 'combat', maxLevel: 1, rarity: 'unique', endgameOnly: true },
  FROZEN_WORLD:      { name: 'ÏñºÏñ¥Î∂ôÏùÄ ÏÑ∏Í≥Ñ', desc: 'Î™®Îì† Ï†Å Ïù¥ÎèôÏÜçÎèÑ -60%', icon: 'üå®Ô∏è', category: 'special', maxLevel: 1, rarity: 'unique', endgameOnly: true },
  SPIRIT_BOMB:       { name: 'Ï†ïÎ†πÏùò Ìè≠ÌÉÑ', desc: 'Îß§ 10Ï¥àÎßàÎã§ ÌôîÎ©¥ Ï†ÑÏ≤¥ 50 Îç∞ÎØ∏ÏßÄ', icon: 'üí•', category: 'combat', maxLevel: 1, rarity: 'unique', endgameOnly: true },
  // ‚ïê‚ïê‚ïê ÏÉà Ï†Å ÎåÄÏùë + ÏõîÎìú Ïò§Î∏åÏ†ùÌä∏ ÏãúÎÑàÏßÄ ÏóÖÍ∑∏Î†àÏù¥Îìú 8Ï¢Ö ‚ïê‚ïê‚ïê
  COLD_RESISTANCE:   { name: 'ÎÉâÍ∏∞ Ï†ÄÌï≠', desc: 'ÏñºÏùåÏÇ¨ÎÉ•Íæº Ïä¨Î°úÏö∞ 50%‚Üì, ÌïúÌåå ÌîºÌï¥ 20%‚Üì', icon: 'üõ°Ô∏è', category: 'survival', maxLevel: 2, rarity: 'uncommon' },
  SPLIT_EXPLOSION:   { name: 'Î∂ÑÏó¥ Ìè≠Î∞ú', desc: 'Î∂ÑÏó¥Ïä¨ÎùºÏûÑ Ï≤òÏπò‚ÜíÎØ∏ÎãàÌè≠Î∞ú+XP 50%‚Üë', icon: 'üí•', category: 'combat', maxLevel: 2, rarity: 'rare' },
  SHAMAN_HUNTER:     { name: 'ÏÉ§Î®º ÏÇ¨ÎÉ•Íæº', desc: 'ÏÉ§Î®º Í≥µÍ≤©Î†•+30%, Ï≤òÏπò Ïãú HP+15', icon: 'üîÆ', category: 'combat', maxLevel: 2, rarity: 'uncommon' },
  HEARTH_MASTER:     { name: 'ÌôîÎ°ØÍ∞Ä Í∞ïÌôî', desc: 'Î™®Îã•Î∂à ÌöåÎ≥µ+50%, Î∞òÍ≤Ω+40px', icon: 'üî•', category: 'survival', maxLevel: 2, rarity: 'uncommon' },
  SUPPLY_EXPERT:     { name: 'Î≥¥Í∏â Ï†ÑÎ¨∏Í∞Ä', desc: 'Î≥¥Í∏âÏÉÅÏûê ÌöåÎ≥µ+50%, Í∞úÎ∞© Ïãú XP+30', icon: 'üì¶', category: 'survival', maxLevel: 1, rarity: 'common' },
  FLARE_EXPERT:      { name: 'Ïã†Ìò∏ÌÉÑ Ï†ÑÎ¨∏Í∞Ä', desc: 'XP2Î∞∞ +15Ï¥à, ÏàòÏßë Ïãú Í≥µÏÜç+20%(15Ï¥à)', icon: 'üß≤', category: 'special', maxLevel: 2, rarity: 'rare' },
  GLACIAL_WALL:      { name: 'ÏñºÏùå Ïû•Î≤Ω Í∞ïÌôî', desc: 'Ïû•Î≤Ω HP 2Î∞∞, Í∑ºÏ≤ò Î∞©Ïñ¥Î†•+15%', icon: '‚ùÑÔ∏è', category: 'special', maxLevel: 2, rarity: 'uncommon' },
  ARCTIC_ADAPT:      { name: 'Í∑πÌïú Ï†ÅÏùë', desc: 'ÌïúÌåå Ï§ë Ïù¥ÏÜç Ïó≠Ï†Ñ+5%, Ï¢ÖÎ£å ÌõÑ Í≥µÏÜç+25%', icon: '‚ö°', category: 'survival', maxLevel: 1, rarity: 'epic' },
};

// ‚ïê‚ïê‚ïê ÌîåÎ†àÏù¥Ïñ¥ ÌÅ¥ÎûòÏä§ ÏãúÏä§ÌÖú ‚ïê‚ïê‚ïê
const PLAYER_CLASSES = {
  warrior: {
    name: 'Ï†ÑÏÇ¨', icon: 'ü™ì', color: '#FF4444', colorHex: 0xFF4444,
    desc: 'Í∑ºÏ†ë Ï†ÑÌà¨ ÌäπÌôî. ÎÜíÏùÄ Ï≤¥Î†•Í≥º Í≥µÍ≤©Î†•.',
    stats: { hp: 120, damageMul: 1.3, speedMul: 0.9, attackSpeedMul: 1.0, attackRangeMul: 1.0, warmthResist: 0 },
    passives: ['ÌÇ¨ Ïãú 5% HP+2 ÌöåÎ≥µ', 'HP 50% Ïù¥Ìïò‚ÜíÍ≥µÍ≤©Î†• 1.5x (Î∂ÑÎÖ∏)'],
    startItem: { slot: 'weapon', itemId: 'knife', grade: 'common' },
    ratings: { hp: 4, atk: 4, spd: 3, surv: 5 },
  },
  mage: {
    name: 'ÎßàÎ≤ïÏÇ¨', icon: 'üßä', color: '#4488FF', colorHex: 0x4488FF,
    desc: 'Î≤îÏúÑ Í≥µÍ≤© ÌäπÌôî. Í¥ÄÌÜµ+ÎèôÍ≤∞ Ìö®Í≥º.',
    stats: { hp: 80, damageMul: 1.1, speedMul: 1.0, attackSpeedMul: 1.3, attackRangeMul: 1.5, warmthResist: 0 },
    passives: ['Í≥µÍ≤© Í¥ÄÌÜµ (Îã§Ïàò Ï†Å ÌûàÌä∏)', 'ÌÇ¨ Ïãú 10% ÏñºÏùå Ìè≠Î∞ú'],
    startItem: { slot: 'ring', itemId: 'ruby_ring', grade: 'common' },
    ratings: { hp: 3, atk: 3, spd: 4, surv: 2 },
  },
  survivor: {
    name: 'ÏÉùÏ°¥Í∞Ä', icon: 'üèÉ', color: '#44DD44', colorHex: 0x44DD44,
    desc: 'Îπ†Î•∏ Ïù¥ÎèôÍ≥º ÌïúÌåå Ï†ÄÌï≠. ÏÉùÏ°¥ ÌäπÌôî.',
    stats: { hp: 90, damageMul: 1.0, speedMul: 1.4, attackSpeedMul: 1.0, attackRangeMul: 1.0, warmthResist: 0.3 },
    passives: ['Ïù¥Îèô Ï§ë 15% ÌöåÌîº', 'ÌïúÌåå Ïù¥ÏÜç Ìå®ÎÑêÌã∞ ÏóÜÏùå'],
    startItem: { slot: 'boots', itemId: 'wind_boots', grade: 'common' },
    ratings: { hp: 3.5, atk: 2, spd: 5, surv: 4 },
  },
  shaman: {
    name: 'Î¨¥Îãπ', icon: 'üîÆ', color: '#9B59B6', colorHex: 0x9B59B6,
    desc: 'ÏûêÏó∞Ïùò ÌûòÏùÑ Îã§Î£®Îäî ÏßÄÏõêÌòï. XP 1.5x, ÏòÅÌòº Íµ¨Ïä¨+Ï†ïÎ†π ÏÜåÌôò.',
    stats: { hp: 95, damageMul: 1.0, speedMul: 1.1, attackSpeedMul: 1.0, attackRangeMul: 1.0, warmthResist: 0, xpMul: 1.5 },
    passives: ['Ï≤òÏπò Ïãú 10% ÏòÅÌòº Íµ¨Ïä¨ (HP+5)', 'Ï∫†ÌîÑÌååÏù¥Ïñ¥ 150pxÎÇ¥ Ï†Ñ Ïä§ÌÉØ+15%'],
    startItem: { slot: 'ring', itemId: 'legend_ring', grade: 'common' },
    ratings: { hp: 3, atk: 2, spd: 3, surv: 4, special: 5 },
  },
  hunter: {
    name: 'ÏÇ¨ÎÉ•Íæº', icon: 'üèπ', color: '#8B4513', colorHex: 0x8B4513,
    desc: 'ÏõêÍ±∞Î¶¨ Í≥µÍ≤© ÌäπÌôî. Î©ÄÎ¶¨ÏÑú Îçî Í∞ïÌïú Îç∞ÎØ∏ÏßÄ.',
    stats: { hp: 85, damageMul: 1.2, speedMul: 1.2, attackSpeedMul: 1.0, attackRangeMul: 2.0, warmthResist: 0 },
    passives: ['ÏõêÍ±∞Î¶¨ 1.5x / Í∑ºÏ†ë 0.7x (Ï†ÄÍ≤©Ïàò)', '15Ï¥àÎßàÎã§ Ìï®Ï†ï ÏÑ§Ïπò (ÎèôÍ≤∞+50dmg)'],
    startItem: { slot: 'weapon', itemId: 'spear', grade: 'common' },
    ratings: { hp: 2, atk: 4, spd: 3, surv: 2, special: 4 },
  },
};

// ‚ïê‚ïê‚ïê ÎÇúÏù¥ÎèÑ Î™®Îìú ÏãúÏä§ÌÖú ‚ïê‚ïê‚ïê
const DIFFICULTY_MODES = {
  normal: { id: 'normal', name: 'üåø ÏùºÎ∞ò', color: '#44DD44', colorHex: 0x44DD44, warn: '',
    enemyHP: 1.0, enemyDmg: 1.0, spawnRate: 1.0, coldDmg: 1.0, xpMul: 1.0, dropMul: 1.0, clearBonus: 10 },
  hard: { id: 'hard', name: 'üî• ÌïòÎìú', color: '#FF8800', colorHex: 0xFF8800, warn: 'Ï†ÅÏù¥ Í∞ïÌï¥ÏßëÎãàÎã§',
    enemyHP: 1.5, enemyDmg: 1.5, spawnRate: 1.3, coldDmg: 1.5, xpMul: 1.2, dropMul: 1.2, clearBonus: 25 },
  hell: { id: 'hell', name: 'üíÄ ÏßÄÏò•', color: '#FF2222', colorHex: 0xFF2222, warn: 'üíÄ ÏÇ¥ÏïÑÎÇ®ÏùÑ Ïàò ÏûàÏùÑÍπå?',
    enemyHP: 2.5, enemyDmg: 2.5, spawnRate: 2.0, coldDmg: 2.0, xpMul: 1.5, dropMul: 1.5, clearBonus: 50 },
};

// ‚ïê‚ïê‚ïê Îç∞ÏùºÎ¶¨ Ï±åÎ¶∞ÏßÄ ÏãúÏä§ÌÖú ‚ïê‚ïê‚ïê
const DAILY_CHALLENGES = [
  { id: 'no_equipment', name: 'Îß®ÏÜê ÎèÑÏ†Ñ', desc: 'Ïû•ÎπÑ ÎìúÎ°≠ ÏóÜÏùå. Ïä§ÌÇ¨ÎßåÏúºÎ°ú ÏÉùÏ°¥!', modifier: { noEquipDrop: true } },
  { id: 'speed_run', name: 'Ïä§ÌîºÎìúÎü∞', desc: '30Î∂Ñ ÏïàÏóê Î†àÎ≤® 20 Îã¨ÏÑ± Ïãú ÌÅ¥Î¶¨Ïñ¥!', modifier: { winCondition: 'level20in30' } },
  { id: 'one_upgrade', name: 'Îã®Ïùº ÎπåÎìú', desc: 'ÏóÖÍ∑∏Î†àÏù¥ÎìúÎ•º 1Ï¢ÖÎ•òÎßå ÏÑ†ÌÉù Í∞ÄÎä•', modifier: { singleUpgrade: true } },
  { id: 'blizzard_always', name: 'ÏòÅÍµ¨ ÌïúÌåå', desc: 'Ìï≠ÏÉÅ ÌïúÌåå ÌôúÏÑ±Ìôî', modifier: { alwaysBlizzard: true } },
  { id: 'glass_cannon', name: 'Ïú†Î¶¨ ÎåÄÌè¨', desc: 'HP 30, Í≥µÍ≤©Î†• 3Î∞∞', modifier: { hp: 30, damageMult: 3.0 } },
  { id: 'pacifist', name: 'ÌèâÌôîÏ£ºÏùò', desc: '30Î∂Ñ ÏÉùÏ°¥ Ïãú ÌÅ¥Î¶¨Ïñ¥ (Í≥µÍ≤© Î∂àÍ∞Ä!)', modifier: { noAttack: true, winCondition: 'survive30' } },
  { id: 'boss_rush', name: 'Î≥¥Ïä§ Îü¨Ïãú', desc: 'Î≥¥Ïä§Í∞Ä 10Î∂ÑÎßàÎã§ Îì±Ïû•', modifier: { bossInterval: 600 } },
];

function getTodayChallenge() {
  const today = new Date();
  const seed = today.getFullYear() * 10000 + (today.getMonth() + 1) * 100 + today.getDate();
  return DAILY_CHALLENGES[seed % DAILY_CHALLENGES.length];
}

function getDailyChallengeKey() {
  const today = new Date();
  return `daily_${today.getFullYear()}_${today.getMonth()+1}_${today.getDate()}`;
}

// ‚ïê‚ïê‚ïê Í≤ΩÌóòÏπò(XP) ÏãúÏä§ÌÖú ‚ïê‚ïê‚ïê
const XP_TABLE = [0, 12, 20, 30, 42, 55, 70, 90, 115, 145, 180, 220, 270, 330, 400, 490, 600, 730, 900, 1100, 1350];
const XP_SOURCES = {
  rabbit: 5, deer: 8, penguin: 6, seal: 12,
  wolf: 18, bear: 35, ice_golem: 60, snow_leopard: 25, ice_hunter: 22, splitting_slime: 30, blizzard_shaman: 35, boss: 80, tree: 2, rock: 2, gold: 5,
  default: 5,
};

// ‚ïê‚ïê‚ïê ÌïúÌåå Ïä§ÏºÄÏ§Ñ ‚ïê‚ïê‚ïê
const BLIZZARD_SCHEDULE = [
  { startMs: 3*60*1000,      duration: 25*1000, tempMult: 1.8, reward: { boxes: 1, gold: 15 } },
  { startMs: 7*60*1000,      duration: 30*1000, tempMult: 2.2, reward: { boxes: 1, gold: 25 } },
  { startMs: 12*60*1000,     duration: 35*1000, tempMult: 2.6, reward: { boxes: 2, gold: 40 } },
  { startMs: 18*60*1000,     duration: 40*1000, tempMult: 3.0, reward: { boxes: 2, gold: 60 } },
  { startMs: 25*60*1000,     duration: 45*1000, tempMult: 3.5, reward: { boxes: 2, gold: 80 } },
  { startMs: 33*60*1000,     duration: 50*1000, tempMult: 4.0, reward: { boxes: 3, gold: 100 } },
  { startMs: 42*60*1000,     duration: 55*1000, tempMult: 4.5, reward: { boxes: 3, gold: 130 } },
  { startMs: 52*60*1000,     duration: 60*1000, tempMult: 5.0, reward: { boxes: 4, gold: 160 } },
];

// ‚ïê‚ïê‚ïê Îßµ Íµ¨Ïó≠ ÏãúÏä§ÌÖú ‚ïê‚ïê‚ïê
const MAP_CENTER = { x: 1200, y: 1200 };
const ZONE_RADII = { safe: 300, normal: 700, danger: 1000 };
const ZONE_TEMP_DECAY = { safe: 0, normal: -1, danger: -2, extreme: -4 };

// ‚ïê‚ïê‚ïê Ïû•ÎπÑ ÏãúÎÑàÏßÄ ÌûåÌä∏ ‚ïê‚ïê‚ïê
const UPGRADE_SYNERGY = {
  LOOT_BONUS: 'üí° Ïû•ÎπÑ ÎìúÎ°≠Î•†ÎèÑ Ï¶ùÍ∞Ä!',
  TREASURE_HUNTER: 'üí° Ïû•ÎπÑ ÎìúÎ°≠Î•†ÎèÑ Ï¶ùÍ∞Ä!',
  DAMAGE_UP: 'üí° Î¨¥Í∏∞ Ïû•ÎπÑÏôÄ ÏãúÎÑàÏßÄ!',
  ATTACK_SPEED: 'üí° Î¨¥Í∏∞ Ïû•ÎπÑÏôÄ ÏãúÎÑàÏßÄ!',
  CRITICAL: 'üí° Î¨¥Í∏∞ Ïû•ÎπÑÏôÄ ÏãúÎÑàÏßÄ!',
  MAX_HP: 'üí° Í∞ëÏò∑ Ïû•ÎπÑÏôÄ ÏãúÎÑàÏßÄ!',
  ARMOR: 'üí° Í∞ëÏò∑ Ïû•ÎπÑÏôÄ ÏãúÎÑàÏßÄ!',
  MOVEMENT: 'üí° Ïã†Î∞ú Ïû•ÎπÑÏôÄ ÏãúÎÑàÏßÄ!',
  DODGE: 'üí° Ïã†Î∞ú Ïû•ÎπÑÏôÄ ÏãúÎÑàÏßÄ!',
  CAMPFIRE_BOOST: 'üí° Ï∫†ÌîÑÌååÏù¥Ïñ¥ HP ÌöåÎ≥µ Í∞ïÌôî!',
  COLD_RESISTANCE: 'üí° ÏñºÏùåÏÇ¨ÎÉ•Íæº+ÌïúÌåå ÎåÄÏùë!',
  SPLIT_EXPLOSION: 'üí° Î∂ÑÏó¥Ïä¨ÎùºÏûÑ Ï≤òÏπò Ïãú Ìè≠Î∞ú!',
  SHAMAN_HUNTER: 'üí° ÏÉ§Î®º ÌäπÌö® Í≥µÍ≤©!',
  HEARTH_MASTER: 'üí° Î™®Îã•Î∂à ÏãúÎÑàÏßÄ Í∞ïÌôî!',
  SUPPLY_EXPERT: 'üí° Î≥¥Í∏âÏÉÅÏûê Ìö®Ïú® Í∑πÎåÄÌôî!',
  FLARE_EXPERT: 'üí° Ïã†Ìò∏ÌÉÑ XP Î≤ÑÌîÑ Ïó∞Ïû•!',
  GLACIAL_WALL: 'üí° ÏñºÏùå Ïû•Î≤Ω Î∞©Ïñ¥ ÏãúÎÑàÏßÄ!',
  ARCTIC_ADAPT: 'üí° ÌïúÌååÎ•º Ïù¥Ï†êÏúºÎ°ú!',
};

// ‚ïê‚ïê‚ïê üîó SKILL SYNERGY SYSTEM ‚ïê‚ïê‚ïê
const SKILL_SYNERGIES = [
  {
    id: 'berserker', name: 'üî¥ Í¥ëÏ†ÑÏÇ¨', emoji: 'üî¥',
    desc: 'Í≥µÍ≤©Î†•+Í≥µÍ≤©ÏÜçÎèÑ ‚Üí Ï∂îÍ∞Ä Í≥µÍ≤©Î†• +20%',
    requires: ['DAMAGE_UP', 'ATTACK_SPEED'],
    bonus: { damageMultiplier: 0.20 }
  },
  {
    id: 'ironwall', name: 'üõ°Ô∏è Ï≤†Î≤Ω', emoji: 'üõ°Ô∏è',
    desc: 'HPÍ∞ïÌôî+Î∞©Ïñ¥Î†• ‚Üí 15% ÌôïÎ•† Îç∞ÎØ∏ÏßÄ Î¨¥Ìö®',
    requires: ['MAX_HP', 'ARMOR'],
    bonus: { blockChance: 0.15 }
  },
  {
    id: 'swift_hunter', name: 'üå™Ô∏è Ïã†ÏÜç ÏÇ¨ÎÉ•Íæº', emoji: 'üå™Ô∏è',
    desc: 'Ïù¥ÎèôÏÜçÎèÑ+ÎÑâÎ∞± ‚Üí Ïù¥ÎèôÏÜçÎèÑ Ï∂îÍ∞Ä +15%',
    requires: ['MOVEMENT', 'KNOCKBACK'],
    bonus: { speedMultiplier: 0.15 }
  },
  {
    id: 'lucky_finder', name: 'üçÄ ÌñâÏö¥ÏïÑ', emoji: 'üçÄ',
    desc: 'ÌñâÏö¥+Î≥¥Î¨ºÏÇ¨ÎÉ• ‚Üí Ïû•ÎπÑ ÎìúÎ°≠Î•† +5%',
    requires: ['LOOT_BONUS', 'TREASURE_HUNTER'],
    bonus: { extraDropRate: 0.05 }
  },
  {
    id: 'cold_master', name: '‚ùÑÔ∏è ÌïúÌåå ÏßÄÎ∞∞Ïûê', emoji: '‚ùÑÔ∏è',
    desc: 'ÌïúÌååÏ†ÄÌï≠+HPÌöåÎ≥µ ‚Üí 5Ï¥àÎßàÎã§ ÌïúÌåå Î¨¥Ìö®',
    requires: ['FROST_RESISTANCE', 'REGEN'],
    bonus: { coldImmunityPulse: 5 }
  }
];

class SynergyManager {
  constructor() {
    this.activeSynergies = new Set();
    this.coldImmunityTimer = 0;
  }

  checkSynergies(upgradeManager, scene) {
    SKILL_SYNERGIES.forEach(syn => {
      if (this.activeSynergies.has(syn.id)) return;
      const allMet = syn.requires.every(id => upgradeManager.getLevel(id) >= 1);
      if (allMet) {
        this.activeSynergies.add(syn.id);
        this.applySynergy(syn, scene);
        if (scene._questProgress) scene._questProgress.synergy_activated++;
        this.showSynergyPopup(syn, scene);
      }
    });
  }

  applySynergy(syn, scene) {
    switch (syn.id) {
      case 'berserker':
        scene.playerDamage = Math.round(scene.playerDamage * (1 + syn.bonus.damageMultiplier) * 100) / 100;
        break;
      case 'ironwall':
        scene._synergyBlockChance = syn.bonus.blockChance;
        break;
      case 'swift_hunter':
        scene.playerBaseSpeed *= (1 + syn.bonus.speedMultiplier);
        scene.playerSpeed = scene.playerBaseSpeed;
        scene.playerBaseSpeed = Math.min(350, scene.playerBaseSpeed);
        scene.playerSpeed = Math.min(350, scene.playerSpeed);
        break;
      case 'lucky_finder':
        scene._synergyExtraDropRate = syn.bonus.extraDropRate;
        break;
      case 'cold_master':
        scene._synergyColdImmunity = true;
        this.coldImmunityTimer = 0;
        break;
    }
  }

  updateColdImmunity(dt, scene) {
    if (!scene._synergyColdImmunity) return;
    this.coldImmunityTimer += dt;
    if (this.coldImmunityTimer >= 5) {
      this.coldImmunityTimer -= 5;
      scene._coldImmunePulse = true;
      if (scene.player && scene.player.active) scene.showFloatingText(scene.player.x, scene.player.y - 40, '‚ùÑÔ∏è ÌïúÌåå Î¨¥Ìö®!', '#88DDFF');
    }
  }

  showSynergyPopup(syn, scene) {
    const cam = scene.cameras.main;
    const t = scene.add.text(cam.width / 2, cam.height * 0.4,
      '‚ú® ' + syn.name + ' ÏãúÎÑàÏßÄ Î∞úÎèô!', { // track synergy for quest
      fontSize: '28px', fontFamily: 'monospace', color: '#FFD700',
      stroke: '#000', strokeThickness: 5, fontStyle: 'bold',
      shadow: { offsetX: 0, offsetY: 0, color: '#FF8C00', blur: 15, fill: true }
    }).setScrollFactor(0).setDepth(250).setOrigin(0.5).setAlpha(0);

    const desc = scene.add.text(cam.width / 2, cam.height * 0.4 + 35,
      syn.desc, {
      fontSize: '16px', fontFamily: 'monospace', color: '#FFFFFF',
      stroke: '#000', strokeThickness: 3
    }).setScrollFactor(0).setDepth(250).setOrigin(0.5).setAlpha(0);

    scene.tweens.add({
      targets: [t, desc], alpha: 1, scale: { from: 0.5, to: 1.1 }, duration: 400, ease: 'Back.Out',
      onComplete: () => {
        scene.tweens.add({ targets: [t, desc], alpha: 0, y: '-=30', duration: 1000, delay: 1500,
          onComplete: () => { t.destroy(); desc.destroy(); }
        });
      }
    });

    scene.cameras.main.flash(300, 255, 200, 0, true);
  }

  renderHUD(scene) {
    // Clear old HUD
    if (this._hudElements) this._hudElements.forEach(e => { try { e.destroy(); } catch(ex) {} });
    this._hudElements = [];
    if (this.activeSynergies.size === 0) return;

    const cam = scene.cameras.main;
    let idx = 0;
    SKILL_SYNERGIES.forEach(syn => {
      if (!this.activeSynergies.has(syn.id)) return;
      const x = 20 + idx * 28;
      const y = cam.height - 30;
      const bg = scene.add.circle(x, y, 12, 0x333333, 0.7).setScrollFactor(0).setDepth(150);
      const icon = scene.add.text(x, y, syn.emoji, {
        fontSize: '14px'
      }).setScrollFactor(0).setDepth(151).setOrigin(0.5);
      this._hudElements.push(bg, icon);
      idx++;
    });
  }

  toJSON() { return { active: [...this.activeSynergies], coldTimer: this.coldImmunityTimer }; }
  fromJSON(data, scene) {
    if (!data) return;
    this.activeSynergies = new Set(data.active || []);
    this.coldImmunityTimer = data.coldTimer || 0;
    // Re-apply effects
    SKILL_SYNERGIES.forEach(syn => {
      if (this.activeSynergies.has(syn.id)) this.applySynergy(syn, scene);
    });
  }
}
// ‚ïê‚ïê‚ïê END SKILL SYNERGY ‚ïê‚ïê‚ïê

const RARITY_WEIGHTS = { common: 70, uncommon: 50, rare: 25, epic: 5, unique: 3 };
const RARITY_LABELS = { common: { name: 'ÏùºÎ∞ò', color: '#9E9E9E' }, rare: { name: 'Ìù¨Í∑Ä', color: '#2196F3' }, epic: { name: 'ÏóêÌîΩ', color: '#9C27B0' } };
const GRADE_COLORS = { common: '#9E9E9E', uncommon: '#4CAF50', rare: '#2196F3', epic: '#9C27B0', legend: '#FF9800' };

// ‚ïê‚ïê‚ïê EQUIPMENT SYSTEM ‚ïê‚ïê‚ïê
const EQUIP_GRADES = ['common','rare','epic','legendary','unique'];
const EQUIP_GRADE_COLORS = { common:'#9E9E9E', rare:'#2196F3', epic:'#9C27B0', legendary:'#FFD700', unique:'#FF4081' };
const EQUIP_GRADE_LABELS = { common:'ÏùºÎ∞ò', rare:'Ìù¨Í∑Ä', epic:'ÏóêÌîΩ', legendary:'Ï†ÑÏÑ§', unique:'Í≥†Ïú†' };
const EQUIP_GRADE_WEIGHTS = { common:55, rare:30, epic:12, legendary:2.5, unique:0.5 };
const EQUIP_SLOT_ICONS = { weapon:'‚öîÔ∏è', armor:'üõ°Ô∏è', boots:'üë¢', helmet:'üé©', ring:'üíç' };

const EQUIPMENT_TABLE = {
  weapon: [
    { id:'stick', name:'ÎÇòÎ¨¥ÏûëÎåÄÍ∏∞', icon:'ü™µ', effects:{ atkMul:0.10 } },
    { id:'knife', name:'ÏÇ¨ÎÉ•Ïπº', icon:'üî™', effects:{ atkMul:0.20, aspdMul:0.10 } },
    { id:'axe', name:'ÎèÑÎÅº', icon:'ü™ì', effects:{ atkMul:0.40 } },
    { id:'spear', name:'ÏñºÏùåÏ∞Ω', icon:'üî±', effects:{ atkMul:0.30 } },
    { id:'fire_sword', name:'ÌôîÏóºÍ≤Ä', icon:'üó°Ô∏è', effects:{ atkMul:0.50 } },
    { id:'legend_sword', name:'Ï†ÑÏÑ§ÏùòÍ≤Ä', icon:'‚öîÔ∏è', effects:{ atkMul:0.80, aspdMul:0.20 } }
  ],
  armor: [
    { id:'rabbit_coat', name:'ÌÜ†ÎÅºÌÑ∏ÏΩîÌä∏', icon:'üê∞', effects:{ hpFlat:20 } },
    { id:'wolf_hide', name:'ÎäëÎåÄÍ∞ÄÏ£Ω', icon:'üê∫', effects:{ hpFlat:40, defMul:0.10 } },
    { id:'bear_hide', name:'Í≥∞Í∞ÄÏ£Ω', icon:'üêª', effects:{ hpFlat:60, defMul:0.20 } },
    { id:'iron_armor', name:'Ï≤†Í∞ëÏò∑', icon:'üõ°Ô∏è', effects:{ hpFlat:80, defMul:0.30 } },
    { id:'hero_armor', name:'Ïö©ÏÇ¨Í∞ëÏò∑', icon:'ü¶∏', effects:{ hpFlat:120, defMul:0.40 } }
  ],
  boots: [
    { id:'old_boots', name:'ÎÇ°ÏùÄÏã†Î∞ú', icon:'üëû', effects:{ spdMul:0.10 } },
    { id:'fur_boots', name:'ÌÑ∏Ïû•Ìôî', icon:'ü•æ', effects:{ spdMul:0.15, coldRes:0.05 } },
    { id:'swift_boots', name:'Îπ†Î•∏Ïû•Ìôî', icon:'üëü', effects:{ spdMul:0.25 } },
    { id:'snowshoes', name:'ÏÑ§ÏÉÅÌôî', icon:'üéø', effects:{ spdMul:0.20, dodgeMul:0.10 } },
    { id:'wind_boots', name:'Î∞îÎûåÏû•Ìôî', icon:'üí®', effects:{ spdMul:0.35, dodgeMul:0.15 } }
  ],
  helmet: [
    { id:'fur_hat', name:'ÌÑ∏Î™®Ïûê', icon:'üß¢', effects:{ coldRes:0.10 } },
    { id:'camp_hat', name:'Ï∫†ÌîÑÌååÏù¥Ïñ¥Î™®Ïûê', icon:'üî•', effects:{ regenPS:0.5 } },
    { id:'battle_helm', name:'Ï†ÑÌà¨Ìà¨Íµ¨', icon:'‚õëÔ∏è', effects:{ hpFlat:30, defMul:0.10 } },
    { id:'crystal_helm', name:'ÏàòÏ†ïÌà¨Íµ¨', icon:'üíé', effects:{ coldRes:0.20, regenPS:1 } },
    { id:'hero_helm', name:'Ïö©ÏÇ¨Ìà¨Íµ¨', icon:'üëë', effects:{ hpFlat:60, regenPS:2 } }
  ],
  ring: [
    { id:'wood_ring', name:'ÎÇòÎ¨¥Î∞òÏßÄ', icon:'üü§', effects:{ xpMul:0.10 } },
    { id:'silver_ring', name:'ÏùÄÎ∞òÏßÄ', icon:'‚ö™', effects:{ xpMul:0.15, luckFlat:5 } },
    { id:'gold_ring', name:'Í∏àÎ∞òÏßÄ', icon:'üü°', effects:{ xpMul:0.20, luckFlat:10 } },
    { id:'ruby_ring', name:'Î£®ÎπÑÎ∞òÏßÄ', icon:'üî¥', effects:{ luckFlat:20, atkMul:0.10 } },
    { id:'legend_ring', name:'Ï†ÑÏÑ§Î∞òÏßÄ', icon:'üíç', effects:{ xpMul:0.30, luckFlat:30, atkMul:0.10 } }
  ]
};

// ‚ïê‚ïê‚ïê üèÜ ACHIEVEMENT SYSTEM ‚ïê‚ïê‚ïê
const ACHIEVEMENTS = [
  { id: 'first_blood',    name: 'Ï≤´ ÏÇ¨ÎÉ•',     desc: 'Ï≤´ Ï†Å Ï≤òÏπò',           icon: 'üéØ' },
  { id: 'survivor_5',     name: '5Î∂Ñ ÏÉùÏ°¥',    desc: '5Î∂Ñ Ïù¥ÏÉÅ ÏÉùÏ°¥',        icon: '‚è±Ô∏è' },
  { id: 'combo_10',       name: 'Ïó∞ÏÜç ÌïôÏÇ¥',   desc: '10ÌÇ¨ ÏΩ§Î≥¥ Îã¨ÏÑ±',       icon: 'üî•' },
  { id: 'level_10',       name: 'ÏàôÎ†®Ïûê',      desc: 'Î†àÎ≤® 10 Îã¨ÏÑ±',         icon: '‚≠ê' },
  { id: 'equipment_rare', name: 'Ìù¨Í∑Ä Î∞úÍ≤¨',   desc: 'Ìù¨Í∑Ä Ïû•ÎπÑ Ï≤´ ÌöçÎìù',    icon: 'üíô' },
  { id: 'equipment_epic', name: 'ÏóêÌîΩ Î∞úÍ≤¨',   desc: 'ÏóêÌîΩ Ïû•ÎπÑ Ï≤´ ÌöçÎìù',    icon: 'üíú' },
  { id: 'boss_kill',      name: 'Î≥¥Ïä§ ÏÇ¨ÎÉ•Íæº', desc: 'Î≥¥Ïä§ Ï≤òÏπò',            icon: 'üíÄ' },
  { id: 'craft_1',        name: 'Ïó∞Í∏àÏà†ÏÇ¨',    desc: 'Ïû•ÎπÑ Ìï©ÏÑ± 1Ìöå',        icon: '‚öóÔ∏è' },
  { id: 'survivor_30',    name: 'Í∞ïÏù∏Ìïú Ïûê',   desc: '30Î∂Ñ ÏÉùÏ°¥',            icon: 'üõ°Ô∏è' },
  { id: 'kills_100',      name: 'ÎåÄÌïôÏÇ¥',      desc: '100ÎßàÎ¶¨ Ï≤òÏπò',         icon: '‚ò†Ô∏è' },
  { id: 'secret_hidden_boss', name: 'ÎπÑÎ∞Ä ÏÇ¨ÎÉ•Íæº', desc: 'Ïà®Í≤®ÏßÑ Î≥¥Ïä§ Ï≤òÏπò', icon: 'üëÅÔ∏è', hidden: true },
  { id: 'secret_konami',      name: 'Ï†ÑÏÑ§Ïùò ÏΩîÎìú', desc: '???',              icon: 'üéÆ', hidden: true },
  { id: 'secret_survive_zone',name: 'Í∑πÌïú ÌÉêÌóòÍ∞Ä', desc: 'Í∑πÌïú Íµ¨Ïó≠ 5Î∂Ñ ÏÉùÏ°¥', icon: 'üèîÔ∏è', hidden: true },
  // ÌÅ¥ÎûòÏä§ ÎßàÏä§ÌÑ∞Î¶¨ (5Ï¢Ö)
  { id: 'class_warrior',   name: 'Ï†ÑÏÇ¨ ÎßàÏä§ÌÑ∞',   desc: 'Ï†ÑÏÇ¨Î°ú 60Î∂Ñ ÌÅ¥Î¶¨Ïñ¥',     icon: 'ü™ì', category: 'class' },
  { id: 'class_mage',      name: 'ÎßàÎ≤ïÏÇ¨ ÎßàÏä§ÌÑ∞',  desc: 'ÎßàÎ≤ïÏÇ¨Î°ú 60Î∂Ñ ÌÅ¥Î¶¨Ïñ¥',    icon: 'üßä', category: 'class' },
  { id: 'class_survivor',  name: 'ÏÉùÏ°¥Í∞Ä ÎßàÏä§ÌÑ∞',  desc: 'ÏÉùÏ°¥Í∞ÄÎ°ú 60Î∂Ñ ÌÅ¥Î¶¨Ïñ¥',    icon: 'üèÉ', category: 'class' },
  { id: 'class_shaman',    name: 'Î¨¥Îãπ ÎßàÏä§ÌÑ∞',    desc: 'Î¨¥ÎãπÏúºÎ°ú 60Î∂Ñ ÌÅ¥Î¶¨Ïñ¥',    icon: 'üîÆ', category: 'class' },
  { id: 'class_hunter',    name: 'ÏÇ¨ÎÉ•Íæº ÎßàÏä§ÌÑ∞',  desc: 'ÏÇ¨ÎÉ•ÍæºÏúºÎ°ú 60Î∂Ñ ÌÅ¥Î¶¨Ïñ¥',  icon: 'üèπ', category: 'class' },
  // ÎèÑÏ†Ñ Î™®Îìú (4Ï¢Ö)
  { id: 'boss_rush_clear', name: 'Î≥¥Ïä§ ÏÇ¨ÎÉ•Íæº',   desc: 'Î≥¥Ïä§ Îü¨Ïãú ÌÅ¥Î¶¨Ïñ¥',         icon: 'üî¥', category: 'challenge' },
  { id: 'ng_plus_clear',   name: 'Ï†ÑÏÑ§ÏùÑ ÎÑòÏñ¥',   desc: 'NG+ Î™®Îìú ÌÅ¥Î¶¨Ïñ¥',          icon: '‚≠ê', category: 'challenge' },
  { id: 'endless_30',      name: 'ÏòÅÏõêÌïú ÏÉùÏ°¥',   desc: 'Î¨¥Ìïú Î™®Îìú 30Î∂Ñ Ï∂îÍ∞Ä ÏÉùÏ°¥', icon: '‚ôæÔ∏è', category: 'challenge' },
  { id: 'hard_clear',      name: 'Í∞ïÏ≤† ÏùòÏßÄ',     desc: 'ÌïòÎìú Ïù¥ÏÉÅ ÎÇúÏù¥ÎèÑ ÌÅ¥Î¶¨Ïñ¥',  icon: 'üî•', category: 'challenge' },
  { id: 'speedrun_clear',  name: 'Î≤àÍ∞úÏ≤òÎüº',     desc: 'Ïä§ÌîºÎìúÎü∞ Î™®Îìú ÌÅ¥Î¶¨Ïñ¥',     icon: '‚ö°', category: 'challenge' },
  { id: 'speedrun_sub_20', name: '20Î∂Ñ Î≤Ω',       desc: 'Ïä§ÌîºÎìúÎü∞ 20Î∂Ñ ÎÇ¥ ÌÅ¥Î¶¨Ïñ¥', icon: '‚ö°', category: 'challenge' },
  { id: 'handicap_win',    name: 'Ïó≠Í≤Ω Í∑πÎ≥µ',     desc: 'Ìï∏ÎîîÏ∫° Î™®ÎìúÎ°ú ÌÅ¥Î¶¨Ïñ¥',    icon: 'üéØ', category: 'challenge' },
  // ÏàòÏßë/ÌÉêÌóò (3Ï¢Ö)
  { id: 'all_equipment',   name: 'ÏàòÏßëÍ∞Ä',        desc: 'Î™®Îì† Ïû•ÎπÑ Ïä¨Î°ØÏóê ÏóêÌîΩ Ïù¥ÏÉÅ Ïû•Ï∞©', icon: 'üíú', category: 'collect' },
  { id: 'all_zones',       name: 'ÌÉêÌóòÍ∞Ä',        desc: 'Î™®Îì† ÏßÄÏó≠ Î∞©Î¨∏',            icon: 'üó∫Ô∏è', category: 'collect' },
  { id: 'all_synergies',   name: 'ÏãúÎÑàÏßÄ ÎßàÏä§ÌÑ∞', desc: '5Í∞ÄÏßÄ ÏãúÎÑàÏßÄ Î™®Îëê Î∞úÎèô',    icon: '‚ö°', category: 'collect' },
];

const RANDOM_EVENTS = [
  { id: 'airdrop',       name: 'üì¶ Í≥µÏ§ë Î≥¥Í∏â',       desc: 'Î≥¥Í∏âÌíàÏù¥ Ìà¨ÌïòÎê©ÎãàÎã§!',                       action: 'spawn_chest' },
  { id: 'blizzard_rush', name: 'üå®Ô∏è ÎßπÎ†¨Ìïú ÎààÎ≥¥Îùº',  desc: 'Í∑πÌïúÏùò ÌïúÌåå! 30Ï¥àÍ∞Ñ ÌïúÌåå Îç∞ÎØ∏ÏßÄ 2Î∞∞.',       action: 'blizzard_double', duration: 30 },
  { id: 'enemy_rush',    name: 'üê∫ ÎñºÏßÄÏñ¥ Ïò§Îã§',     desc: 'Ï†ÅÎì§Ïù¥ Î™∞Î†§ÏòµÎãàÎã§! 30Ï¥àÍ∞Ñ Ïä§Ìè∞ 3Î∞∞.',       action: 'spawn_rush',      duration: 30 },
  { id: 'golden_fever',  name: '‚ú® Ìô©Í∏à ÏãúÍ∞Ñ',       desc: '30Ï¥àÍ∞Ñ Ïû•ÎπÑ ÎìúÎ°≠Î•† 3Î∞∞!',                   action: 'drop_fever',      duration: 30 },
  { id: 'healing_spring',name: 'üî• Îî∞ÎúªÌïú Î¥Ñ',       desc: '30Ï¥àÍ∞Ñ HP ÌöåÎ≥µ ÏÜçÎèÑ 5Î∞∞!',                  action: 'heal_boost',      duration: 30 },
  { id: 'merchant',      name: 'üßë‚Äçü§ù‚Äçüßë ÌñâÏÉÅÏù∏ Î∞©Î¨∏',    desc: 'ÌñâÏÉÅÏù∏Ïù¥ ÎÇòÌÉÄÎÇ¨Îã§! Î≥¥Í∏â ÏÉÅÏûêÍ∞Ä Ï∂úÌòÑÌï©ÎãàÎã§.',action: 'spawn_chest' },
  { id: 'equipment_bonus', name: 'üéÅ Ïû•ÎπÑ Î≥¥Í∏â', desc: '30Ï¥àÍ∞Ñ Ïû•ÎπÑ ÎìúÎ°≠Î•† 5Î∞∞!', action: 'equip_bonus_5x', duration: 30 },
  { id: 'xp_feast',        name: 'üìö ÏßÄÏãùÏùò Ìè≠Î∞ú', desc: '30Ï¥àÍ∞Ñ XP ÌöçÎìù 3Î∞∞!',   action: 'xp_triple', duration: 30 },
  { id: 'shield_wall',     name: 'üõ°Ô∏è Ïã†ÏÑ±Ìïú Î∞©Ïñ¥', desc: '30Ï¥àÍ∞Ñ ÌîºÌï¥ 50% Í∞êÏÜå',  action: 'damage_reduce', duration: 30 },
  { id: 'mega_combo',      name: 'üî• ÌÇ¨ Í¥ëÎûÄ', desc: 'Îã§Ïùå 10ÌÇ¨ÏùÄ XP 3Î∞∞',        action: 'combo_xp', charges: 10 },
  { id: 'class_boost',     name: '‚ú® ÌÅ¥ÎûòÏä§ Í∞ÅÏÑ±', desc: '30Ï¥àÍ∞Ñ ÌÅ¥ÎûòÏä§ Ïä§ÌÇ¨ Ïø®Îã§Ïö¥ 0', action: 'class_cd_zero', duration: 30 },
];

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// üèÖ RecordManager ‚Äî Í∞úÏù∏ Í∏∞Î°ù Í¥ÄÎ¶¨
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
class RecordManager {
  static KEY = 'whiteout_records';

  static _default() {
    return {
      bestSurvivalTime: 0, bestKills: 0, bestLevel: 0, bestCombo: 0,
      totalPlays: 0, totalKills: 0, totalPlayTime: 0, wins: 0, achievementsUnlocked: 0,
      longestEndlessSurvival: 0, totalQuestsCompleted: 0, ngPlusClears: 0,
      bossRushClears: 0, hardClears: 0,
      speedrunClears: 0, bestSpeedrunTime: 0, handicapClears: 0
    };
  }

  static load() {
    try {
      const raw = localStorage.getItem(RecordManager.KEY);
      return raw ? { ...RecordManager._default(), ...JSON.parse(raw) } : RecordManager._default();
    } catch(e) { return RecordManager._default(); }
  }

  static save(data) {
    try { localStorage.setItem(RecordManager.KEY, JSON.stringify(data)); } catch(e) {}
  }

  /** Í≤åÏûÑ Ï¢ÖÎ£å Ïãú Ìò∏Ï∂ú. Ïã†Í∏∞Î°ù Ìï≠Î™© Î∞∞Ïó¥ Î∞òÌôò */
  static recordRun(survivalTime, kills, level, combo, isWin, achievementsCount) {
    const rec = RecordManager.load();
    const newRecords = [];

    if (survivalTime > rec.bestSurvivalTime) { rec.bestSurvivalTime = survivalTime; newRecords.push('survivalTime'); }
    if (kills > rec.bestKills) { rec.bestKills = kills; newRecords.push('kills'); }
    if (level > rec.bestLevel) { rec.bestLevel = level; newRecords.push('level'); }
    if (combo > rec.bestCombo) { rec.bestCombo = combo; newRecords.push('combo'); }

    rec.totalPlays++;
    rec.totalKills += kills;
    rec.totalPlayTime += survivalTime;
    if (isWin) rec.wins++;
    if (typeof achievementsCount === 'number') rec.achievementsUnlocked = achievementsCount;

    RecordManager.save(rec);
    return newRecords;
  }

  static formatTime(seconds) {
    const h = Math.floor(seconds / 3600);
    const m = Math.floor((seconds % 3600) / 60);
    const s = Math.floor(seconds % 60);
    if (h > 0) return `${h}ÏãúÍ∞Ñ ${m}Î∂Ñ`;
    return `${m}Î∂Ñ ${s}Ï¥à`;
  }
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// üèÜ Ï†êÏàò Í≥ÑÏÇ∞ + Îì±Í∏â ÏãúÏä§ÌÖú
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
class ScoreSystem {
  static GRADE_TABLE = [
    { min: 1000000, grade: 'S+', title: 'Ï†ÑÏÑ§Ïùò ÏÉùÏ°¥Ïûê', color: '#FFD700' },
    { min: 500000,  grade: 'S',  title: 'ÎààÌè≠ÌíçÏùò ÏßÄÎ∞∞Ïûê', color: '#C0C0C0' },
    { min: 200000,  grade: 'A',  title: 'ÏñºÏùåÏùò Ìà¨ÏÇ¨', color: '#4488FF' },
    { min: 100000,  grade: 'B',  title: 'ÌòπÌïúÏùò Ï†ÑÏÇ¨', color: '#44DD44' },
    { min: 50000,   grade: 'C',  title: 'ÏÉùÏ°¥Ïûê', color: '#CCDDEE' },
    { min: 0,       grade: 'D',  title: 'Í≤®Ïö∏Ïùò Ï¥àÎ≥¥Ïûê', color: '#888888' },
  ];

  static PERCENTILE_TABLE = [
    { min: 1000000, pct: 1 },
    { min: 500000,  pct: 5 },
    { min: 200000,  pct: 15 },
    { min: 100000,  pct: 30 },
    { min: 50000,   pct: 50 },
    { min: 20000,   pct: 70 },
    { min: 0,       pct: 95 },
  ];

  static calculate(opts) {
    const { survivalTime, kills, maxCombo, level, difficulty, handicap, equipmentManager, isSpeedrun, speedrunRemaining } = opts;
    let base = Math.floor(survivalTime) * 100
      + kills * 10
      + maxCombo * 50
      + level * 200;
    // Equipment grade sum
    if (equipmentManager) {
      const gradeValues = { common: 1, rare: 2, epic: 3, legendary: 4, unique: 5 };
      for (const item of Object.values(equipmentManager.slots || {})) {
        if (item && item.grade) base += (gradeValues[item.grade] || 0) * 300;
      }
    }
    // Difficulty multiplier
    const diffMul = { normal: 1, hard: 1.5, hell: 2.5 };
    base = Math.floor(base * (diffMul[difficulty] || 1));
    // Handicap bonus (+10% each)
    if (handicap && handicap !== 'none') {
      base = Math.floor(base * 1.1);
    }
    // Speedrun time bonus
    if (isSpeedrun && speedrunRemaining > 0) {
      base += Math.floor(speedrunRemaining) * 50;
    }
    return base;
  }

  static getGrade(score) {
    if (score === undefined || score === null || isNaN(score)) return ScoreSystem.GRADE_TABLE[ScoreSystem.GRADE_TABLE.length - 1];
    for (const entry of ScoreSystem.GRADE_TABLE) {
      if (score >= entry.min) return entry;
    }
    return ScoreSystem.GRADE_TABLE[ScoreSystem.GRADE_TABLE.length - 1];
  }

  static getPercentile(score) {
    for (const entry of ScoreSystem.PERCENTILE_TABLE) {
      if (score >= entry.min) return entry.pct;
    }
    return 99;
  }

  static SCORES_KEY = 'whiteout_scores';
  static saveScore(scoreData) {
    try {
      let arr = JSON.parse(localStorage.getItem(ScoreSystem.SCORES_KEY) || '[]');
      arr.unshift(scoreData);
      if (arr.length > 5) arr = arr.slice(0, 5);
      localStorage.setItem(ScoreSystem.SCORES_KEY, JSON.stringify(arr));
    } catch(e) {}
    // Update bestScore in RecordManager
    try {
      const rec = RecordManager.load();
      if (!rec.bestScore || scoreData.score > rec.bestScore) {
        rec.bestScore = scoreData.score;
        RecordManager.save(rec);
      }
    } catch(e) {}
  }

  static loadScores() {
    try { return JSON.parse(localStorage.getItem(ScoreSystem.SCORES_KEY) || '[]'); } catch(e) { return []; }
  }

  static formatScore(n) {
    if (n === undefined || n === null || isNaN(n)) n = 0;
    return n.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',');
  }
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// üé® ÌîåÎ†àÏù¥Ïñ¥ Ïä§ÌÇ® ÏãúÏä§ÌÖú
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
const PLAYER_SKINS = [
  { id: 'default',       name: 'Í∏∞Î≥∏',         color: 0xFFFFFF, outline: 0x888888, unlockCondition: 'always' },
  { id: 'warrior_red',   name: 'Ï†ÑÏÇ¨Ïùò Î∂âÏùå',  color: 0xFF4444, outline: 0xCC0000, unlockCondition: 'class_warrior_win' },
  { id: 'mage_blue',     name: 'ÎßàÎ≤ïÏÇ¨Ïùò Ìë∏Î¶Ñ', color: 0x44AAFF, outline: 0x0066CC, unlockCondition: 'class_mage_win' },
  { id: 'survivor_green',name: 'ÏÉùÏ°¥Í∞ÄÏùò Ï¥àÎ°ù', color: 0x44FF88, outline: 0x00AA44, unlockCondition: 'class_survivor_win' },
  { id: 'golden',        name: 'Ìô©Í∏à ÏòÅÏõÖ',    color: 0xFFD700, outline: 0xB8860B, unlockCondition: 'win_once' },
  { id: 'shadow',        name: 'Ïñ¥Îë†Ïùò Ï†ÑÏÇ¨',  color: 0x444444, outline: 0x222222, unlockCondition: 'kills_100_total' },
  { id: 'icy',           name: 'ÏñºÏùå Íµ∞Ï£º',    color: 0xAAEEFF, outline: 0x66CCEE, unlockCondition: 'achievements_5' },
  { id: 'legendary',     name: 'Ï†ÑÏÑ§Ïùò Ïûê',    color: 0xFF8C00, outline: 0xFF4500, unlockCondition: 'endless_60min' },
  { id: 'shaman_purple', name: 'Î¨¥ÎãπÏùò ÏòÅÌòº',  color: 0x9B59B6, outline: 0x6C3483, unlockCondition: 'class_shaman_win' },
  { id: 'hunter_brown',  name: 'ÏÑ§ÏõêÏùò ÏÇ¨ÎÉ•Íæº', color: 0x8B4513, outline: 0x6B3A2A, unlockCondition: 'class_hunter_win' },
];

const ACHIEVEMENT_REWARDS = {
  first_blood:    { type: 'meta_points', amount: 2 },
  survivor_5:     { type: 'meta_points', amount: 5 },
  combo_10:       { type: 'meta_points', amount: 10 },
  level_10:       { type: 'meta_points', amount: 8 },
  equipment_rare: { type: 'skin_unlock', skinId: 'default' },
  equipment_epic: { type: 'meta_points', amount: 15 },
  boss_kill:      { type: 'meta_points', amount: 20 },
  craft_1:        { type: 'meta_points', amount: 5 },
  survivor_30:    { type: 'meta_points', amount: 30 },
  kills_100:      { type: 'skin_unlock', skinId: 'shadow' },
  // ÌÅ¥ÎûòÏä§ ÎßàÏä§ÌÑ∞Î¶¨
  class_warrior:   { type: 'meta_points', amount: 15 },
  class_mage:      { type: 'meta_points', amount: 15 },
  class_survivor:  { type: 'meta_points', amount: 15 },
  class_shaman:    { type: 'meta_points', amount: 15 },
  class_hunter:    { type: 'meta_points', amount: 15 },
  // ÎèÑÏ†Ñ Î™®Îìú
  boss_rush_clear: { type: 'meta_points', amount: 25 },
  ng_plus_clear:   { type: 'meta_points', amount: 30 },
  endless_30:      { type: 'meta_points', amount: 30 },
  hard_clear:      { type: 'meta_points', amount: 20 },
  // ÏàòÏßë/ÌÉêÌóò
  all_equipment:   { type: 'meta_points', amount: 20 },
  all_zones:       { type: 'meta_points', amount: 15 },
  all_synergies:   { type: 'meta_points', amount: 25 },
};

class SkinManager {
  static KEY = 'whiteout_skins';
  static SELECTED_KEY = 'whiteout_selected_skin';

  static load() {
    try {
      return JSON.parse(localStorage.getItem(SkinManager.KEY) || '{}');
    } catch(e) { return {}; }
  }

  static save(data) {
    try { localStorage.setItem(SkinManager.KEY, JSON.stringify(data)); } catch(e) {}
  }

  static getSelectedId() {
    return localStorage.getItem(SkinManager.SELECTED_KEY) || 'default';
  }

  static getCurrentSkin() {
    const id = SkinManager.getSelectedId();
    return PLAYER_SKINS.find(s => s.id === id) || PLAYER_SKINS[0];
  }

  static select(skinId) {
    if (SkinManager.isUnlocked(skinId)) {
      try { localStorage.setItem(SkinManager.SELECTED_KEY, skinId); } catch(e) {}
    }
  }

  static isUnlocked(skinId) {
    const skin = PLAYER_SKINS.find(s => s.id === skinId);
    if (!skin) return false;
    return SkinManager._checkCondition(skin.unlockCondition);
  }

  static _checkCondition(cond) {
    if (cond === 'always') return true;
    const rec = RecordManager.load();
    let achCount = 0;
    try { achCount = Object.keys(JSON.parse(localStorage.getItem('achievements_whiteout') || '{}')).length; } catch(e) {}

    switch (cond) {
      case 'win_once': return rec.wins >= 1;
      case 'kills_100_total': return rec.totalKills >= 100;
      case 'achievements_5': return achCount >= 5;
      case 'endless_60min': return (rec.longestEndlessSurvival || 0) >= 3600;
      case 'class_warrior_win': return SkinManager._classWin('warrior');
      case 'class_mage_win': return SkinManager._classWin('mage');
      case 'class_survivor_win': return SkinManager._classWin('survivor');
      case 'class_shaman_win': return SkinManager._classWin('shaman');
      case 'class_hunter_win': return SkinManager._classWin('hunter');
      default: return false;
    }
  }

  static _classWin(cls) {
    try {
      const data = JSON.parse(localStorage.getItem('whiteout_class_wins') || '{}');
      return !!data[cls];
    } catch(e) { return false; }
  }

  static recordClassWin(cls) {
    try {
      const data = JSON.parse(localStorage.getItem('whiteout_class_wins') || '{}');
      data[cls] = true;
      localStorage.setItem('whiteout_class_wins', JSON.stringify(data));
    } catch(e) {}
  }

  static getUnlockDescription(cond) {
    const descs = {
      'always': 'Í∏∞Î≥∏ Ìï¥Ï†ú',
      'class_warrior_win': 'Ï†ÑÏÇ¨Î°ú 60Î∂Ñ ÌÅ¥Î¶¨Ïñ¥',
      'class_mage_win': 'ÎßàÎ≤ïÏÇ¨Î°ú 60Î∂Ñ ÌÅ¥Î¶¨Ïñ¥',
      'class_survivor_win': 'ÏÉùÏ°¥Í∞ÄÎ°ú 60Î∂Ñ ÌÅ¥Î¶¨Ïñ¥',
      'class_shaman_win': 'Î¨¥ÎãπÏúºÎ°ú 60Î∂Ñ ÌÅ¥Î¶¨Ïñ¥',
      'class_hunter_win': 'ÏÇ¨ÎÉ•ÍæºÏúºÎ°ú 60Î∂Ñ ÌÅ¥Î¶¨Ïñ¥',
      'win_once': '1Ìöå ÌÅ¥Î¶¨Ïñ¥',
      'kills_100_total': 'ÎàÑÏ†Å ÌÇ¨ 100 Ïù¥ÏÉÅ',
      'achievements_5': 'ÏÑ±Ï∑® 5Í∞ú Ïù¥ÏÉÅ Îã¨ÏÑ±',
      'endless_60min': 'Î¨¥Ìïú Î™®Îìú 60Î∂Ñ ÏÉùÏ°¥',
    };
    return descs[cond] || '???';
  }

  static getUnlockedCount() {
    return PLAYER_SKINS.filter(s => SkinManager.isUnlocked(s.id)).length;
  }
}

class EquipmentManager {
  static STORAGE_KEY = 'whiteout_equipment';

  constructor() {
    this.slots = { weapon:null, armor:null, boots:null, helmet:null, ring:null };
    this.inventory = { weapon:[], armor:[], boots:[], helmet:[], ring:[] };
    this.load();
  }

  load() {
    try {
      const raw = localStorage.getItem(EquipmentManager.STORAGE_KEY);
      if (raw) {
        const saved = JSON.parse(raw);
        Object.keys(this.slots).forEach(s => { if (saved[s]) this.slots[s] = saved[s]; });
        if (saved._inventory) {
          Object.keys(this.inventory).forEach(s => { if (saved._inventory[s]) this.inventory[s] = saved._inventory[s]; });
        }
      }
    } catch(e) {}
  }

  save() {
    const data = { ...this.slots, _inventory: this.inventory };
    try { localStorage.setItem(EquipmentManager.STORAGE_KEY, JSON.stringify(data)); } catch(e) {}
  }

  // Try equipping; returns true if equipped (upgrade)
  tryEquip(slot, itemId, grade) {
    const current = this.slots[slot];
    const gradeIdx = EQUIP_GRADES.indexOf(grade);
    if (current) {
      const curIdx = EQUIP_GRADES.indexOf(current.grade);
      if (gradeIdx <= curIdx) return false; // not an upgrade
    }
    this.slots[slot] = { itemId, grade };
    this.save();
    EquipmentManager.recordDiscovered(slot, itemId);
    return true;
  }

  getItemDef(slot) {
    const eq = this.slots[slot];
    if (!eq) return null;
    const list = EQUIPMENT_TABLE[slot];
    return list ? list.find(i => i.id === eq.itemId) : null;
  }

  // Aggregate all equipment bonuses (30% nerfed for balance)
  getTotalBonuses() {
    const b = { atkMul:0, aspdMul:0, hpFlat:0, defMul:0, spdMul:0, dodgeMul:0, coldRes:0, regenPS:0, xpMul:0, luckFlat:0 };
    const EQUIP_NERF = 0.7; // Ïû•ÎπÑ Ìö®Í≥º 30% ÌïòÌñ•
    for (const slot of Object.keys(this.slots)) {
      const def = this.getItemDef(slot);
      if (!def) continue;
      const gradeIdx = EQUIP_GRADES.indexOf(this.slots[slot].grade);
      const gradeMul = 1 + gradeIdx * 0.25; // common=1x, rare=1.25x, epic=1.5x, legendary=1.75x, unique=2x
      for (const [k, v] of Object.entries(def.effects)) {
        if (k === 'hpFlat' || k === 'luckFlat') b[k] += v * gradeMul * EQUIP_NERF;
        else b[k] += v * gradeMul * EQUIP_NERF;
      }
    }
    return b;
  }

  // Roll a random equipment drop
  static rollDrop(luck) {
    // Pick grade
    const roll = Math.random() * 100;
    let acc = 0; let grade = 'common';
    for (const g of EQUIP_GRADES) {
      acc += EQUIP_GRADE_WEIGHTS[g];
      if (roll < acc) { grade = g; break; }
    }
    // Pick random slot
    const slots = Object.keys(EQUIPMENT_TABLE);
    const slot = slots[Math.floor(Math.random() * slots.length)];
    // Pick random item from that slot
    const items = EQUIPMENT_TABLE[slot];
    const item = items[Math.floor(Math.random() * items.length)];
    return { slot, itemId: item.id, grade, name: item.name, icon: item.icon };
  }

  addToInventory(slot, itemId, grade) {
    this.inventory[slot].push({ itemId, grade });
    this.save();
    EquipmentManager.recordDiscovered(slot, itemId);
  }

  // Count items of a specific grade in a slot's inventory
  countByGrade(slot, grade) {
    return this.inventory[slot].filter(i => i.grade === grade).length;
  }

  // Get craftable grades for a slot (grades that have 3+ items)
  getCraftableGrades(slot) {
    const result = [];
    for (const g of EQUIP_GRADES.slice(0, -1)) { // can't craft unique‚Üínext
      if (this.countByGrade(slot, g) >= 3) result.push(g);
    }
    return result;
  }

  // Craft: consume 3 items of same grade from slot ‚Üí produce next grade random item
  craft(slot, grade) {
    const gradeIdx = EQUIP_GRADES.indexOf(grade);
    if (gradeIdx < 0 || gradeIdx >= EQUIP_GRADES.length - 1) return null;
    if (this.countByGrade(slot, grade) < 3) return null;
    // Remove 3 items of this grade
    let removed = 0;
    this.inventory[slot] = this.inventory[slot].filter(i => {
      if (removed >= 3) return true;
      if (i.grade === grade) { removed++; return false; }
      return true;
    });
    // Create next grade item
    const nextGrade = EQUIP_GRADES[gradeIdx + 1];
    const items = EQUIPMENT_TABLE[slot];
    const newItem = items[Math.floor(Math.random() * items.length)];
    const result = { slot, itemId: newItem.id, grade: nextGrade, name: newItem.name, icon: newItem.icon };
    // Auto-equip if better, otherwise add to inventory
    if (!this.tryEquip(slot, result.itemId, result.grade)) {
      this.inventory[slot].push({ itemId: result.itemId, grade: result.grade });
    }
    this.save();
    return result;
  }

  reset() {
    this.slots = { weapon:null, armor:null, boots:null, helmet:null, ring:null };
    this.inventory = { weapon:[], armor:[], boots:[], helmet:[], ring:[] };
    try { localStorage.removeItem(EquipmentManager.STORAGE_KEY); } catch(e) {}
  }

  // ‚ïê‚ïê‚ïê üì¶ Ïû•ÎπÑ ÎèÑÍ∞ê (Î∞úÍ≤¨ Í∏∞Î°ù) ‚ïê‚ïê‚ïê
  static DISCOVERED_KEY = 'whiteout_discovered';

  static loadDiscovered() {
    try {
      return JSON.parse(localStorage.getItem(EquipmentManager.DISCOVERED_KEY) || '{}');
    } catch(e) { return {}; }
  }

  static saveDiscovered(data) {
    try { localStorage.setItem(EquipmentManager.DISCOVERED_KEY, JSON.stringify(data)); } catch(e) {}
  }

  static recordDiscovered(slot, itemId) {
    const disc = EquipmentManager.loadDiscovered();
    if (!disc[slot]) disc[slot] = [];
    if (!disc[slot].includes(itemId)) {
      disc[slot].push(itemId);
      EquipmentManager.saveDiscovered(disc);
    }
  }
}

// ‚ïê‚ïê‚ïê üìú Îü∞ ÌûàÏä§ÌÜ†Î¶¨ Îß§ÎãàÏ†Ä ‚ïê‚ïê‚ïê
class RunHistoryManager {
  static KEY = 'whiteout_runs';
  static MAX = 10;
  constructor() { this._load(); }
  _load() { try { this.runs = JSON.parse(localStorage.getItem(RunHistoryManager.KEY) || '[]'); } catch(e) { this.runs = []; } }
  save(runData) {
    this.runs.unshift(runData);
    if (this.runs.length > RunHistoryManager.MAX) this.runs.pop();
    try { localStorage.setItem(RunHistoryManager.KEY, JSON.stringify(this.runs)); } catch(e) {}
  }
  getBest() {
    if (this.runs.length === 0) return null;
    return {
      longestSurvival: this.runs.reduce((a, b) => a.survivalTime > b.survivalTime ? a : b),
      mostKills: this.runs.reduce((a, b) => a.kills > b.kills ? a : b),
      highestLevel: this.runs.reduce((a, b) => a.level > b.level ? a : b),
    };
  }
  static formatTime(sec) { return `${Math.floor(sec/60)}Î∂Ñ ${Math.floor(sec%60)}Ï¥à`; }
}

class UpgradeManager {
  constructor() {
    this.levels = {}; // { DAMAGE_UP: 2, ... }
    this.totalKills = 0;
    this.cratesSpawned = 0; // how many crates triggered so far
    this.regenPerSec = 0;
    this.critChance = 0;
    this.dodgeChance = 0;
    this.lifestealAmount = 0;
    this.knockbackBonus = 0;
    this.lootBonus = 0;
    this.sellBonus = 0;
    this.magnetRange = 70; // base magnet range
    this.multiHitCount = 1;
    this.explosionLevel = 0;
    this.campfireBoost = 1;
    this.cooldownReduction = 1;
    this.frostResistance = 0;
    this.berserkerBonus = 0;
    this.chainAttackChance = 0;
    this.treasureHunterBonus = 0;
    this.armorReduction = 0;
    this.vampireHeal = 0;
    this.winterHeartBonus = 0;
    this.scavengerSpeed = 0;
    this.swiftStrikeActive = false;
    this.swiftStrikeUsed = false; // tracks if first attack bonus was used
    this.frostWalkerActive = false;
    this.swiftStrikeApplied = false;
    this.attackCounter = 0;
    // Phase 2
    this.chainLightningLevel = 0; this.iceAuraLevel = 0; this.lifeStealPct = 0;
    this.shieldBashActive = false; this.shieldBashCD = 0; this.shieldBashReady = false;
    this.doubleShotChance = 0; this.thornsDamage = 0;
    this.timeWarpLevel = 0; this.timeWarpCD = 0;
    this.xpScavengerBonus = 0; this.adrenalineLevel = 0; this.blizzardCloakActive = false;
  }

  getLevel(key) { return this.levels[key] || 0; }
  isMaxed(key) { return this.getLevel(key) >= UPGRADES[key].maxLevel; }

  getAvailableUpgrades(playerClass, endgameMode = false) {
    return Object.keys(UPGRADES).filter(k => {
      if (this.isMaxed(k)) return false;
      const u = UPGRADES[k];
      // Endgame-only cards: only in endless mode after 60min
      if (u.endgameOnly && !endgameMode) return false;
      // Class-only cards: only show for matching class
      if (u.classOnly) return u.classOnly === playerClass;
      return true;
    });
  }

  pickThreeCards(extra = 0, playerClass = null, endgameMode = false) {
    // In endgame mode, only offer endgame cards if any are available
    if (endgameMode) {
      const endgameAvailable = this.getAvailableUpgrades(playerClass, true).filter(k => UPGRADES[k].endgameOnly);
      if (endgameAvailable.length > 0) {
        const picked = [];
        const used = new Set();
        const count = Math.min(3 + extra, endgameAvailable.length);
        const shuffled = [...endgameAvailable].sort(() => Math.random() - 0.5);
        for (let i = 0; i < count; i++) { picked.push(shuffled[i]); }
        return picked;
      }
    }
    const available = this.getAvailableUpgrades(playerClass, endgameMode);
    if (available.length === 0) return [];

    // Weighted by rarity
    const weighted = [];
    available.forEach(k => {
      const w = RARITY_WEIGHTS[UPGRADES[k].rarity] || 70;
      for (let i = 0; i < w; i++) weighted.push(k);
    });

    const picked = [];
    const used = new Set();
    const count = Math.min(3 + extra, available.length);
    while (picked.length < count) {
      const k = weighted[Math.floor(Math.random() * weighted.length)];
      if (!used.has(k)) { used.add(k); picked.push(k); }
    }
    return picked;
  }

  // Diminishing returns: 2nd=70%, 3rd=40%, 4th+=20%
  _diminish(lv) {
    if (lv <= 1) return 1.0;
    if (lv === 2) return 0.7;
    if (lv === 3) return 0.4;
    return 0.2;
  }

  applyUpgrade(key, scene) {
    this.levels[key] = (this.levels[key] || 0) + 1;
    const lv = this.levels[key];
    const dim = this._diminish(lv);

    switch (key) {
      case 'DAMAGE_UP': {
        const boost = 1 + 0.25 * dim;
        scene.playerDamage = Math.round(scene.playerDamage * boost * 100) / 100;
        if (scene.playerDamage < 1) scene.playerDamage = 1;
        // Cap: 300% of base (base=10)
        scene.playerDamage = Math.min(scene.playerDamage, 30);
        break;
      }
      case 'ATTACK_SPEED': {
        scene.baseAttackSpeed *= (1 - 0.2 * dim);
        // Cap: 400% speed => min cooldown 0.35/4 = 0.0875
        scene.baseAttackSpeed = Math.max(0.0875, scene.baseAttackSpeed);
        break;
      }
      case 'CRITICAL':
        this.critChance = lv * 0.1;
        break;
      case 'LIFESTEAL':
        this.lifestealAmount = lv;
        break;
      case 'KNOCKBACK':
        this.knockbackBonus = lv * 40;
        break;
      case 'MAX_HP':
        scene.playerMaxHP += 20;
        scene.playerHP += 20;
        break;
      case 'WARMTH':
        scene.warmthResist = Math.min(1.0, scene.warmthResist + 0.2); // Now increases resistance
        break;
      case 'REGEN':
        this.regenPerSec = lv * 0.5;
        break;
      case 'MOVEMENT':
        scene.playerBaseSpeed *= (1 + 0.15 * dim);
        scene.playerSpeed = scene.playerBaseSpeed;
        // Cap: 250% of base (base=120 => max 300)
        scene.playerBaseSpeed = Math.min(300, scene.playerBaseSpeed);
        scene.playerSpeed = Math.min(300, scene.playerSpeed);
        break;
      case 'DODGE':
        this.dodgeChance = lv * 0.1;
        break;
      case 'LOOT_BONUS':
        this.lootBonus = lv * 0.5;
        break;
      case 'WOOD_BONUS':
        scene.woodBonus += 1;
        break;
      case 'STONE_BONUS':
        scene.stoneBonus += 1;
        break;
      case 'STORAGE':
        scene.storageCapacity += 25;
        break;
      case 'SELL_BONUS':
        this.sellBonus = lv * 0.2;
        break;
      case 'MAGNET':
        this.magnetRange = 70 + lv * 50;
        break;
      case 'MULTI_HIT':
        this.multiHitCount = 1 + lv;
        break;
      case 'EXPLOSION':
        this.explosionLevel = lv;
        break;
      case 'CAMPFIRE_BOOST':
        this.campfireBoost = 1 + lv * 0.5;
        break;
      case 'TIME_BONUS':
        this.cooldownReduction = Math.pow(0.8, lv);
        break;
      case 'FROST_RESISTANCE': this.frostResistance = Math.min(0.9, this.frostResistance + 0.3); break;
      case 'BERSERKER': this.berserkerBonus = Math.min(1.0, this.berserkerBonus + 0.5); break;
      case 'CHAIN_ATTACK': this.chainAttackChance = Math.min(1.0, this.chainAttackChance + 0.5); break;
      case 'TREASURE_HUNTER': this.treasureHunterBonus += 0.4; break;
      case 'ARMOR': this.armorReduction = Math.min(0.6, this.armorReduction + 0.2); break;
      case 'VAMPIRE': this.vampireHeal += 5; break;
      case 'WINTER_HEART': this.winterHeartBonus += 0.2; break;
      case 'SCAVENGER': this.scavengerSpeed += 0.3; break;
      case 'SWIFT_STRIKE': this.swiftStrikeActive = true; break;
      case 'FROST_WALKER': this.frostWalkerActive = true; break;
      // === Phase 2 Ïã†Í∑ú 10Ï¢Ö ===
      case 'CHAIN_LIGHTNING': this.chainLightningLevel = lv; break;
      case 'ICE_AURA': this.iceAuraLevel = lv; break;
      case 'LIFE_STEAL_PCT': this.lifeStealPct = lv * 0.10; break;
      case 'SHIELD_BASH': this.shieldBashActive = true; this.shieldBashCD = 0; break;
      case 'DOUBLE_SHOT': this.doubleShotChance = Math.min(0.6, lv * 0.30); break;
      case 'THORNS': this.thornsDamage = lv * 5; break;
      case 'TIME_WARP': this.timeWarpLevel = lv; this.timeWarpCD = 0; break;
      case 'XP_SCAVENGER': this.xpScavengerBonus = lv * 0.50; this.magnetRange = Math.round((70 + this.getLevel('MAGNET') * 50) * (1 + this.xpScavengerBonus)); break;
      case 'ADRENALINE': this.adrenalineLevel = lv; break;
      case 'BLIZZARD_CLOAK': this.blizzardCloakActive = true; break;
      // ‚ïê‚ïê‚ïê Class Upgrades ‚ïê‚ïê‚ïê
      case 'CLASS_WARRIOR_ROAR': this._classWarriorRoar = true; break;
      case 'CLASS_MAGE_BLIZZARD': this._classMageBlizzard = true; break;
      case 'CLASS_SURVIVOR_SPRINT': this._classSurvivorSprint = true; break;
      case 'CLASS_SHAMAN_SPIRIT': this._classShamanSpirit = true; break;
      case 'CLASS_SHAMAN_STORM': this._classShamanStorm = true; break;
      case 'CLASS_HUNTER_VOLLEY': this._classHunterVolley = true; break;
      case 'CLASS_HUNTER_POISON': this._classHunterPoison = true; break;
      // ‚ïê‚ïê‚ïê Endgame Upgrades ‚ïê‚ïê‚ïê
      case 'GODLIKE_POWER':
        scene.playerDamage = Math.round(scene.playerDamage * 1.5);
        scene.playerMaxHP = Math.round(scene.playerMaxHP * 1.5);
        scene.playerHP = Math.min(scene.playerHP + scene.playerMaxHP * 0.5, scene.playerMaxHP);
        scene.playerSpeed *= 1.5;
        scene.baseAttackSpeed *= 0.67; // 50% faster
        break;
      case 'IMMORTAL_WILL':
        scene.playerMaxHP += 200;
        scene.playerHP = Math.min(scene.playerHP + 200, scene.playerMaxHP);
        this.regenPerSec += 5;
        break;
      case 'TIME_WARP_ULTRA':
        scene.baseAttackSpeed *= 0.5; // 100% faster
        this.cooldownReduction *= 0.5;
        break;
      case 'FROZEN_WORLD':
        this._frozenWorldActive = true;
        break;
      case 'SPIRIT_BOMB':
        this._spiritBombActive = true;
        this._spiritBombTimer = 0;
        break;
      // ‚ïê‚ïê‚ïê ÏÉà Ï†Å ÎåÄÏùë + ÏõîÎìú Ïò§Î∏åÏ†ùÌä∏ ÏãúÎÑàÏßÄ 8Ï¢Ö ‚ïê‚ïê‚ïê
      case 'COLD_RESISTANCE':
        this._coldResistSlowReduce = Math.min(1.0, lv * 0.5);   // 50% per level
        this._coldResistBlizzardReduce = Math.min(0.4, lv * 0.2); // 20% per level
        break;
      case 'SPLIT_EXPLOSION':
        this._splitExplosionLevel = lv;  // explosion radius=50, +50% XP per level
        break;
      case 'SHAMAN_HUNTER':
        this._shamanHunterLevel = lv;  // +30% dmg per level vs shaman, +15HP on kill
        break;
      case 'HEARTH_MASTER':
        this._hearthMasterLevel = lv;  // heal mult +50% per lv, radius +40px per lv
        this.campfireBoost = (this.getLevel('CAMPFIRE_BOOST') > 0 ? 1 + this.getLevel('CAMPFIRE_BOOST') * 0.5 : 1) * (1 + lv * 0.5);
        this._campfireRadiusBonus = lv * 40;
        break;
      case 'SUPPLY_EXPERT':
        this._supplyExpertActive = true;  // +50% meat heal, +30 XP on open
        break;
      case 'FLARE_EXPERT':
        this._flareExpertLevel = lv;  // +15s XP2x duration per lv, +20% atkspd 15s on pickup
        break;
      case 'GLACIAL_WALL':
        this._glacialWallLevel = lv;  // wall HP x2 per lv, +15% def within 100px
        break;
      case 'ARCTIC_ADAPT':
        this._arcticAdaptActive = true;  // blizzard speed +5% instead of penalty, post-blizzard +25% atkspd 10s
        break;
    }
  }

  onKill(scene) {
    this.totalKills++;
    // Crate spawning removed - now handled by XP level-up system
  }

  toJSON() {
    return {
      levels: { ...this.levels },
      totalKills: this.totalKills,
      cratesSpawned: this.cratesSpawned,
    };
  }

  fromJSON(data, scene) {
    if (!data) return;
    this.totalKills = data.totalKills || 0;
    this.cratesSpawned = data.cratesSpawned || 0;
    // Re-apply all upgrades from scratch
    if (data.levels) {
      const savedLevels = { ...data.levels };
      this.levels = {};
      this.regenPerSec = 0; this.critChance = 0; this.dodgeChance = 0;
      this.lifestealAmount = 0; this.knockbackBonus = 0; this.lootBonus = 0;
      this.sellBonus = 0; this.magnetRange = 70; this.multiHitCount = 1;
      this.explosionLevel = 0; this.campfireBoost = 1; this.cooldownReduction = 1;
      this.frostResistance = 0; this.berserkerBonus = 0; this.chainAttackChance = 0;
      this.treasureHunterBonus = 0; this.armorReduction = 0; this.vampireHeal = 0;
      this.winterHeartBonus = 0; this.scavengerSpeed = 0;
      this.swiftStrikeActive = false; this.swiftStrikeUsed = false; this.frostWalkerActive = false;
      this.swiftStrikeApplied = false; this.attackCounter = 0;
      // Phase 2 resets
      this.chainLightningLevel = 0; this.iceAuraLevel = 0; this.lifeStealPct = 0;
      this.shieldBashActive = false; this.shieldBashCD = 0; this.shieldBashReady = false;
      this.doubleShotChance = 0; this.thornsDamage = 0;
      this.timeWarpLevel = 0; this.timeWarpCD = 0;
      this.xpScavengerBonus = 0; this.adrenalineLevel = 0; this.blizzardCloakActive = false;
      // Phase 3 resets (new 8)
      this._coldResistSlowReduce = 0; this._coldResistBlizzardReduce = 0;
      this._splitExplosionLevel = 0; this._shamanHunterLevel = 0;
      this._hearthMasterLevel = 0; this._campfireRadiusBonus = 0;
      this._supplyExpertActive = false; this._flareExpertLevel = 0;
      this._glacialWallLevel = 0; this._arcticAdaptActive = false;
      Object.entries(savedLevels).forEach(([key, lv]) => {
        for (let i = 0; i < lv; i++) this.applyUpgrade(key, scene);
      });
    }
  }
}
// ‚ïê‚ïê‚ïê END UPGRADE SYSTEM ‚ïê‚ïê‚ïê

const WORLD_W = 2400;
const WORLD_H = 2400;

// ‚îÄ‚îÄ Animal Definitions (REBALANCED) ‚îÄ‚îÄ
const ANIMALS = {
  rabbit:  { hp: 10,  speed: 100,  damage: 0, drops: { meat: 1 }, size: 16, behavior: 'flee', name: 'üê∞ ÌÜ†ÎÅº', aggroRange: 80, fleeRange: 60, fleeDistance: 80, color: 0xFFEEDD },
  deer:    { hp: 15,  speed: 80,  damage: 0, drops: { meat: 2, leather: 1 }, size: 18, behavior: 'flee', name: 'ü¶å ÏÇ¨Ïä¥', aggroRange: 120, fleeRange: 90, fleeDistance: 100, color: 0xC4A46C },
  penguin: { hp: 8,  speed: 40,  damage: 0, drops: { meat: 1 }, size: 16, behavior: 'wander', name: 'üêß Ìé≠Í∑Ñ', aggroRange: 0, fleeRange: 0, fleeDistance: 0, color: 0x222222 },
  seal:    { hp: 12,  speed: 30,  damage: 0, drops: { meat: 2, leather: 2 }, size: 20, behavior: 'wander', name: 'ü¶≠ Î¨ºÍ∞ú', aggroRange: 0, fleeRange: 0, fleeDistance: 0, color: 0x7B8D9E },
  wolf:    { hp: 30,  speed: 110,  damage: 5, drops: { meat: 3, leather: 1 }, size: 18, behavior: 'chase', name: 'üê∫ ÎäëÎåÄ', aggroRange: 160, fleeRange: 0, fleeDistance: 0, color: 0x666677 },
  bear:    { hp: 80, speed: 70,  damage: 15, drops: { meat: 6, leather: 3 }, size: 26, behavior: 'chase', name: 'üêª Í≥∞', aggroRange: 140, fleeRange: 0, fleeDistance: 0, color: 0xF0EEE8 },
  ice_golem: { hp: 240, speed: 60, damage: 50, drops: { meat: 10, leather: 5, gold: 15 }, size: 24, behavior: 'chase', name: 'üßä ÏñºÏùåÍ≥®Î†ò', aggroRange: 200, fleeRange: 0, fleeDistance: 0, color: 0x88CCEE },
  snow_leopard: { hp: 45, speed: 220, damage: 20, drops: { meat: 4, leather: 2, gold: 5 }, size: 14, behavior: 'chase', name: 'üêÜ ÎààÌëúÎ≤î', aggroRange: 250, fleeRange: 0, fleeDistance: 0, color: 0xF8F8FF },
  ice_hunter: { hp: 45, speed: 80, damage: 3, drops: { meat: 3, leather: 2, gold: 3 }, size: 20, behavior: 'ranged', name: 'üèπ ÏñºÏùåÏÇ¨ÎÉ•Íæº', aggroRange: 280, fleeRange: 0, fleeDistance: 0, color: 0x4488CC },
  splitting_slime: { hp: 64, speed: 45, damage: 8, drops: { meat: 4, gold: 5 }, size: 24, behavior: 'chase', name: 'üí• Î∂ÑÏó¥Ïä¨ÎùºÏûÑ', aggroRange: 160, fleeRange: 0, fleeDistance: 0, color: 0x44CC44 },
  blizzard_shaman: { hp: 25, speed: 70, damage: 2, drops: { meat: 2, gold: 8 }, size: 18, behavior: 'shaman', name: 'üîÆ ÎààÎ≥¥ÎùºÏÉ§Î®º', aggroRange: 200, fleeRange: 100, fleeDistance: 120, color: 0xAA55FF },
};

// ‚îÄ‚îÄ Building Definitions (ENHANCED) ‚îÄ‚îÄ
const BUILDINGS = {
  campfire: {
    name: 'ÌôîÎçï', cost: { wood: 5 }, warmth: 8, desc: 'Í∞ïÎ†•Ìïú ÏÉùÏ°¥ Í∏∞ÏßÄ', icon: 'üî•',
    warmthRadius: 150,
    effects: { healthRegen: 8, goldGeneration: 3, attackSpeedBonus: 1.5, moveSpeedBonus: 1.3, animalRepelRadius: 120 }
  },
  tent:     { name: 'ÌÖêÌä∏', cost: { wood: 10, leather: 3 }, warmth: 5, desc: 'ÏàòÎ©¥ ÌöåÎ≥µ + HPÌöåÎ≥µ', icon: '‚õ∫',
    effects: { healthRegen: 3, hungerSlowdown: 0.5 }
  },
  storage:  { name: 'Ï∞ΩÍ≥†', cost: { wood: 15, stone: 10 }, storageBonus: 50, desc: 'Î≥¥Í¥ÄÎüâ +50, ÏûêÎèôÏ†ïÎ¶¨', icon: 'üì¶',
    effects: { autoSort: true }
  },
  workshop: { name: 'ÏûëÏóÖÎåÄ', cost: { wood: 20, stone: 15 }, desc: 'ÎèÑÍµ¨ Ï†úÏûë Í∞ÄÎä•', icon: 'üî®' },
  wall:     { name: 'Î∞©Î≤Ω', cost: { stone: 8 }, desc: 'ÎèôÎ¨º ÏßÑÏûÖ Ï∞®Îã®', icon: 'üß±' },
};

// ‚îÄ‚îÄ Crafting Recipes ‚îÄ‚îÄ
const RECIPES = {
  stone_axe:  { name: 'ÎèåÎèÑÎÅº', cost: { wood: 3, stone: 2 }, effect: 'woodBonus', value: 1, desc: 'ÎÇòÎ¨¥ Ï±ÑÏßë +1', icon: 'ü™ì' },
  stone_pick: { name: 'Í≥°Í¥≠Ïù¥', cost: { wood: 3, stone: 3 }, effect: 'stoneBonus', value: 1, desc: 'Îèå Ï±ÑÏßë +1', icon: '‚õèÔ∏è' },
  spear:      { name: 'Ï∞Ω', cost: { wood: 5, stone: 3 }, effect: 'damage', value: 1, desc: 'Í≥µÍ≤©Î†• +1', icon: 'üî±' },
  fur_coat:   { name: 'Î™®Ìîº ÏΩîÌä∏', cost: { leather: 8 }, effect: 'warmthResist', value: 0.3, desc: 'Ï≤¥Ïò® Í∞êÏÜå -30%', icon: 'üß•' },
  boots:      { name: 'Í∞ÄÏ£Ω Ïû•Ìôî', cost: { leather: 5 }, effect: 'speed', value: 30, desc: 'Ïù¥ÎèôÏÜçÎèÑ +30', icon: 'üë¢' },
};

// ‚îÄ‚îÄ Act Story Text ‚îÄ‚îÄ
const ACT_STORY = {
  start: "‚ùÑÔ∏è ÏòÅÌïò 60ÎèÑÏùò ÏÑ§Ïõê. ÏÇ¥ÏïÑÎÇ®ÏïÑÏïº ÌïúÎã§.",
  act2:  "üê∫ ÏßêÏäπÎì§Ïù¥ ÏõÄÏßÅÏù¥Í∏∞ ÏãúÏûëÌñàÎã§. Îçî Í∞ïÌï¥Ï†∏Ïïº ÌïúÎã§.",
  act3:  "üíÄ Í¥¥Î¨ºÏù¥ ÎÇòÌÉÄÎÇ¨Îã§. ÎèÑÎßùÏπ† Í≥≥ÏùÄ ÏóÜÎã§.",
  act4:  "üå®Ô∏è ÎààÎ≥¥ÎùºÍ∞Ä Í±∞ÏÑ∏ÏßÑÎã§. Ìù¨ÎßùÏùÄ ÏïÑÏßÅ ÏûàÎã§.",
  act5:  "üëÅÔ∏è ÏµúÍ∞ïÏùò Ï°¥Ïû¨Í∞Ä ÎààÏùÑ Îú¨Îã§. ÎßàÏßÄÎßâ Í≤∞Ï†Ñ.",
  win:   "üèîÔ∏è ÏÇ¥ÏïÑÎÇ®ÏïòÎã§. Ï†ÑÏÑ§Ïù¥ ÎêòÏóàÎã§."
};

// ‚îÄ‚îÄ Region Names ‚îÄ‚îÄ
const REGION_NAMES = {
  safe:    { name: 'üèïÔ∏è ÏÉùÏ°¥ Ï∫†ÌîÑ', color: '#44FF44' },
  normal:  { name: 'üå≤ Ïπ®ÏóΩÏàòÎ¶º', color: '#FFDD44' },
  danger:  { name: 'üèîÔ∏è ÎπôÌïò ÏßÄÎåÄ', color: '#FF8844' },
  extreme: { name: 'üíÄ Ï£ΩÏùåÏùò ÏÑ§Ïõê', color: '#FF4444' }
};

// ‚îÄ‚îÄ NPC Speech Bubbles ‚îÄ‚îÄ
const NPC_BUBBLES = {
  merchant:  'üí¨ Ïò§Îäò Ïö¥Ïù¥ Ï¢ãÎÑ§Ïöî! Ï¢ãÏùÄ Î¨ºÍ±¥ ÏûàÏñ¥Ïöî.',
  hunter:    'üí¨ ÏÇ¨ÎÉ•Í∞êÏù¥ ÎßéÍµ∞... Í∞ôÏù¥ Í∞ÄÏûê!',
  gatherer:  'üí¨ Ïû¨Î£åÎßå ÏûàÏúºÎ©¥ Î≠êÎì† ÎßåÎì§Ïñ¥ ÎìúÎ†§Ïöî.',
  warrior:   'üí¨ ÌïúÌååÍ∞Ä 3Î∂ÑÎßàÎã§ Ïò®Îã§ÎÑ§... Ï°∞Ïã¨ÌïòÍ≤å.'
};

// ‚îÄ‚îÄ NPC Definitions ‚îÄ‚îÄ
const NPC_DEFS = [
  { type: 'hunter',    name: 'ÏÇ¨ÎÉ•Íæº', cost: { meat: 12 },  desc: 'ÏûêÎèô ÏÇ¨ÎÉ•' },
  { type: 'gatherer',  name: 'Ï±ÑÏßëÍæº', cost: { meat: 8 },  desc: 'ÏûêÎèô Ï±ÑÏßë' },
  { type: 'merchant',  name: 'ÏÉÅÏù∏',   cost: { meat: 30 }, desc: 'Í≥†Í∏∞‚ÜíÍ∏àÌôî' },
  { type: 'warrior',   name: 'Ï†ÑÏÇ¨',   cost: { meat: 50 }, desc: 'Í∞ïÎ†• Ï†ÑÌà¨' },
];

// ‚îÄ‚îÄ Resource node types ‚îÄ‚îÄ
const RESOURCE_NODES = {
  tree:  { name: 'ÎÇòÎ¨¥', resource: 'wood',  hp: 3, yield: 2, size: 16, regen: 30 },
  rock:  { name: 'Î∞îÏúÑ', resource: 'stone', hp: 4, yield: 2, size: 14, regen: 45 },
};

// ‚îÄ‚îÄ Quests (20+ redesigned with conditions) ‚îÄ‚îÄ
const QUESTS = [
  // Act 1: Ï¥àÎ∞ò ÏÉùÏ°¥ (0-5Î∂Ñ)
  { id: 'q1', name: 'Ï≤´ ÏÇ¨ÎÉ•', desc: 'ÌÜ†ÎÅº 5ÎßàÎ¶¨ Ï≤òÏπò', check: s => (s.kills.rabbit||0) >= 5, reward: { meat: 5 } },
  { id: 'q2', name: 'Í≥†Í∏∞ ÎÇ©Ìíà', desc: 'Í≥†Í∏∞ 5Í∞ú Î™®ÏúºÍ∏∞', check: s => (s.meatCollected||0) >= 5, reward: { gold: 30 }, rewardEffect: { tempBonus: 5 } },
  { id: 'q3', name: 'ÎÇòÎ¨¥Íæº', desc: 'ÎÇòÎ¨¥ 10Í∞ú Ï±ÑÏßë', check: s => s.woodGathered >= 10, reward: { stone: 5, meat: 3 } },
  { id: 'q4', name: 'ÌôîÎçï Í±¥ÏÑ§', desc: 'ÌôîÎçï 1Í∞ú Í±¥ÏÑ§', check: s => (s.built.campfire||0) >= 1, reward: { leather: 3 } },
  { id: 'q5', name: 'Ï≤¥Ïò® Ïú†ÏßÄ', desc: 'ÌôîÎçï Í±¥ÏÑ§ ÌõÑ 30Ï¥à Ï≤¥Ïò® Ïú†ÏßÄ', check: (s, scene) => (s.built.campfire||0) >= 1 && scene && scene._warmthNearFireTime >= 30, reward: { gold: 50, meat: 5 } },

  // Act 2: Ï§ëÎ∞ò ÏÑ±Ïû• (5-10Î∂Ñ)
  { id: 'q6', name: 'ÎèÑÍµ¨ Ï†úÏûë', desc: 'ÎèÑÍµ¨ 1Í∞ú Ï†úÏûë', check: s => s.crafted >= 1, reward: { meat: 8 } },
  { id: 'q7', name: 'Ìé≠Í∑Ñ ÏÇ¨ÎÉ•Íæº', desc: 'Ìé≠Í∑Ñ 8ÎßàÎ¶¨ Ï≤òÏπò', check: s => (s.kills.penguin||0) >= 8, reward: { leather: 3, gold: 20 } },
  { id: 'q8', name: 'ÏÇ¨Ïä¥ ÏÇ¨ÎÉ•Íæº', desc: 'ÏÇ¨Ïä¥ 10ÎßàÎ¶¨ Ï≤òÏπò', check: s => (s.kills.deer||0) >= 10, reward: { leather: 5, meat: 8 } },
  { id: 'q9', name: 'ÎåÄÎüâ ÎÇ©Ìíà', desc: 'Í≥†Í∏∞ 15Í∞ú Î™®ÏúºÍ∏∞', check: s => (s.meatCollected||0) >= 15, reward: { gold: 80 }, rewardEffect: { maxHPBonus: 15 } },
  { id: 'q10', name: '5Î∂Ñ ÏÉùÏ°¥', desc: '5Î∂ÑÍ∞Ñ ÏÉùÏ°¥ÌïòÍ∏∞', check: (s, scene) => scene && scene.gameElapsed >= 300, reward: { meat: 10, wood: 10 } },

  // Act 3: ÎäëÎåÄ ÏãúÎåÄ (10-15Î∂Ñ)
  { id: 'q11', name: 'ÎäëÎåÄ ÏÇ¨ÎÉ•', desc: 'ÎäëÎåÄ 3ÎßàÎ¶¨ Ï≤òÏπò', check: s => (s.kills.wolf||0) >= 3, reward: { leather: 5, gold: 40 } },
  { id: 'q12', name: 'NPC Í≥†Ïö©', desc: 'NPC 1Î™Ö Í≥†Ïö©', check: s => s.npcsHired >= 1, reward: { wood: 10, stone: 10 } },
  { id: 'q13', name: 'ÌÖêÌä∏ Í±¥ÏÑ§', desc: 'ÌÖêÌä∏ Í±¥ÏÑ§ÌïòÍ∏∞', check: s => (s.built.tent||0) >= 1, reward: { meat: 12, gold: 30 } },
  { id: 'q14', name: '10Î∂Ñ ÏÉùÏ°¥', desc: '10Î∂ÑÍ∞Ñ ÏÉùÏ°¥ÌïòÍ∏∞', check: (s, scene) => scene && scene.gameElapsed >= 600, reward: { gold: 100, leather: 5 }, rewardEffect: { maxHPBonus: 20 } },
  { id: 'q15', name: 'Ïó∞ÏÜç Ï≤òÏπò', desc: '10ÌÇ¨ ÏΩ§Î≥¥ Îã¨ÏÑ±', check: s => (s.maxCombo||0) >= 10, reward: { gold: 60, meat: 8 } },

  // Act 4: Í≥∞ ÏãúÎåÄ (15-20Î∂Ñ)
  { id: 'q16', name: 'Í≥∞ ÏÇ¨ÎÉ•', desc: 'Í≥∞ 3ÎßàÎ¶¨ Ï≤òÏπò ÌõÑ Í≥†Í∏∞ 8Í∞ú ÎÇ©Ìíà', check: s => (s.kills.bear||0) >= 3 && (s.meatCollected||0) >= 25, reward: { leather: 10, gold: 100 } },
  { id: 'q17', name: 'Î¨¥Í∏∞ Ïû•Ïù∏', desc: 'Ïû•ÎπÑ Ìï©ÏÑ± 2Ìöå', check: s => s.crafted >= 2, reward: { gold: 80, meat: 10 } },
  { id: 'q18', name: '15Î∂Ñ ÏÉùÏ°¥', desc: '15Î∂ÑÍ∞Ñ ÏÉùÏ°¥ÌïòÍ∏∞', check: (s, scene) => scene && scene.gameElapsed >= 900, reward: { gold: 150, leather: 8 }, rewardEffect: { maxHPBonus: 30 } },
  { id: 'q19', name: 'ÎäëÎåÄ ÌïôÏÇ¥', desc: 'ÎäëÎåÄ 10ÎßàÎ¶¨ Ï≤òÏπò', check: s => (s.kills.wolf||0) >= 10, reward: { leather: 8, gold: 60 } },

  // Act 5: Î≥¥Ïä§ Î†àÏù¥Îìú (20Î∂Ñ+)
  { id: 'q20', name: '20Î∂Ñ ÏÉùÏ°¥', desc: '20Î∂ÑÍ∞Ñ ÏÉùÏ°¥ÌïòÍ∏∞', check: (s, scene) => scene && scene.gameElapsed >= 1200, reward: { gold: 200, meat: 20 }, rewardEffect: { maxHPBonus: 40 } },
  { id: 'q21', name: 'Í≥∞ ÌïôÏÇ¥', desc: 'Í≥∞ 10ÎßàÎ¶¨ Ï≤òÏπò', check: s => (s.kills.bear||0) >= 10, reward: { leather: 15, gold: 120 } },
  { id: 'q22', name: 'Î≥¥Ïä§ Ï≤òÏπò', desc: 'Î≥¥Ïä§ 1ÎßàÎ¶¨ Ï≤òÏπò', check: s => (s.bossKills||0) >= 1, reward: { gold: 300, leather: 20 }, rewardEffect: { maxHPBonus: 50 } },
  { id: 'q23', name: 'ÎåÄÎüâ ÌïôÏÇ¥', desc: 'Ï¥ù 100ÎßàÎ¶¨ Ï≤òÏπò', check: s => { let t=0; for(const k in s.kills) t+=s.kills[k]; return t>=100; }, reward: { gold: 200, meat: 15 } },
  { id: 'q24', name: '30Î∂Ñ ÏÉùÏ°¥', desc: '30Î∂ÑÍ∞Ñ ÏÉùÏ°¥ÌïòÍ∏∞', check: (s, scene) => scene && scene.gameElapsed >= 1800, reward: { gold: 500 }, rewardEffect: { maxHPBonus: 60 } },
];

// ‚ïê‚ïê‚ïê üé¨ TITLE SCENE ‚ïê‚ïê‚ïê
class TitleScene extends Phaser.Scene {
  constructor() { super('Title'); }

  create() {
    const W = this.scale.width;
    const H = this.scale.height;
    
    // ‚ïê‚ïê‚ïê ÏÑ§ÏÇ∞ Î∞∞Í≤Ω: Í∑∏ÎùºÎç∞Ïù¥ÏÖò ÌïòÎäò ‚ïê‚ïê‚ïê
    this.cameras.main.setBackgroundColor('#0A0E1A');
    this.skyGfx = this.add.graphics().setDepth(0);
    const skySteps = 40;
    for (let i = 0; i < skySteps; i++) {
      const t = i / skySteps;
      const r = Math.floor(8 + t * 140);
      const g = Math.floor(12 + t * 160);
      const b = Math.floor(50 + t * 170);
      const color = (r << 16) | (g << 8) | b;
      this.skyGfx.fillStyle(color, 1);
      this.skyGfx.fillRect(0, (H * 0.7) * (i / skySteps), W, (H * 0.7) / skySteps + 1);
    }
    
    // ‚ïê‚ïê‚ïê ÏÑ§ÏÇ∞ Î¥âÏö∞Î¶¨ Ïã§Î£®Ïó£ ‚ïê‚ïê‚ïê
    this.mountainGfx = this.add.graphics().setDepth(1);
    // Îí∑ÏÇ∞ (Îçî Ïñ¥Îë°Í≥† Ïû•ÏóÑÌïòÍ≤å)
    this.mountainGfx.fillStyle(0x8090b0, 0.5);
    this.mountainGfx.beginPath();
    this.mountainGfx.moveTo(0, H * 0.7);
    const peaks1 = [0, 0.1, 0.2, 0.35, 0.45, 0.55, 0.7, 0.8, 0.9, 1.0];
    const heights1 = [0.55, 0.35, 0.42, 0.25, 0.38, 0.3, 0.22, 0.4, 0.35, 0.5];
    peaks1.forEach((px, i) => this.mountainGfx.lineTo(px * W, H * heights1[i]));
    this.mountainGfx.lineTo(W, H * 0.7);
    this.mountainGfx.closePath();
    this.mountainGfx.fillPath();
    // ÏïûÏÇ∞ (ÏïΩÍ∞Ñ Ïñ¥Îë°Í≤å)
    this.mountainGfx.fillStyle(0xc0cce0, 0.7);
    this.mountainGfx.beginPath();
    this.mountainGfx.moveTo(0, H * 0.7);
    const peaks2 = [0, 0.15, 0.3, 0.45, 0.6, 0.75, 0.9, 1.0];
    const heights2 = [0.6, 0.4, 0.5, 0.32, 0.45, 0.38, 0.48, 0.6];
    peaks2.forEach((px, i) => this.mountainGfx.lineTo(px * W, H * heights2[i]));
    this.mountainGfx.lineTo(W, H * 0.7);
    this.mountainGfx.closePath();
    this.mountainGfx.fillPath();
    // Îàà ÎçÆÏù∏ Î∞îÎã•
    this.mountainGfx.fillStyle(0xd8e4f0, 0.8);
    this.mountainGfx.fillRect(0, H * 0.7, W, H * 0.3);
    
    // ‚ïê‚ïê‚ïê ÏûêÏó∞ ÎèôÎ¨º Ïä§ÌÅ¨Î°§ ‚ïê‚ïê‚ïê
    this.scrollAnimals = [];
    this._animalSpawnTimer = 0;
    // Generate simple animal textures for title screen
    this._createTitleAnimalTextures();
    // Spawn initial animals
    for (let i = 0; i < 3; i++) this._spawnTitleAnimal(true);
    
    // ‚ïê‚ïê‚ïê Snow particles (Í∞ïÌôî v2 - more natural) ‚ïê‚ïê‚ïê
    this.snowParticles = [];
    for (let i = 0; i < 200; i++) {
      this.snowParticles.push({
        x: Math.random() * W,
        y: Math.random() * H,
        size: 0.5 + Math.random() * 4,
        speedX: -0.2 - Math.random() * 0.8,
        speedY: 0.3 + Math.random() * 2.5,
        alpha: 0.15 + Math.random() * 0.65,
        wobble: Math.random() * Math.PI * 2,
        wobbleSpeed: 0.5 + Math.random() * 1.5,
        wobbleAmp: 0.3 + Math.random() * 0.8
      });
    }
    
    this.snowGfx = this.add.graphics().setDepth(10);
    
    // ‚ïê‚ïê‚ïê Game Tips (rotating) ‚ïê‚ïê‚ïê
    this._tipIndex = 0;
    this._tipText = this.add.text(W / 2, H * 0.94, GAME_TIPS[0], {
      fontSize: isMobileLayout() ? '10px' : '12px', fontFamily: 'monospace', color: '#667788',
      wordWrap: { width: W * 0.85 }, align: 'center'
    }).setOrigin(0.5).setDepth(20).setAlpha(0.8);
    this._tipTimer = this.time.addEvent({
      delay: 5000, loop: true,
      callback: () => {
        this._tipIndex = (this._tipIndex + 1) % GAME_TIPS.length;
        this.tweens.add({ targets: this._tipText, alpha: 0, duration: 300, onComplete: () => {
          if (this._tipText && this._tipText.active) {
            this._tipText.setText(GAME_TIPS[this._tipIndex]);
            this.tweens.add({ targets: this._tipText, alpha: 0.8, duration: 300 });
          }
        }});
      }
    });
    
    // Title text with glow pulse
    const titleLogo = this.add.text(W / 2, H * 0.25, '‚ùÑÔ∏è ÌôîÏù¥Ìä∏ÏïÑÏõÉ ÏÑúÎ∞îÏù¥Î≤å', {
      fontSize: Math.min(42, W * 0.06) + 'px',
      fontFamily: 'monospace',
      color: '#e0e8ff',
      stroke: '#000',
      strokeThickness: 4,
      shadow: { offsetX: 2, offsetY: 2, color: '#0a0a2a', blur: 8, fill: true }
    }).setOrigin(0.5);
    // Glow pulse animation (shadowBlur 8‚Üí18‚Üí8)
    this.tweens.add({ targets: { v: 8 }, v: 18, duration: 2000, yoyo: true, repeat: -1, ease: 'Sine.InOut',
      onUpdate: (_, t) => { titleLogo.setShadow(2, 2, '#4466aa', t.v, true, true); }
    });
    
    this.add.text(W / 2, H * 0.33, 'Í∑πÌïúÏùò Ï∂îÏúÑÏóêÏÑú ÏÇ¥ÏïÑÎÇ®ÏïÑÎùº', {
      fontSize: Math.min(18, W * 0.03) + 'px',
      fontFamily: 'monospace',
      color: '#8899bb',
    }).setOrigin(0.5);

    // Version text (Easter egg: 5 rapid clicks)
    const versionText = this.add.text(W - 10, H - 10, 'v2.1', {
      fontSize: '11px', fontFamily: 'monospace', color: '#445566', alpha: 0.6
    }).setOrigin(1, 1).setDepth(20).setInteractive();
    let _vClickCount = 0, _vClickTimer = 0;
    versionText.on('pointerdown', () => {
      const now = Date.now();
      if (now - _vClickTimer > 2000) _vClickCount = 0;
      _vClickTimer = now;
      _vClickCount++;
      if (_vClickCount >= 5) {
        _vClickCount = 0;
        // Unlock all skins + 100 meta points
        const meta = MetaManager.load();
        meta.totalPoints += 100;
        MetaManager.save(meta);
        PLAYER_SKINS.forEach(s => {
          try {
            const data = JSON.parse(localStorage.getItem(SkinManager.KEY) || '{}');
            data[s.id] = true;
            localStorage.setItem(SkinManager.KEY, JSON.stringify(data));
          } catch(e) {}
        });
        // Save konami-like achievement
        try {
          const ach = JSON.parse(localStorage.getItem('achievements_whiteout') || '{}');
          ach['secret_konami'] = true;
          localStorage.setItem('achievements_whiteout', JSON.stringify(ach));
        } catch(e) {}
        const popup = this.add.text(W / 2, H / 2, 'üõ†Ô∏è Í∞úÎ∞úÏûê Î™®Îìú', {
          fontSize: '20px', fontFamily: 'monospace', color: '#FFD700', stroke: '#000', strokeThickness: 4
        }).setOrigin(0.5).setDepth(999);
        this.time.delayedCall(2000, () => popup.destroy());
      }
    });
    
    // Menu buttons
    const btnY = H * 0.52;
    const btnW = Math.min(260, W * 0.5);
    const btnH = 50;
    const hasSave = SaveManager.exists();
    
    // "Ïù¥Ïñ¥ÌïòÍ∏∞" button
    if (hasSave) {
      this._createButton(W / 2, btnY, btnW, btnH, '‚ñ∂ Ïù¥Ïñ¥ÌïòÍ∏∞', 0x2255aa, () => {
        // Double-check save exists at click time (may have been cleared)
        if (!SaveManager.exists()) {
          this.scene.start('Boot', { loadSave: false });
          return;
        }
        this.scene.start('Boot', { loadSave: true });
      });
      
      // Show save info
      const saveData = SaveManager.load();
      if (saveData) {
        const date = new Date(saveData.timestamp);
        const timeStr = date.toLocaleDateString('ko-KR') + ' ' + date.toLocaleTimeString('ko-KR', { hour: '2-digit', minute: '2-digit' });
        this.add.text(W / 2, btnY + btnH / 2 + 16, 'üíæ ' + timeStr, {
          fontSize: '12px', fontFamily: 'monospace', color: '#6688aa'
        }).setOrigin(0.5);
      }
    }
    
    // "ÏÉàÎ°úÌïòÍ∏∞" button
    const newBtnY = hasSave ? btnY + btnH + 40 : btnY;
    this._createButton(W / 2, newBtnY, btnW, btnH, 'üÜï ÏÉàÎ°úÌïòÍ∏∞', hasSave ? 0x444466 : 0x2255aa, () => {
      if (hasSave) {
        this._showConfirmDialogThenClass();
      } else {
        this._showClassSelection();
      }
    });
    
    // ‚ïê‚ïê‚ïê 2Ïó¥ Í∑∏Î¶¨Îìú Î≤ÑÌäº Î∞∞Ïπò ‚ïê‚ïê‚ïê
    const meta = MetaManager.load();
    const hasPoints = MetaManager.getAvailablePoints() > 0;
    const skinCount = SkinManager.getUnlockedCount();
    const gridBtnW = Math.min(120, (W - 40) / 2 - 5);
    const gridBtnH = 42;
    const gridGap = 10;
    const gridStartY = newBtnY + btnH + 24;
    const gridLeft = W / 2 - gridBtnW - gridGap / 2;
    const gridRight = W / 2 + gridGap / 2;

    // Row 1: ÏòÅÍµ¨ Í∞ïÌôî, üìñ ÎèÑÍ∞ê
    this._createButton(gridLeft + gridBtnW / 2, gridStartY, gridBtnW, gridBtnH, `üîÆ ÏòÅÍµ¨ Í∞ïÌôî${hasPoints ? ' ‚ú®' : ''}`, hasPoints ? 0xaa44aa : 0x444466, () => {
      this._showMetaUpgradeUI();
    });
    this._createButton(gridRight + gridBtnW / 2, gridStartY, gridBtnW, gridBtnH, 'üìñ ÎèÑÍ∞ê', 0x3A4455, () => {
      this._showCollectionScreen();
    });

    // Row 2: üìä ÌÜµÍ≥Ñ, üé® Ïä§ÌÇ®
    const gridRow2Y = gridStartY + gridBtnH + gridGap;
    this._createButton(gridLeft + gridBtnW / 2, gridRow2Y, gridBtnW, gridBtnH, 'üìä ÌÜµÍ≥Ñ', 0x334455, () => {
      this._showStatsPopup();
    });
    this._createButton(gridRight + gridBtnW / 2, gridRow2Y, gridBtnW, gridBtnH, `üé® Ïä§ÌÇ® (${skinCount})`, 0x445544, () => {
      this._showSkinPopup();
    });
    
    // Show best time if exists
    const afterGridY = gridRow2Y + gridBtnH / 2 + 16;
    if (meta.bestTime > 0) {
      const bestMin = Math.floor(meta.bestTime / 60);
      const bestSec = Math.floor(meta.bestTime % 60);
      this.add.text(W / 2, afterGridY, `üèÜ ÏµúÍ≥† Í∏∞Î°ù: ${bestMin}Î∂Ñ ${bestSec}Ï¥à | Ï¥ù ${meta.totalRuns}Ìöå`, {
        fontSize: '12px', fontFamily: 'monospace', color: '#aa88cc'
      }).setOrigin(0.5);
    }

    // ‚ïê‚ïê‚ïê üèÖ ÎÇ¥ Í∏∞Î°ù (ÌÉÄÏù¥ÌãÄ ÌïòÎã®) ‚ïê‚ïê‚ïê
    const rec = RecordManager.load();
    const recordY = (meta.bestTime > 0 ? afterGridY + 20 : gridRow2Y + gridBtnH / 2 + 20);
    const recordBoxH = 76;
    const recordGfx = this.add.graphics().setDepth(10);
    recordGfx.fillStyle(0x0A0E1A, 0.7);
    recordGfx.fillRoundedRect(W/2 - btnW/2 - 10, recordY - 8, btnW + 20, recordBoxH, 8);

    if (rec.totalPlays > 0) {
      const bestTimeStr = RecordManager.formatTime(rec.bestSurvivalTime);
      let achCount = 0;
      try { achCount = Object.keys(JSON.parse(localStorage.getItem('achievements_whiteout') || '{}')).length; } catch(e) {}
      this.add.text(W / 2, recordY + 4, 'üèÖ ÎÇ¥ Í∏∞Î°ù', {
        fontSize: '13px', fontFamily: 'monospace', color: '#FFD700'
      }).setOrigin(0.5, 0).setDepth(11);
      if (rec.bestScore) {
        const bgi = ScoreSystem.getGrade(rec.bestScore);
        this.add.text(W / 2, recordY + 22, `üèÜ ÏµúÍ≥†Ï†êÏàò: [${bgi.grade}] ${ScoreSystem.formatScore(rec.bestScore)}Ï†ê`, {
          fontSize: '12px', fontFamily: 'monospace', color: bgi.color
        }).setOrigin(0.5, 0).setDepth(11);
      }
      this.add.text(W / 2, recordY + (rec.bestScore ? 38 : 22), `ÏµúÏû• ${bestTimeStr} | ÏµúÎã§ ${rec.bestKills}ÌÇ¨ | ÌÅ¥Î¶¨Ïñ¥ ${rec.wins}Ìöå | ${rec.totalPlays}Ìåê`, {
        fontSize: '11px', fontFamily: 'monospace', color: '#8899bb'
      }).setOrigin(0.5, 0).setDepth(11);
      this.add.text(W / 2, recordY + 38, `üèÜ ÏÑ±Ï∑®: ${achCount} / ${ACHIEVEMENTS.length}`, {
        fontSize: '11px', fontFamily: 'monospace', color: '#AABB88'
      }).setOrigin(0.5, 0).setDepth(11);
      if (rec.bestSpeedrunTime > 0) {
        const srMin = Math.floor(rec.bestSpeedrunTime / 60);
        const srSec = Math.floor(rec.bestSpeedrunTime % 60);
        this.add.text(W / 2, recordY + 54, `‚ö° Ïä§ÌîºÎìúÎü∞ ÏµúÍ≥†: ${srMin}Î∂Ñ ${srSec}Ï¥à ÎÇ®Ïùå`, {
          fontSize: '11px', fontFamily: 'monospace', color: '#FFCC44'
        }).setOrigin(0.5, 0).setDepth(11);
      }
    } else {
      this.add.text(W / 2, recordY + 18, 'üèÖ ÏïÑÏßÅ Í∏∞Î°ù ÏóÜÏùå', {
        fontSize: '13px', fontFamily: 'monospace', color: '#556677'
      }).setOrigin(0.5, 0.5).setDepth(11);
    }

    // ‚ïê‚ïê‚ïê üìä ÏµúÍ∑º Ï†êÏàò Í∏∞Î°ù (ÏµúÍ∑º 5Ìåê) ‚ïê‚ïê‚ïê
    const scoreHistory = ScoreSystem.loadScores();
    let scoreHistoryEndY = recordY + recordBoxH;
    if (scoreHistory.length > 0) {
      const shY = recordY + recordBoxH + 12;
      const shH = 18 + scoreHistory.length * 18 + 8;
      const shGfx = this.add.graphics().setDepth(10);
      shGfx.fillStyle(0x0A0E1A, 0.7);
      shGfx.fillRoundedRect(W/2 - btnW/2 - 10, shY - 4, btnW + 20, shH, 8);
      this.add.text(W/2, shY + 4, 'üìä ÏµúÍ∑º Ï†êÏàò', {
        fontSize: '12px', fontFamily: 'monospace', color: '#FFD700'
      }).setOrigin(0.5, 0).setDepth(11);
      const bestInHistory = Math.max(...scoreHistory.map(s => s.score));
      scoreHistory.forEach((s, i) => {
        const gi = ScoreSystem.getGrade(s.score);
        const isBest = s.score === bestInHistory;
        const color = isBest ? '#FFD700' : '#8899bb';
        const prefix = isBest ? '‚òÖ ' : '  ';
        this.add.text(W/2, shY + 20 + i * 18,
          prefix + s.date + '  [' + gi.grade + '] ' + ScoreSystem.formatScore(s.score) + 'Ï†ê', {
          fontSize: '10px', fontFamily: 'monospace', color: color
        }).setOrigin(0.5, 0).setDepth(11);
      });
      scoreHistoryEndY = shY + shH;
    }

    // ‚ïê‚ïê‚ïê üìÖ Îç∞ÏùºÎ¶¨ Ï±åÎ¶∞ÏßÄ ‚ïê‚ïê‚ïê
    const dailyCh = getTodayChallenge();
    const dailyKey = getDailyChallengeKey();
    const dailyCleared = localStorage.getItem('daily_clear_' + dailyKey) === 'true';
    const dailyY = scoreHistoryEndY + 16;
    const dailyBoxH = 70;
    const dailyGfx = this.add.graphics().setDepth(10);
    dailyGfx.fillStyle(0x1A1E2E, 0.8);
    dailyGfx.fillRoundedRect(W/2 - btnW/2 - 10, dailyY - 8, btnW + 20, dailyBoxH, 8);
    dailyGfx.lineStyle(1, 0xFFAA00, 0.4);
    dailyGfx.strokeRoundedRect(W/2 - btnW/2 - 10, dailyY - 8, btnW + 20, dailyBoxH, 8);

    this.add.text(W / 2, dailyY + 4, `üìÖ Ïò§ÎäòÏùò Ï±åÎ¶∞ÏßÄ: ${dailyCh.name}`, {
      fontSize: '13px', fontFamily: 'monospace', color: '#FFD700'
    }).setOrigin(0.5, 0).setDepth(11);
    this.add.text(W / 2, dailyY + 22, dailyCh.desc, {
      fontSize: '11px', fontFamily: 'monospace', color: '#aabbcc', wordWrap: { width: btnW - 20 }, align: 'center'
    }).setOrigin(0.5, 0).setDepth(11);

    if (dailyCleared) {
      this.add.text(W / 2, dailyY + 44, '‚úÖ ÌÅ¥Î¶¨Ïñ¥ ÏôÑÎ£å!', {
        fontSize: '12px', fontFamily: 'monospace', color: '#44DD44'
      }).setOrigin(0.5, 0).setDepth(11);
    } else {
      const dailyBtnW2 = 80, dailyBtnH2 = 24;
      const dbg = this.add.graphics().setDepth(11);
      dbg.fillStyle(0xFF6B35, 0.9);
      dbg.fillRoundedRect(W/2 - dailyBtnW2/2, dailyY + 42, dailyBtnW2, dailyBtnH2, 6);
      this.add.text(W / 2, dailyY + 42 + dailyBtnH2/2, 'üéØ ÎèÑÏ†Ñ', {
        fontSize: '12px', fontFamily: 'monospace', color: '#fff', fontStyle: 'bold'
      }).setOrigin(0.5).setDepth(12);
      const dailyHit = this.add.rectangle(W/2, dailyY + 42 + dailyBtnH2/2, dailyBtnW2, dailyBtnH2, 0, 0).setInteractive({ useHandCursor: true }).setDepth(13);
      dailyHit.on('pointerdown', () => {
        this.scene.start('Boot', { loadSave: false, playerClass: localStorage.getItem('whiteout_class') || 'warrior', dailyChallenge: dailyCh });
      });
    }

    // Version
    this.add.text(W - 10, H - 10, 'v2.1', {
      fontSize: '11px', fontFamily: 'monospace', color: '#334'
    }).setOrigin(1, 1);

    // ‚ïê‚ïê‚ïê ? ÎèÑÏõÄÎßê Î≤ÑÌäº ‚ïê‚ïê‚ïê
    const helpBtnSize = 36;
    const helpBg = this.add.graphics().setDepth(20);
    helpBg.fillStyle(0x334466, 0.8);
    helpBg.fillCircle(30, H - 30, helpBtnSize / 2);
    helpBg.lineStyle(2, 0x6688aa, 0.6);
    helpBg.strokeCircle(30, H - 30, helpBtnSize / 2);
    const helpTxt = this.add.text(30, H - 30, '?', {
      fontSize: '20px', fontFamily: 'monospace', color: '#aaccee', fontStyle: 'bold'
    }).setOrigin(0.5).setDepth(21);
    const helpHit = this.add.circle(30, H - 30, helpBtnSize / 2, 0, 0).setInteractive({ useHandCursor: true }).setDepth(22);
    helpHit.on('pointerdown', () => this._showHelpModal());
    
    this.elapsed = 0;
  }

  _showHelpModal() {
    const W = this.scale.width;
    const H = this.scale.height;
    const allEl = [];
    const destroy = () => allEl.forEach(o => { try { o.destroy(); } catch(e) {} });

    const ov = this.add.rectangle(W/2, H/2, W, H, 0x000000, 0.85).setInteractive().setDepth(300);
    allEl.push(ov);
    const pw = Math.min(380, W * 0.85);
    const ph = Math.min(340, H * 0.7);
    const panel = this.add.graphics().setDepth(301);
    panel.fillStyle(0x0A0E1A, 0.98);
    panel.fillRoundedRect(W/2 - pw/2, H/2 - ph/2, pw, ph, 12);
    panel.lineStyle(2, 0x4488ff, 0.6);
    panel.strokeRoundedRect(W/2 - pw/2, H/2 - ph/2, pw, ph, 12);
    allEl.push(panel);

    const title = this.add.text(W/2, H/2 - ph/2 + 30, 'üìñ ÌîåÎ†àÏù¥ Î∞©Î≤ï', {
      fontSize: '22px', fontFamily: 'monospace', color: '#e0e8ff', stroke: '#000', strokeThickness: 3
    }).setOrigin(0.5).setDepth(302);
    allEl.push(title);

    const helpLines = [
      'üïπÔ∏è Ïù¥Îèô: WASD ÎòêÎäî ÌôîÏÇ¥ÌëúÌÇ§ (Î™®Î∞îÏùº: Ï°∞Ïù¥Ïä§Ìã±)',
      '‚öîÔ∏è Í≥µÍ≤©: Ï†ÅÏóêÍ≤å Îã§Í∞ÄÍ∞ÄÎ©¥ ÏûêÎèô Í≥µÍ≤©',
      '‚¨ÜÔ∏è Î†àÎ≤®ÏóÖ: Ï†Å Ï≤òÏπò ‚Üí XP ‚Üí 3Í∞ú Ïπ¥Îìú Ï§ë ÌÉù 1',
      '‚ùÑÔ∏è ÏÉùÏ°¥: ÌïúÌåå Îïå Ï≤¥Ïò® Í¥ÄÎ¶¨! Ï∫†ÌîÑÌååÏù¥Ïñ¥ ÌôúÏö©',
      'ü™µ Í±¥ÏÑ§: ÏûêÏõêÏùÑ Î™®ÏïÑ Í±¥Î¨ºÏùÑ ÏßÄÏúºÎ©¥ Ïú†Î¶¨',
      'üó°Ô∏è Ïû•ÎπÑ: Ï†ÅÏù¥ ÎìúÎ°≠ÌïòÎäî Ïû•ÎπÑÎ°ú Í∞ïÌï¥ÏßÄÏÑ∏Ïöî',
      'üîÆ ÏòÅÍµ¨ Í∞ïÌôî: Í≤åÏûÑ Ï¢ÖÎ£å Ïãú Ìè¨Ïù∏Ìä∏ ÌöçÎìù ‚Üí Îã§Ïùå Ìåê Ï†ÅÏö©',
    ];
    helpLines.forEach((line, i) => {
      const t = this.add.text(W/2, H/2 - ph/2 + 70 + i * 30, line, {
        fontSize: '12px', fontFamily: 'monospace', color: '#AABBDD', wordWrap: { width: pw - 40 }
      }).setOrigin(0.5).setDepth(302);
      allEl.push(t);
    });

    const closeBtn = this.add.text(W/2, H/2 + ph/2 - 30, 'Îã´Í∏∞', {
      fontSize: '16px', fontFamily: 'monospace', color: '#FFD700', fontStyle: 'bold'
    }).setOrigin(0.5).setDepth(302).setInteractive({ useHandCursor: true });
    allEl.push(closeBtn);
    closeBtn.on('pointerdown', destroy);
    ov.on('pointerdown', destroy);
  }
  
  _createButton(x, y, w, h, text, color, callback) {
    const isOrange = color === 0x2255aa || color === 0xaa44aa;
    const bg = this.add.graphics();
    if (isOrange) {
      // Orange CTA gradient
      bg.fillStyle(0xFF6B35, 0.9);
      bg.fillRoundedRect(x - w / 2, y - h / 2, w, h, 12);
      bg.fillStyle(0xE65100, 0.5);
      bg.fillRoundedRect(x - w / 2, y - h / 2 + h * 0.5, w, h * 0.5, { tl: 0, tr: 0, bl: 12, br: 12 });
    } else {
      bg.fillStyle(color, 0.8);
      bg.fillRoundedRect(x - w / 2, y - h / 2, w, h, 12);
    }
    bg.lineStyle(2, isOrange ? 0xFFAA66 : 0x88aadd, 0.5);
    bg.strokeRoundedRect(x - w / 2, y - h / 2, w, h, 12);
    
    const txt = this.add.text(x, y, text, {
      fontSize: '20px', fontFamily: 'monospace', color: '#fff',
      stroke: '#000', strokeThickness: 2, fontStyle: 'bold'
    }).setOrigin(0.5);
    
    const hitArea = this.add.rectangle(x, y, w, h, 0x000000, 0).setInteractive({ useHandCursor: true });
    hitArea.on('pointerover', () => {
      bg.clear();
      if (isOrange) {
        bg.fillStyle(0xFF8C42, 1);
        bg.fillRoundedRect(x - w / 2, y - h / 2, w, h, 12);
        bg.fillStyle(0xE65100, 0.5);
        bg.fillRoundedRect(x - w / 2, y - h / 2 + h * 0.5, w, h * 0.5, { tl: 0, tr: 0, bl: 12, br: 12 });
      } else {
        bg.fillStyle(color, 1);
        bg.fillRoundedRect(x - w / 2, y - h / 2, w, h, 12);
      }
      bg.lineStyle(2, isOrange ? 0xFFCC88 : 0xaaccff, 0.8);
      bg.strokeRoundedRect(x - w / 2, y - h / 2, w, h, 12);
      // Scale up on hover
      this.tweens.add({ targets: [bg, txt], scale: 1.05, duration: 120, ease: 'Quad.Out' });
    });
    hitArea.on('pointerout', () => {
      bg.clear();
      if (isOrange) {
        bg.fillStyle(0xFF6B35, 0.9);
        bg.fillRoundedRect(x - w / 2, y - h / 2, w, h, 12);
        bg.fillStyle(0xE65100, 0.5);
        bg.fillRoundedRect(x - w / 2, y - h / 2 + h * 0.5, w, h * 0.5, { tl: 0, tr: 0, bl: 12, br: 12 });
      } else {
        bg.fillStyle(color, 0.8);
        bg.fillRoundedRect(x - w / 2, y - h / 2, w, h, 12);
      }
      bg.lineStyle(2, isOrange ? 0xFFAA66 : 0x88aadd, 0.5);
      bg.strokeRoundedRect(x - w / 2, y - h / 2, w, h, 12);
      // Scale back to normal
      this.tweens.add({ targets: [bg, txt], scale: 1, duration: 120, ease: 'Quad.Out' });
    });
    hitArea.on('pointerdown', () => {
      // Scale 0.95 press effect
      this.tweens.add({ targets: [bg, txt], scale: 0.95, duration: 60, yoyo: true, ease: 'Quad.InOut',
        onComplete: () => { bg.setScale(1); txt.setScale(1); callback(); }
      });
    });
    
    return { bg, txt, hitArea };
  }
  
  _showSkinPopup() {
    const W = this.scale.width;
    const H = this.scale.height;
    const allElements = [];
    const destroy = () => allElements.forEach(o => { try { o.destroy(); } catch(e) {} });

    const overlay = this.add.rectangle(W/2, H/2, W, H, 0x000000, 0.85).setInteractive().setDepth(200);
    allElements.push(overlay);
    overlay.on('pointerdown', destroy);

    const titleTxt = this.add.text(W/2, H*0.08, 'üé® ÌîåÎ†àÏù¥Ïñ¥ Ïä§ÌÇ®', {
      fontSize: Math.min(24, W*0.045)+'px', fontFamily:'monospace', color:'#e0e8ff', stroke:'#000', strokeThickness:3
    }).setOrigin(0.5).setDepth(201);
    allElements.push(titleTxt);

    const cols = 4;
    const cellW = Math.min(80, W * 0.2);
    const cellH = 90;
    const gap = 8;
    const totalGridW = cols * cellW + (cols-1) * gap;
    const startX = W/2 - totalGridW/2 + cellW/2;
    const startY = H * 0.18;

    const selectedId = SkinManager.getSelectedId();

    PLAYER_SKINS.forEach((skin, i) => {
      const col = i % cols;
      const row = Math.floor(i / cols);
      const cx = startX + col * (cellW + gap);
      const cy = startY + row * (cellH + gap);
      const unlocked = SkinManager.isUnlocked(skin.id);
      const isSelected = skin.id === selectedId;

      const g = this.add.graphics().setDepth(201);
      g.fillStyle(isSelected ? 0x2a3a4e : 0x1a1a2e, 0.95);
      g.fillRoundedRect(cx - cellW/2, cy - cellH/2, cellW, cellH, 6);
      g.lineStyle(2, isSelected ? 0xFFD700 : (unlocked ? 0x556688 : 0x333344), 1);
      g.strokeRoundedRect(cx - cellW/2, cy - cellH/2, cellW, cellH, 6);

      // Skin preview circle
      const previewG = this.add.graphics().setDepth(202);
      if (unlocked) {
        previewG.fillStyle(skin.color, 1);
        previewG.fillCircle(cx, cy - 16, 14);
        previewG.lineStyle(2, skin.outline, 1);
        previewG.strokeCircle(cx, cy - 16, 14);
      } else {
        previewG.fillStyle(0x333333, 1);
        previewG.fillCircle(cx, cy - 16, 14);
        previewG.lineStyle(2, 0x555555, 1);
        previewG.strokeCircle(cx, cy - 16, 14);
      }
      allElements.push(previewG);

      // Lock icon or name
      if (unlocked) {
        const nameTxt = this.add.text(cx, cy + 10, skin.name, {
          fontSize: '10px', fontFamily: 'monospace', color: isSelected ? '#FFD700' : '#CCDDEE'
        }).setOrigin(0.5).setDepth(202);
        allElements.push(nameTxt);
        if (isSelected) {
          const selTxt = this.add.text(cx, cy + 24, '‚úì ÏÑ†ÌÉùÎê®', {
            fontSize: '9px', fontFamily: 'monospace', color: '#88FF88'
          }).setOrigin(0.5).setDepth(202);
          allElements.push(selTxt);
        }
      } else {
        const lockTxt = this.add.text(cx, cy - 16, 'üîí', {
          fontSize: '16px'
        }).setOrigin(0.5).setDepth(203);
        allElements.push(lockTxt);
        const condTxt = this.add.text(cx, cy + 10, SkinManager.getUnlockDescription(skin.unlockCondition), {
          fontSize: '8px', fontFamily: 'monospace', color: '#666677', wordWrap: { width: cellW - 8 }, align: 'center'
        }).setOrigin(0.5).setDepth(202);
        allElements.push(condTxt);
      }

      allElements.push(g);

      // Click to select
      if (unlocked && !isSelected) {
        const hit = this.add.rectangle(cx, cy, cellW, cellH, 0, 0).setInteractive({ useHandCursor: true }).setDepth(204);
        allElements.push(hit);
        hit.on('pointerdown', () => {
          SkinManager.select(skin.id);
          destroy();
          this._showSkinPopup();
        });
      }
    });

    // Close button
    const closeTxt = this.add.text(W/2, H*0.85, 'Îã´Í∏∞', {
      fontSize: '18px', fontFamily: 'monospace', color: '#AABBCC', fontStyle: 'bold'
    }).setOrigin(0.5).setDepth(201).setInteractive({ useHandCursor: true });
    closeTxt.on('pointerdown', destroy);
    allElements.push(closeTxt);
  }

  _showConfirmDialog() {
    const W = this.scale.width;
    const H = this.scale.height;
    
    // Overlay
    const overlay = this.add.rectangle(W / 2, H / 2, W, H, 0x000000, 0.7).setInteractive().setDepth(100);
    
    // Dialog box
    const dlg = this.add.graphics().setDepth(101);
    const dw = Math.min(320, W * 0.7);
    const dh = 180;
    dlg.fillStyle(0x1a1a2e, 0.95);
    dlg.fillRoundedRect(W / 2 - dw / 2, H / 2 - dh / 2, dw, dh, 12);
    dlg.lineStyle(2, 0xff6644, 0.8);
    dlg.strokeRoundedRect(W / 2 - dw / 2, H / 2 - dh / 2, dw, dh, 12);
    
    const title = this.add.text(W / 2, H / 2 - 50, '‚ö†Ô∏è Í≤ΩÍ≥†', {
      fontSize: '20px', fontFamily: 'monospace', color: '#ff8866'
    }).setOrigin(0.5).setDepth(102);
    
    const msg = this.add.text(W / 2, H / 2 - 15, 'Í∏∞Ï°¥ Ï†ÄÏû• Îç∞Ïù¥ÌÑ∞Í∞Ä ÏÇ≠Ï†úÎê©ÎãàÎã§.\nÏ†ïÎßê ÏÉàÎ°ú ÏãúÏûëÌïòÏãúÍ≤†ÏäµÎãàÍπå?', {
      fontSize: '14px', fontFamily: 'monospace', color: '#ccccdd', align: 'center'
    }).setOrigin(0.5).setDepth(102);
    
    // Confirm button
    const confirmBg = this.add.graphics().setDepth(102);
    confirmBg.fillStyle(0xcc3322, 0.9); confirmBg.fillRoundedRect(W / 2 - 70 - 50, H / 2 + 40, 100, 36, 6);
    const confirmTxt = this.add.text(W / 2 - 70, H / 2 + 58, 'ÏÇ≠Ï†ú ÌõÑ ÏãúÏûë', { fontSize: '13px', fontFamily: 'monospace', color: '#fff' }).setOrigin(0.5).setDepth(102);
    const confirmHit = this.add.rectangle(W / 2 - 70, H / 2 + 58, 100, 36, 0, 0).setInteractive({ useHandCursor: true }).setDepth(103);
    confirmHit.on('pointerdown', () => {
      SaveManager.delete();
      this.scene.start('Boot', { loadSave: false });
    });
    
    // Cancel button
    const cancelBg = this.add.graphics().setDepth(102);
    cancelBg.fillStyle(0x334466, 0.9); cancelBg.fillRoundedRect(W / 2 + 70 - 50, H / 2 + 40, 100, 36, 6);
    const cancelTxt = this.add.text(W / 2 + 70, H / 2 + 58, 'Ï∑®ÏÜå', { fontSize: '13px', fontFamily: 'monospace', color: '#aabbcc' }).setOrigin(0.5).setDepth(102);
    const cancelHit = this.add.rectangle(W / 2 + 70, H / 2 + 58, 100, 36, 0, 0).setInteractive({ useHandCursor: true }).setDepth(103);
    cancelHit.on('pointerdown', () => {
      [overlay, dlg, title, msg, confirmBg, confirmTxt, confirmHit, cancelBg, cancelTxt, cancelHit].forEach(o => o.destroy());
    });
  }
  
  _showConfirmDialogThenClass() {
    const W = this.scale.width;
    const H = this.scale.height;
    const overlay = this.add.rectangle(W / 2, H / 2, W, H, 0x000000, 0.7).setInteractive().setDepth(100);
    const dlg = this.add.graphics().setDepth(101);
    const dw = Math.min(320, W * 0.7); const dh = 180;
    dlg.fillStyle(0x1a1a2e, 0.95); dlg.fillRoundedRect(W/2-dw/2, H/2-dh/2, dw, dh, 12);
    dlg.lineStyle(2, 0xff6644, 0.8); dlg.strokeRoundedRect(W/2-dw/2, H/2-dh/2, dw, dh, 12);
    const title = this.add.text(W/2, H/2-50, '‚ö†Ô∏è Í≤ΩÍ≥†', { fontSize:'20px', fontFamily:'monospace', color:'#ff8866' }).setOrigin(0.5).setDepth(102);
    const msg = this.add.text(W/2, H/2-15, 'Í∏∞Ï°¥ Ï†ÄÏû• Îç∞Ïù¥ÌÑ∞Í∞Ä ÏÇ≠Ï†úÎê©ÎãàÎã§.\nÏ†ïÎßê ÏÉàÎ°ú ÏãúÏûëÌïòÏãúÍ≤†ÏäµÎãàÍπå?', { fontSize:'14px', fontFamily:'monospace', color:'#ccccdd', align:'center' }).setOrigin(0.5).setDepth(102);
    const confirmBg = this.add.graphics().setDepth(102);
    confirmBg.fillStyle(0xcc3322, 0.9); confirmBg.fillRoundedRect(W/2-70-50, H/2+40, 100, 36, 6);
    const confirmTxt = this.add.text(W/2-70, H/2+58, 'ÏÇ≠Ï†ú ÌõÑ ÏãúÏûë', { fontSize:'13px', fontFamily:'monospace', color:'#fff' }).setOrigin(0.5).setDepth(102);
    const confirmHit = this.add.rectangle(W/2-70, H/2+58, 100, 36, 0, 0).setInteractive({ useHandCursor:true }).setDepth(103);
    confirmHit.on('pointerdown', () => {
      SaveManager.delete();
      [overlay, dlg, title, msg, confirmBg, confirmTxt, confirmHit, cancelBg, cancelTxt, cancelHit].forEach(o => o.destroy());
      this._showClassSelection();
    });
    const cancelBg = this.add.graphics().setDepth(102);
    cancelBg.fillStyle(0x334466, 0.9); cancelBg.fillRoundedRect(W/2+70-50, H/2+40, 100, 36, 6);
    const cancelTxt = this.add.text(W/2+70, H/2+58, 'Ï∑®ÏÜå', { fontSize:'13px', fontFamily:'monospace', color:'#aabbcc' }).setOrigin(0.5).setDepth(102);
    const cancelHit = this.add.rectangle(W/2+70-50, H/2+58, 100, 36, 0, 0).setInteractive({ useHandCursor:true }).setDepth(103);
    cancelHit.on('pointerdown', () => {
      [overlay, dlg, title, msg, confirmBg, confirmTxt, confirmHit, cancelBg, cancelTxt, cancelHit].forEach(o => o.destroy());
    });
  }

  _showClassSelection() {
    const W = this.scale.width;
    const H = this.scale.height;
    const allElements = [];
    // Hide DOM HUD behind class selection
    const _csHud = document.getElementById('dom-hud');
    const _csBtns = document.getElementById('bottom-buttons');
    if (_csHud) _csHud.style.visibility = 'hidden';
    if (_csBtns) _csBtns.style.display = 'none';
    const destroy = () => {
      allElements.forEach(o => { try { o.destroy(); } catch(e) {} });
      if (_csHud) _csHud.style.visibility = 'visible';
      if (_csBtns) _csBtns.style.display = '';
    };

    // Overlay
    const overlay = this.add.rectangle(W/2, H/2, W, H, 0x000000, 0.85).setInteractive().setDepth(200);
    allElements.push(overlay);

    // Title
    const titleTxt = this.add.text(W/2, H*0.10, '‚öîÔ∏è ÌÅ¥ÎûòÏä§Î•º ÏÑ†ÌÉùÌïòÏÑ∏Ïöî', {
      fontSize: Math.min(28, W*0.05)+'px', fontFamily:'monospace', color:'#e0e8ff', stroke:'#000', strokeThickness:3
    }).setOrigin(0.5).setDepth(201);
    allElements.push(titleTxt);

    // FTUE hint
    const hintTop = this.add.text(W/2, H*0.16, '‚ö° ÌÅ¥ÎûòÏä§Î•º ÏÑ†ÌÉùÌïòÎ©¥ Í≤åÏûÑÏù¥ ÏãúÏûëÎê©ÎãàÎã§', {
      fontSize: Math.min(13, W*0.025)+'px', fontFamily:'monospace', color:'#667788'
    }).setOrigin(0.5).setDepth(201);
    allElements.push(hintTop);

    let selectedClass = localStorage.getItem('whiteout_class') || 'warrior';
    let selectedDifficulty = localStorage.getItem('whiteout_difficulty') || 'normal';
    const classKeys = ['warrior', 'mage', 'survivor', 'shaman', 'hunter'];
    const diffKeys = ['normal', 'hard', 'hell'];
    const cardW = Math.min(75, W * 0.17);
    const cardH = 170;
    const gap = Math.min(10, W * 0.015);
    const totalW = cardW * 5 + gap * 4;
    const startX = W/2 - totalW/2 + cardW/2;
    const cardY = H * 0.38;

    // Class recommendation map
    const classRecommend = {
      warrior: 'üõ°Ô∏è Í∑ºÏ†ë Ï†ÑÌà¨ÏôÄ ÏÉùÏ°¥Î†•ÏùÑ ÏõêÌïòÎäî Î∂Ñ',
      mage: 'üîÆ Í∞ïÎ†•Ìïú Í¥ëÏó≠Í∏∞Î•º ÏõêÌïòÎäî Î∂Ñ',
      survivor: 'üèÉ ÏÜçÎèÑÏôÄ Ïú†Ìã∏Î¶¨Ìã∞Î•º ÏõêÌïòÎäî Î∂Ñ',
      hunter: 'üèπ ÏõêÍ±∞Î¶¨ ÌÅ¨Î¶¨Ìã∞Ïª¨Ïóê ÌäπÌôîÎêú Î∂Ñ',
      shaman: 'üåø ÌåÄ ÏÑúÌè¨Ìä∏ÏôÄ ÌûêÎßÅÏùÑ ÏõêÌïòÎäî Î∂Ñ',
    };

    // Description text (updated on selection)
    const descTxt = this.add.text(W/2, H*0.70, '', {
      fontSize:'13px', fontFamily:'monospace', color:'#ccddee', align:'center', wordWrap:{width:W*0.8}
    }).setOrigin(0.5).setDepth(201);
    allElements.push(descTxt);

    // Recommendation text
    const recommendTxt = this.add.text(W/2, H*0.74, '', {
      fontSize:'11px', fontFamily:'monospace', color:'#88BBAA', align:'center'
    }).setOrigin(0.5).setDepth(201);
    allElements.push(recommendTxt);

    // Stat bars container
    const statBarGfx = this.add.graphics().setDepth(201);
    allElements.push(statBarGfx);
    const statBarLabels = [];
    const statBarY = H * 0.78;
    const barW = Math.min(180, W * 0.35);
    const barH = 10;
    const statNames = ['HP', 'Í≥µÍ≤©', 'ÏÜçÎèÑ', 'ÏÉùÏ°¥'];
    const statKeys = ['hp', 'atk', 'spd', 'surv'];
    const statColors = [0x44BB44, 0xFF4444, 0x44AAFF, 0xFFAA44];
    statNames.forEach((name, i) => {
      const lbl = this.add.text(W/2 - barW/2 - 40, statBarY + i * 18, name, {
        fontSize: '10px', fontFamily: 'monospace', color: '#8899aa'
      }).setOrigin(1, 0.5).setDepth(202);
      allElements.push(lbl);
      statBarLabels.push(lbl);
    });

    // Star rating helper
    const stars = (val, max=5) => '‚òÖ'.repeat(Math.round(val)) + '‚òÜ'.repeat(max - Math.round(val));

    const cardElements = []; // track per-card elements for highlight updates
    const cardGfx = [];

    const updateSelection = () => {
      const cls = PLAYER_CLASSES[selectedClass];
      descTxt.setText(`${cls.icon} ${cls.name}: ${cls.desc}\nÌå®ÏãúÎ∏å: ${cls.passives.join(' / ')}`);
      recommendTxt.setText(classRecommend[selectedClass] || '');
      // Draw stat bars
      statBarGfx.clear();
      statKeys.forEach((key, i) => {
        const val = cls.ratings[key] || 0;
        const y = statBarY + i * 18;
        // Background
        statBarGfx.fillStyle(0x222244, 0.8);
        statBarGfx.fillRoundedRect(W/2 - barW/2, y - barH/2, barW, barH, 3);
        // Fill
        statBarGfx.fillStyle(statColors[i], 0.9);
        statBarGfx.fillRoundedRect(W/2 - barW/2, y - barH/2, barW * (val / 5), barH, 3);
      });
      // Update card highlights
      classKeys.forEach((k, i) => {
        const isSelected = k === selectedClass;
        const g = cardGfx[i];
        const cx = startX + i * (cardW + gap);
        g.clear();
        // Background
        g.fillStyle(isSelected ? 0x2a2a4e : 0x1a1a2e, 0.95);
        g.fillRoundedRect(cx - cardW/2, cardY - cardH/2, cardW, cardH, 8);
        // Border
        const borderColor = PLAYER_CLASSES[k].colorHex;
        g.lineStyle(isSelected ? 3 : 1, borderColor, isSelected ? 1 : 0.5);
        g.strokeRoundedRect(cx - cardW/2, cardY - cardH/2, cardW, cardH, 8);
        if (isSelected) {
          // Glow effect
          g.lineStyle(1, borderColor, 0.3);
          g.strokeRoundedRect(cx - cardW/2 - 3, cardY - cardH/2 - 3, cardW + 6, cardH + 6, 10);
        }
      });
    };

    classKeys.forEach((k, i) => {
      const cls = PLAYER_CLASSES[k];
      const cx = startX + i * (cardW + gap);

      // Card background graphics
      const g = this.add.graphics().setDepth(201);
      allElements.push(g);
      cardGfx.push(g);

      // Icon + name
      const iconTxt = this.add.text(cx, cardY - cardH/2 + 22, cls.icon, {
        fontSize:'24px'
      }).setOrigin(0.5).setDepth(202);
      allElements.push(iconTxt);

      const nameTxt = this.add.text(cx, cardY - cardH/2 + 45, cls.name, {
        fontSize:'14px', fontFamily:'monospace', color: cls.color, fontStyle:'bold'
      }).setOrigin(0.5).setDepth(202);
      allElements.push(nameTxt);

      // Stats
      const statY = cardY - cardH/2 + 65;
      const statStyle = { fontSize:'10px', fontFamily:'monospace', color:'#aabbcc' };
      const labels = [
        `HP: ${stars(cls.ratings.hp)}`,
        `Í≥µÍ≤©: ${stars(cls.ratings.atk)}`,
        `ÏÜçÎèÑ: ${stars(cls.ratings.spd)}`,
        `ÏÉùÏ°¥: ${stars(cls.ratings.surv)}`,
      ];
      labels.forEach((lbl, li) => {
        const st = this.add.text(cx, statY + li * 16, lbl, statStyle).setOrigin(0.5).setDepth(202);
        allElements.push(st);
      });

      // üé® Skin preview circle
      const skinData = SkinManager.getCurrentSkin();
      const skinPreviewG = this.add.graphics().setDepth(202);
      skinPreviewG.fillStyle(skinData.color, 1);
      skinPreviewG.fillCircle(cx + cardW/2 - 14, cardY - cardH/2 + 14, 6);
      skinPreviewG.lineStyle(1, skinData.outline, 1);
      skinPreviewG.strokeCircle(cx + cardW/2 - 14, cardY - cardH/2 + 14, 6);
      allElements.push(skinPreviewG);

      // Clickable area
      const hitArea = this.add.rectangle(cx, cardY, cardW, cardH, 0, 0).setInteractive({ useHandCursor: true }).setDepth(203);
      allElements.push(hitArea);
      hitArea.on('pointerdown', () => { selectedClass = k; updateSelection(); });
    });

    updateSelection();

    // ‚ïê‚ïê‚ïê ÎÇúÏù¥ÎèÑ ÏÑ†ÌÉù ‚ïê‚ïê‚ïê
    const diffY = H * 0.68;
    const diffBtnW = Math.min(80, W * 0.2);
    const diffBtnH = 32;
    const diffGap = Math.min(10, W * 0.02);
    const diffTotalW = diffBtnW * 3 + diffGap * 2;
    const diffStartX = W/2 - diffTotalW/2 + diffBtnW/2;

    const diffLabel = this.add.text(W/2, diffY - 22, 'ÎÇúÏù¥ÎèÑ', {
      fontSize: '13px', fontFamily: 'monospace', color: '#8899aa'
    }).setOrigin(0.5).setDepth(201);
    allElements.push(diffLabel);

    const diffWarnTxt = this.add.text(W/2, diffY + diffBtnH/2 + 14, '', {
      fontSize: '11px', fontFamily: 'monospace', color: '#FF8800'
    }).setOrigin(0.5).setDepth(201);
    allElements.push(diffWarnTxt);

    const diffGfxArr = [];
    const diffTxtArr = [];

    const updateDiffSelection = () => {
      const dm = DIFFICULTY_MODES[selectedDifficulty];
      diffWarnTxt.setText(dm.warn);
      diffWarnTxt.setColor(dm.color);
      diffKeys.forEach((dk, di) => {
        const isSelected = dk === selectedDifficulty;
        const ddm = DIFFICULTY_MODES[dk];
        const dx = diffStartX + di * (diffBtnW + diffGap);
        const g = diffGfxArr[di];
        g.clear();
        g.fillStyle(isSelected ? ddm.colorHex : 0x1a1a2e, isSelected ? 0.9 : 0.6);
        g.fillRoundedRect(dx - diffBtnW/2, diffY - diffBtnH/2, diffBtnW, diffBtnH, 6);
        g.lineStyle(isSelected ? 2 : 1, ddm.colorHex, isSelected ? 1 : 0.4);
        g.strokeRoundedRect(dx - diffBtnW/2, diffY - diffBtnH/2, diffBtnW, diffBtnH, 6);
        diffTxtArr[di].setColor(isSelected ? '#ffffff' : '#888888');
      });
    };

    diffKeys.forEach((dk, di) => {
      const ddm = DIFFICULTY_MODES[dk];
      const dx = diffStartX + di * (diffBtnW + diffGap);
      const g = this.add.graphics().setDepth(201);
      allElements.push(g);
      diffGfxArr.push(g);
      const t = this.add.text(dx, diffY, ddm.name, {
        fontSize: '12px', fontFamily: 'monospace', color: '#888888', fontStyle: 'bold'
      }).setOrigin(0.5).setDepth(202);
      allElements.push(t);
      diffTxtArr.push(t);
      const hit = this.add.rectangle(dx, diffY, diffBtnW, diffBtnH, 0, 0).setInteractive({ useHandCursor: true }).setDepth(203);
      allElements.push(hit);
      hit.on('pointerdown', () => { selectedDifficulty = dk; updateDiffSelection(); if (dk === 'hell') playHellSelect(); });
    });

    updateDiffSelection();

    // ‚ïê‚ïê‚ïê Í≥†Í∏â ÏÑ§Ï†ï (Ï†ëÍ∏∞/ÌéºÏπòÍ∏∞) ‚ïê‚ïê‚ïê
    let endlessMode = localStorage.getItem('whiteout_endless') === 'true';
    const rec = RecordManager.load();
    const ngPlusUnlocked = rec.wins > 0;
    let ngPlusMode = false;
    let bossRushMode = false;
    let advancedOpen = false;
    const advBtnY = diffY + diffBtnH/2 + 36;
    const advElements = []; // elements shown only when expanded

    // "‚öôÔ∏è Í≥†Í∏â ÏÑ§Ï†ï" toggle button
    const advToggleTxt = this.add.text(W/2, advBtnY, '‚öôÔ∏è Í≥†Í∏â ÏÑ§Ï†ï ‚ñº', {
      fontSize: '13px', fontFamily: 'monospace', color: '#8899bb'
    }).setOrigin(0.5).setDepth(202);
    allElements.push(advToggleTxt);
    const advToggleHit = this.add.rectangle(W/2, advBtnY, 200, 28, 0, 0).setInteractive({ useHandCursor: true }).setDepth(203);
    allElements.push(advToggleHit);

    // Create advanced toggle elements (hidden initially)
    const endlessY = advBtnY + 30;
    const endlessGfx = this.add.graphics().setDepth(201);
    advElements.push(endlessGfx); allElements.push(endlessGfx);
    const endlessTxt = this.add.text(W/2 + 14, endlessY, '‚ôæÔ∏è Î¨¥Ìïú Î™®Îìú (60Î∂Ñ Ïù¥ÌõÑ Í≥ÑÏÜç)', {
      fontSize: '12px', fontFamily: 'monospace', color: '#888899'
    }).setOrigin(0, 0.5).setDepth(202);
    advElements.push(endlessTxt); allElements.push(endlessTxt);

    const drawEndlessToggle = () => {
      endlessGfx.clear();
      const cbx = W/2 - 8, cby = endlessY - 8;
      endlessGfx.fillStyle(endlessMode ? 0x44BB44 : 0x333344, 0.9);
      endlessGfx.fillRoundedRect(cbx, cby, 16, 16, 3);
      endlessGfx.lineStyle(1, endlessMode ? 0x66DD66 : 0x555566, 1);
      endlessGfx.strokeRoundedRect(cbx, cby, 16, 16, 3);
      endlessTxt.setColor(endlessMode ? '#44FF44' : '#888899');
    };
    const endlessHit = this.add.rectangle(W/2 + 60, endlessY, 200, 24, 0, 0).setInteractive({ useHandCursor: true }).setDepth(203);
    advElements.push(endlessHit); allElements.push(endlessHit);
    endlessHit.on('pointerdown', () => { endlessMode = !endlessMode; if (endlessMode) { speedrunMode = false; drawSpeedrunToggle(); } drawEndlessToggle(); });

    const ngPlusY = endlessY + 28;
    const ngPlusGfx = this.add.graphics().setDepth(201);
    advElements.push(ngPlusGfx); allElements.push(ngPlusGfx);
    const ngPlusLevel = rec.ngPlusClears || 0;
    const ngPlusLabel = ngPlusLevel > 0 ? `‚≠ê NG+ (Lv${ngPlusLevel + 1})` : '‚≠ê NEW GAME+';
    const ngPlusTxt = this.add.text(W/2 + 14, ngPlusY, ngPlusLabel + (ngPlusUnlocked ? '' : ' üîí'), {
      fontSize: '12px', fontFamily: 'monospace', color: ngPlusUnlocked ? '#888899' : '#555566'
    }).setOrigin(0, 0.5).setDepth(202);
    advElements.push(ngPlusTxt); allElements.push(ngPlusTxt);

    const drawNgPlusToggle = () => {
      ngPlusGfx.clear();
      const cbx = W/2 - 8, cby = ngPlusY - 8;
      if (!ngPlusUnlocked) {
        ngPlusGfx.fillStyle(0x222233, 0.5); ngPlusGfx.fillRoundedRect(cbx, cby, 16, 16, 3);
        ngPlusGfx.lineStyle(1, 0x333344, 0.5); ngPlusGfx.strokeRoundedRect(cbx, cby, 16, 16, 3);
      } else {
        ngPlusGfx.fillStyle(ngPlusMode ? 0xFFD700 : 0x333344, 0.9); ngPlusGfx.fillRoundedRect(cbx, cby, 16, 16, 3);
        ngPlusGfx.lineStyle(1, ngPlusMode ? 0xFFAA00 : 0x555566, 1); ngPlusGfx.strokeRoundedRect(cbx, cby, 16, 16, 3);
        ngPlusTxt.setColor(ngPlusMode ? '#FFD700' : '#888899');
      }
    };
    if (ngPlusUnlocked) {
      const ngPlusHit = this.add.rectangle(W/2 + 60, ngPlusY, 200, 24, 0, 0).setInteractive({ useHandCursor: true }).setDepth(203);
      advElements.push(ngPlusHit); allElements.push(ngPlusHit);
      ngPlusHit.on('pointerdown', () => { ngPlusMode = !ngPlusMode; drawNgPlusToggle(); });
    }

    const bossRushY = ngPlusY + 28;
    const bossRushGfx = this.add.graphics().setDepth(201);
    advElements.push(bossRushGfx); allElements.push(bossRushGfx);
    const bossRushTxt = this.add.text(W/2 + 14, bossRushY, 'üî¥ Î≥¥Ïä§ Îü¨Ïãú', {
      fontSize: '12px', fontFamily: 'monospace', color: '#888899'
    }).setOrigin(0, 0.5).setDepth(202);
    advElements.push(bossRushTxt); allElements.push(bossRushTxt);
    const drawBossRushToggle = () => {
      bossRushGfx.clear();
      const cbx = W/2 - 8, cby = bossRushY - 8;
      bossRushGfx.fillStyle(bossRushMode ? 0xFF4444 : 0x333344, 0.9); bossRushGfx.fillRoundedRect(cbx, cby, 16, 16, 3);
      bossRushGfx.lineStyle(1, bossRushMode ? 0xFF6666 : 0x555566, 1); bossRushGfx.strokeRoundedRect(cbx, cby, 16, 16, 3);
      bossRushTxt.setColor(bossRushMode ? '#FF6666' : '#888899');
    };
    const bossRushHit = this.add.rectangle(W/2 + 60, bossRushY, 200, 24, 0, 0).setInteractive({ useHandCursor: true }).setDepth(203);
    advElements.push(bossRushHit); allElements.push(bossRushHit);
    bossRushHit.on('pointerdown', () => { bossRushMode = !bossRushMode; drawBossRushToggle(); });

    // ‚ïê‚ïê‚ïê Speedrun Toggle ‚ïê‚ïê‚ïê
    let speedrunMode = false;
    const speedrunY = bossRushY + 28;
    const speedrunGfx = this.add.graphics().setDepth(201);
    advElements.push(speedrunGfx); allElements.push(speedrunGfx);
    const speedrunTxt = this.add.text(W/2 + 14, speedrunY, '‚ö° Ïä§ÌîºÎìúÎü∞ (30Î∂Ñ ÌÅ¥Î¶¨Ïñ¥)', {
      fontSize: '12px', fontFamily: 'monospace', color: '#888899'
    }).setOrigin(0, 0.5).setDepth(202);
    advElements.push(speedrunTxt); allElements.push(speedrunTxt);
    const drawSpeedrunToggle = () => {
      speedrunGfx.clear();
      const cbx = W/2 - 8, cby = speedrunY - 8;
      speedrunGfx.fillStyle(speedrunMode ? 0xFFAA00 : 0x333344, 0.9); speedrunGfx.fillRoundedRect(cbx, cby, 16, 16, 3);
      speedrunGfx.lineStyle(1, speedrunMode ? 0xFFCC44 : 0x555566, 1); speedrunGfx.strokeRoundedRect(cbx, cby, 16, 16, 3);
      speedrunTxt.setColor(speedrunMode ? '#FFCC44' : '#888899');
    };
    const speedrunHit = this.add.rectangle(W/2 + 60, speedrunY, 200, 24, 0, 0).setInteractive({ useHandCursor: true }).setDepth(203);
    advElements.push(speedrunHit); allElements.push(speedrunHit);
    speedrunHit.on('pointerdown', () => { speedrunMode = !speedrunMode; if (speedrunMode) { endlessMode = false; drawEndlessToggle(); } drawSpeedrunToggle(); });

    // ‚ïê‚ïê‚ïê Handicap Dropdown ‚ïê‚ïê‚ïê
    const handicapOptions = ['none', 'glass_body', 'no_equipment', 'random_build', 'low_vision'];
    const handicapLabels = ['Ìï∏ÎîîÏ∫° ÏóÜÏùå', 'ü©∏ Ïú†Î¶¨Î™∏', 'üí™ Îß®ÏÜê', 'üé≤ ÎûúÎç§ ÎπåÎìú', 'üëÅÔ∏è Ï†ÄÏãúÎ†•'];
    let handicapIdx = 0;
    const handicapY = speedrunY + 28;
    const handicapTxt = this.add.text(W/2 + 14, handicapY, 'üéØ ' + handicapLabels[0], {
      fontSize: '12px', fontFamily: 'monospace', color: '#888899'
    }).setOrigin(0, 0.5).setDepth(202);
    advElements.push(handicapTxt); allElements.push(handicapTxt);
    const handicapGfx = this.add.graphics().setDepth(201);
    advElements.push(handicapGfx); allElements.push(handicapGfx);
    const drawHandicapToggle = () => {
      handicapGfx.clear();
      const cbx = W/2 - 8, cby = handicapY - 8;
      const active = handicapIdx > 0;
      handicapGfx.fillStyle(active ? 0xCC44CC : 0x333344, 0.9); handicapGfx.fillRoundedRect(cbx, cby, 16, 16, 3);
      handicapGfx.lineStyle(1, active ? 0xEE66EE : 0x555566, 1); handicapGfx.strokeRoundedRect(cbx, cby, 16, 16, 3);
      handicapTxt.setText('üéØ ' + handicapLabels[handicapIdx]);
      handicapTxt.setColor(active ? '#EE66EE' : '#888899');
    };
    const handicapHit = this.add.rectangle(W/2 + 60, handicapY, 200, 24, 0, 0).setInteractive({ useHandCursor: true }).setDepth(203);
    advElements.push(handicapHit); allElements.push(handicapHit);
    handicapHit.on('pointerdown', () => { handicapIdx = (handicapIdx + 1) % handicapOptions.length; drawHandicapToggle(); });

    // Initially hide advanced elements
    const toggleAdvanced = () => {
      advancedOpen = !advancedOpen;
      advToggleTxt.setText(advancedOpen ? '‚öôÔ∏è Í≥†Í∏â ÏÑ§Ï†ï ‚ñ≤' : '‚öôÔ∏è Í≥†Í∏â ÏÑ§Ï†ï ‚ñº');
      advElements.forEach(el => el.setVisible(advancedOpen));
      if (advancedOpen) { drawEndlessToggle(); drawNgPlusToggle(); drawBossRushToggle(); drawSpeedrunToggle(); drawHandicapToggle(); }
    };
    advElements.forEach(el => el.setVisible(false));
    advToggleHit.on('pointerdown', toggleAdvanced);

    // Confirm button
    const btnW2 = Math.min(200, W * 0.4);
    const btnH2 = 44;
    const btnY2 = H * 0.88;
    const btnBg = this.add.graphics().setDepth(201);
    btnBg.fillStyle(0x2255aa, 0.9); btnBg.fillRoundedRect(W/2 - btnW2/2, btnY2 - btnH2/2, btnW2, btnH2, 8);
    btnBg.lineStyle(2, 0x4488ff, 0.8); btnBg.strokeRoundedRect(W/2 - btnW2/2, btnY2 - btnH2/2, btnW2, btnH2, 8);
    allElements.push(btnBg);
    const btnTxt = this.add.text(W/2, btnY2, '‚ñ∂ ÏÑ†ÌÉù', {
      fontSize:'18px', fontFamily:'monospace', color:'#ffffff', fontStyle:'bold'
    }).setOrigin(0.5).setDepth(202);
    allElements.push(btnTxt);
    const btnHit = this.add.rectangle(W/2, btnY2, btnW2, btnH2, 0, 0).setInteractive({ useHandCursor: true }).setDepth(203);
    allElements.push(btnHit);
    btnHit.on('pointerdown', () => {
      try { localStorage.setItem('whiteout_class', selectedClass); } catch(e) {}
      try { localStorage.setItem('whiteout_difficulty', selectedDifficulty); } catch(e) {}
      try { localStorage.setItem('whiteout_endless', endlessMode ? 'true' : 'false'); } catch(e) {}
      destroy();
      this.scene.start('Boot', { loadSave: false, playerClass: selectedClass, difficulty: selectedDifficulty, endlessMode, ngPlus: ngPlusMode, bossRush: bossRushMode, speedrun: speedrunMode, handicap: handicapOptions[handicapIdx] });
    });

    // FTUE bottom hint
    const hintBottom = this.add.text(W/2, btnY2 + btnH2/2 + 16, 'üí° Ï≤òÏùåÏù¥ÎùºÎ©¥ ü™ì Ï†ÑÏÇ¨Î•º Ï∂îÏ≤úÌï©ÎãàÎã§', {
      fontSize: '11px', fontFamily: 'monospace', color: '#667788'
    }).setOrigin(0.5).setDepth(201);
    allElements.push(hintBottom);

    // Cancel / back
    const backTxt = this.add.text(W*0.05, H*0.05, '‚Üê Îí§Î°ú', {
      fontSize:'14px', fontFamily:'monospace', color:'#8899aa'
    }).setDepth(202).setInteractive({ useHandCursor: true });
    allElements.push(backTxt);
    backTxt.on('pointerdown', () => destroy());
  }

  _showMetaUpgradeUI(activeTab) {
    const W = this.scale.width;
    const H = this.scale.height;
    const allElements = [];
    const destroy = () => allElements.forEach(o => { try { o.destroy(); } catch(e) {} });

    // Overlay
    const overlay = this.add.rectangle(W / 2, H / 2, W, H, 0x000000, 0.85).setInteractive().setDepth(100);
    allElements.push(overlay);

    // Panel
    const panel = this.add.graphics().setDepth(101);
    const pw = Math.min(420, W * 0.9);
    const ph = Math.min(560, H * 0.88);
    const px0 = W / 2 - pw / 2, py0 = H / 2 - ph / 2;
    panel.fillStyle(0x0A0E1A, 0.98);
    panel.fillRoundedRect(px0, py0, pw, ph, 14);
    panel.lineStyle(2, 0xaa44aa, 0.6);
    panel.strokeRoundedRect(px0, py0, pw, ph, 14);
    allElements.push(panel);

    // Title
    allElements.push(this.add.text(W / 2, py0 + 24, 'üîÆ ÏòÅÍµ¨ Í∞ïÌôî', {
      fontSize: '22px', fontFamily: 'monospace', color: '#ddaaff', stroke: '#000', strokeThickness: 2
    }).setOrigin(0.5).setDepth(102));

    // Points display - big
    const available = MetaManager.getAvailablePoints();
    const meta = MetaManager.load();
    allElements.push(this.add.text(W / 2, py0 + 52, `üíé ${available} Ìè¨Ïù∏Ìä∏`, {
      fontSize: '20px', fontFamily: 'monospace', color: '#FFD700', stroke: '#000', strokeThickness: 3, fontStyle: 'bold'
    }).setOrigin(0.5).setDepth(102));

    // Tabs
    const tabs = [
      { id: 'attack', label: '‚öîÔ∏è Í≥µÍ≤©', color: 0xFF4444 },
      { id: 'defense', label: 'üõ°Ô∏è Î∞©Ïñ¥', color: 0x4488FF },
      { id: 'util', label: 'üîß Ïú†Ìã∏', color: 0x44FF88 },
      { id: 'equip', label: 'üéí Ïû•ÎπÑ', color: 0xFFAA44 }
    ];
    const currentTab = activeTab || 'attack';
    const tabW = (pw - 20) / tabs.length;
    const tabY = py0 + 76;
    tabs.forEach((tab, i) => {
      const tx = px0 + 10 + i * tabW;
      const isActive = tab.id === currentTab;
      const tg = this.add.graphics().setDepth(102);
      tg.fillStyle(isActive ? tab.color : 0x1a1a2e, isActive ? 0.9 : 0.5);
      tg.fillRoundedRect(tx, tabY, tabW - 4, 28, { tl: 6, tr: 6, bl: 0, br: 0 });
      if (isActive) { tg.lineStyle(1, tab.color, 0.8); tg.strokeRoundedRect(tx, tabY, tabW - 4, 28, { tl: 6, tr: 6, bl: 0, br: 0 }); }
      allElements.push(tg);
      allElements.push(this.add.text(tx + (tabW - 4) / 2, tabY + 14, tab.label, {
        fontSize: '12px', fontFamily: 'monospace', color: isActive ? '#fff' : '#889'
      }).setOrigin(0.5).setDepth(103));
      const tabHit = this.add.rectangle(tx + (tabW - 4) / 2, tabY + 14, tabW - 4, 28, 0, 0).setInteractive({ useHandCursor: true }).setDepth(104);
      tabHit.on('pointerdown', () => { destroy(); this._showMetaUpgradeUI(tab.id); });
      allElements.push(tabHit);
    });

    // Upgrade definitions per tab
    const allUpgrades = {
      attack: [
        { key: 'startHP', name: '‚ù§Ô∏è ÏãúÏûë Ï≤¥Î†•', desc: 'LvÎãπ +20 HP', max: 5, icon: '‚ù§Ô∏è' },
        { key: 'extraCard', name: 'üé¥ Ïπ¥Îìú ÏÑ†ÌÉùÏßÄ', desc: 'LvÎãπ +1 ÏÑ†ÌÉùÏßÄ', max: 3, icon: 'üé¥' },
      ],
      defense: [
        { key: 'startTempResist', name: 'üß• Ï≤¥Ïò® Ï†ÄÌï≠', desc: 'LvÎãπ +5% Ï†ÄÌï≠', max: 5, icon: 'üß•' },
      ],
      util: [
        { key: 'startWood', name: 'ü™µ ÏãúÏûë ÎÇòÎ¨¥', desc: 'LvÎãπ +3 ÎÇòÎ¨¥', max: 5, icon: 'ü™µ' },
        { key: 'revival_scroll', name: 'üí´ Î∂ÄÌôú Ï£ºÎ¨∏ÏÑú', desc: 'Í≤åÏûÑ Ïò§Î≤Ñ Ïãú 1Ìöå Î∂ÄÌôú', max: 1, icon: 'üí´' },
      ],
      equip: []
    };
    const upgrades = allUpgrades[currentTab] || [];
    const cardW = pw - 40;
    const cardH = 72;
    let yPos = tabY + 38;
    const RARITY_COLORS = { common: 0x888888, rare: 0x4488FF, epic: 0xAA44FF, legendary: 0xFFAA00 };

    if (upgrades.length === 0) {
      allElements.push(this.add.text(W / 2, yPos + 60, 'üöß Ï§ÄÎπÑ Ï§ë...', {
        fontSize: '16px', fontFamily: 'monospace', color: '#667788'
      }).setOrigin(0.5).setDepth(103));
    }

    upgrades.forEach(upg => {
      const level = meta.upgrades[upg.key] || 0;
      const cost = MetaManager.getUpgradeCost(upg.key, level);
      const canBuy = available >= cost && level < upg.max;
      const maxed = level >= upg.max;

      // Card background
      const cg = this.add.graphics().setDepth(102);
      const borderColor = maxed ? 0xFFD700 : (canBuy ? 0xaa44aa : 0x333344);
      cg.fillStyle(canBuy ? 0x151928 : 0x0D1018, 0.95);
      cg.fillRoundedRect(px0 + 20, yPos, cardW, cardH, 8);
      cg.lineStyle(maxed ? 2 : 1, borderColor, maxed ? 1 : 0.5);
      cg.strokeRoundedRect(px0 + 20, yPos, cardW, cardH, 8);
      allElements.push(cg);

      // Icon
      allElements.push(this.add.text(px0 + 38, yPos + cardH / 2, upg.icon, {
        fontSize: '24px'
      }).setOrigin(0.5).setDepth(103));

      // Name + Level
      const nameColor = maxed ? '#FFD700' : '#ccddee';
      allElements.push(this.add.text(px0 + 58, yPos + 10, upg.name, {
        fontSize: '13px', fontFamily: 'monospace', color: nameColor, fontStyle: 'bold'
      }).setOrigin(0, 0).setDepth(103));

      // Level progress bar
      const barX = px0 + 58, barY = yPos + 28, barW = cardW - 120, barH = 8;
      const pg = this.add.graphics().setDepth(103);
      pg.fillStyle(0x222233, 0.8); pg.fillRoundedRect(barX, barY, barW, barH, 4);
      const fillW = upg.max > 0 ? (barW * level / upg.max) : 0;
      pg.fillStyle(maxed ? 0xFFD700 : 0xaa44aa, 0.9); pg.fillRoundedRect(barX, barY, fillW, barH, 4);
      allElements.push(pg);
      allElements.push(this.add.text(barX + barW + 4, barY - 1, maxed ? 'MAX' : `${level}/${upg.max}`, {
        fontSize: '10px', fontFamily: 'monospace', color: maxed ? '#FFD700' : '#8899aa'
      }).setOrigin(0, 0).setDepth(103));

      // Description
      allElements.push(this.add.text(px0 + 58, yPos + 42, upg.desc, {
        fontSize: '10px', fontFamily: 'monospace', color: '#667788'
      }).setOrigin(0, 0).setDepth(103));

      // Cost + Buy button
      if (!maxed) {
        allElements.push(this.add.text(px0 + cardW - 10, yPos + 12, `${cost}üíé`, {
          fontSize: '11px', fontFamily: 'monospace', color: canBuy ? '#FFD700' : '#ff5555'
        }).setOrigin(1, 0).setDepth(103));
        const btnX = px0 + cardW - 10, btnY2 = yPos + 38;
        const bg2 = this.add.graphics().setDepth(103);
        bg2.fillStyle(canBuy ? 0xaa44aa : 0x333344, 0.9);
        bg2.fillRoundedRect(btnX - 52, btnY2, 56, 22, 4);
        allElements.push(bg2);
        allElements.push(this.add.text(btnX - 24, btnY2 + 11, canBuy ? 'Í∞ïÌôî' : 'Î∂ÄÏ°±', {
          fontSize: '11px', fontFamily: 'monospace', color: canBuy ? '#fff' : '#666'
        }).setOrigin(0.5).setDepth(104));
        if (canBuy) {
          const hit = this.add.rectangle(btnX - 24, btnY2 + 11, 56, 22, 0, 0).setInteractive({ useHandCursor: true }).setDepth(105);
          hit.on('pointerdown', () => { if (MetaManager.doUpgrade(upg.key)) { destroy(); this._showMetaUpgradeUI(currentTab); } });
          allElements.push(hit);
        }
      } else {
        allElements.push(this.add.text(px0 + cardW - 10, yPos + cardH / 2, '‚úÖ MAX', {
          fontSize: '14px', fontFamily: 'monospace', color: '#FFD700', fontStyle: 'bold'
        }).setOrigin(1, 0.5).setDepth(103));
      }

      yPos += cardH + 8;
    });

    // Stats
    const statsY = H / 2 + ph / 2 - 70;
    allElements.push(this.add.text(W / 2, statsY, `üèÜ ÏµúÍ≥†: ${Math.floor(meta.bestTime/60)}Î∂Ñ${Math.floor(meta.bestTime%60)}Ï¥à | üéÆ ${meta.totalRuns}Ìöå`, {
      fontSize: '11px', fontFamily: 'monospace', color: '#667788'
    }).setOrigin(0.5).setDepth(103));

    // Close button
    const closeBg = this.add.graphics().setDepth(102);
    closeBg.fillStyle(0x334455, 0.9);
    closeBg.fillRoundedRect(W / 2 - 50, H / 2 + ph / 2 - 46, 100, 34, 6);
    allElements.push(closeBg);
    allElements.push(this.add.text(W / 2, H / 2 + ph / 2 - 29, 'Îã´Í∏∞', {
      fontSize: '14px', fontFamily: 'monospace', color: '#aabbcc'
    }).setOrigin(0.5).setDepth(103));
    const closeHit = this.add.rectangle(W / 2, H / 2 + ph / 2 - 29, 100, 34, 0, 0).setInteractive({ useHandCursor: true }).setDepth(104);
    closeHit.on('pointerdown', destroy);
    allElements.push(closeHit);
  }
  
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // üìñ ÎèÑÍ∞ê (Ïª¨Î†âÏÖò) ÌôîÎ©¥
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  _showCollectionScreen() {
    const W = this.scale.width, H = this.scale.height;
    const container = [];
    let activeTab = 'achievements';

    // Overlay
    const ov = this.add.graphics().setDepth(300);
    ov.fillStyle(0x000000, 0.75); ov.fillRect(0, 0, W, H);
    container.push(ov);
    const ovHit = this.add.rectangle(W/2, H/2, W, H).setDepth(300).setOrigin(0.5).setInteractive().setAlpha(0.001);
    container.push(ovHit);

    // Panel
    const pw = Math.min(360, W - 20), ph = Math.min(520, H - 40);
    const px = W/2 - pw/2, py = H/2 - ph/2;
    const panel = this.add.graphics().setDepth(301);
    panel.fillStyle(0x0E1225, 0.97);
    panel.fillRoundedRect(px, py, pw, ph, 16);
    panel.lineStyle(2, 0x4466aa, 0.6);
    panel.strokeRoundedRect(px, py, pw, ph, 16);
    container.push(panel);

    // Title
    const titleT = this.add.text(W/2, py + 24, 'üìñ ÎèÑÍ∞ê', {
      fontSize: '22px', fontFamily: 'monospace', color: '#e0e8ff',
      stroke: '#000', strokeThickness: 3, fontStyle: 'bold'
    }).setOrigin(0.5).setDepth(302);
    container.push(titleT);

    // Tab buttons
    const tabs = [
      { id: 'achievements', label: 'üèÜ ÏÑ±Ï∑®' },
      { id: 'equipment', label: 'üì¶ Ïû•ÎπÑ' },
      { id: 'quests', label: 'üìä ÌÄòÏä§Ìä∏' },
      { id: 'runhistory', label: 'üìú Îü∞ Í∏∞Î°ù' }
    ];
    const tabW = (pw - 30) / 4;
    const tabY = py + 52;
    const tabBtns = [];

    // Content area
    const contentY = tabY + 36;
    const contentH = ph - 130;
    let contentItems = [];

    const clearContent = () => { contentItems.forEach(el => el.destroy()); contentItems = []; };

    const renderTabs = () => {
      tabBtns.forEach(t => t.destroy());
      tabBtns.length = 0;
      tabs.forEach((tab, i) => {
        const tx = px + 15 + i * tabW + tabW/2;
        const isActive = activeTab === tab.id;
        const bg = this.add.graphics().setDepth(302);
        bg.fillStyle(isActive ? 0x2244aa : 0x1A1E2E, 0.9);
        bg.fillRoundedRect(tx - tabW/2, tabY, tabW - 4, 30, 6);
        tabBtns.push(bg);
        const lbl = this.add.text(tx, tabY + 15, tab.label, {
          fontSize: '12px', fontFamily: 'monospace', color: isActive ? '#ffffff' : '#667788',
          stroke: '#000', strokeThickness: 1
        }).setOrigin(0.5).setDepth(303).setInteractive({ useHandCursor: true });
        lbl.on('pointerdown', () => { activeTab = tab.id; renderTabs(); renderContent(); });
        tabBtns.push(lbl);
      });
    };

    const SLOT_ICONS = { weapon: '‚öîÔ∏è', armor: 'üõ°Ô∏è', boots: 'üëü', helmet: 'üé©', ring: 'üíç' };
    const SLOT_NAMES = { weapon: 'Î¨¥Í∏∞', armor: 'Î∞©Ïñ¥Íµ¨', boots: 'Ïû•Ìôî', helmet: 'Î™®Ïûê', ring: 'Î∞òÏßÄ' };
    const HIDDEN_IDS = ['secret_hidden_boss', 'secret_konami', 'secret_survive_zone'];
    const ACH_CATEGORIES = [
      { key: 'basic', label: 'üèÖ Í∏∞Î≥∏ ÏÑ±Ï∑®', filter: (a) => !a.hidden && !a.category },
      { key: 'class', label: 'üèÜ ÌÅ¥ÎûòÏä§ ÎßàÏä§ÌÑ∞Î¶¨', filter: (a) => a.category === 'class' },
      { key: 'challenge', label: 'üéØ ÎèÑÏ†Ñ Î™®Îìú', filter: (a) => a.category === 'challenge' },
      { key: 'collect', label: 'üó∫Ô∏è ÌÉêÌóò/ÏàòÏßë', filter: (a) => a.category === 'collect' },
      { key: 'hidden', label: 'üîí ÌûàÎì† ÏÑ±Ï∑®', filter: (a) => a.hidden },
    ];

    const renderContent = () => {
      clearContent();
      const leftX = px + 16;
      const textW = pw - 32;
      let cy = contentY + 8;

      if (activeTab === 'achievements') {
        // Load achievements
        let saved = {};
        try { saved = JSON.parse(localStorage.getItem('achievements_whiteout') || '{}'); } catch(e) {}
        const achCount = Object.keys(saved).length;
        const total = ACHIEVEMENTS.length;
        const pct = total > 0 ? Math.round(achCount / total * 100) : 0;

        const header = this.add.text(W/2, cy, `Îã¨ÏÑ±: ${achCount} / ${total} (${pct}%)`, {
          fontSize: '14px', fontFamily: 'monospace', color: '#FFD700', stroke: '#000', strokeThickness: 2
        }).setOrigin(0.5).setDepth(303);
        contentItems.push(header);
        cy += 26;

        // Progress bar
        const barW = pw - 60, barH = 8;
        const barG = this.add.graphics().setDepth(303);
        barG.fillStyle(0x222244, 1); barG.fillRoundedRect(W/2 - barW/2, cy, barW, barH, 4);
        barG.fillStyle(0x44AA44, 1); barG.fillRoundedRect(W/2 - barW/2, cy, barW * (achCount/total), barH, 4);
        contentItems.push(barG);
        cy += 20;

        for (const cat of ACH_CATEGORIES) {
          const catAchs = ACHIEVEMENTS.filter(cat.filter);
          const catDone = catAchs.filter(a => saved[a.id]).length;
          const catHeader = this.add.text(leftX, cy, `${cat.label} (${catDone}/${catAchs.length})`, {
            fontSize: '12px', fontFamily: 'monospace', color: '#AABBDD', stroke: '#000', strokeThickness: 1
          }).setDepth(303);
          contentItems.push(catHeader);
          cy += 18;

          for (const ach of catAchs) {
            const isHidden = HIDDEN_IDS.includes(ach.id);
            const achieved = !!saved[ach.id];
            let line, color;
            if (achieved) {
              line = `  ${ach.icon} ${ach.name}  ${ach.desc}  ‚úÖ`;
              color = '#88DDAA';
            } else if (isHidden) {
              line = `  üîí ???  ÎπÑÎ∞Ä ÏÑ±Ï∑®  üîí`;
              color = '#445566';
            } else {
              line = `  ${ach.icon} ${ach.name}  ${ach.desc}  ‚¨ú`;
              color = '#667788';
            }
            const t = this.add.text(leftX, cy, line, {
              fontSize: '11px', fontFamily: 'monospace', color, wordWrap: { width: textW }
            }).setDepth(303);
            contentItems.push(t);
            cy += 20;
            if (cy > contentY + contentH - 10) break;
          }
          cy += 6;
          if (cy > contentY + contentH - 10) break;
        }
      } else if (activeTab === 'equipment') {
        const disc = EquipmentManager.loadDiscovered();
        // Also scan current equipment manager data from localStorage
        let currentSlots = {};
        try {
          const eqRaw = localStorage.getItem(EquipmentManager.STORAGE_KEY);
          if (eqRaw) { const eqData = JSON.parse(eqRaw); Object.keys(SLOT_ICONS).forEach(s => { if (eqData[s]) currentSlots[s] = eqData[s].itemId; }); }
        } catch(e) {}

        for (const slot of Object.keys(EQUIPMENT_TABLE)) {
          const items = EQUIPMENT_TABLE[slot];
          const found = disc[slot] || [];
          const icon = SLOT_ICONS[slot] || '';
          const name = SLOT_NAMES[slot] || slot;

          const headerT = this.add.text(leftX, cy, `${icon} ${name} (${found.length}/${items.length})`, {
            fontSize: '13px', fontFamily: 'monospace', color: '#AABBDD', stroke: '#000', strokeThickness: 1
          }).setDepth(303);
          contentItems.push(headerT);
          cy += 18;

          let itemLine = '';
          for (const item of items) {
            if (found.includes(item.id)) {
              const isEquipped = currentSlots[slot] === item.id;
              itemLine += `${isEquipped ? '‚òÖ' : ''}${item.icon}${item.name}  `;
            } else {
              itemLine += '???  ';
            }
          }
          const itemT = this.add.text(leftX + 8, cy, itemLine.trim(), {
            fontSize: '11px', fontFamily: 'monospace', color: '#8899AA', wordWrap: { width: textW - 16 }
          }).setDepth(303);
          contentItems.push(itemT);
          cy += Math.max(20, itemT.height + 6);
          if (cy > contentY + contentH - 10) break;
        }

        // Total count
        let totalFound = 0, totalAll = 0;
        for (const slot of Object.keys(EQUIPMENT_TABLE)) {
          totalAll += EQUIPMENT_TABLE[slot].length;
          totalFound += (disc[slot] || []).length;
        }
        if (cy < contentY + contentH - 20) {
          const sumT = this.add.text(W/2, cy + 8, `Ï†ÑÏ≤¥: ${totalFound} / ${totalAll} Î∞úÍ≤¨`, {
            fontSize: '12px', fontFamily: 'monospace', color: '#FFD700', stroke: '#000', strokeThickness: 1
          }).setOrigin(0.5).setDepth(303);
          contentItems.push(sumT);
        }
      } else if (activeTab === 'quests') {
        const rec = RecordManager.load();
        const totalCompleted = rec.totalQuestsCompleted || 0;

        // Show all quests with status
        const headerT = this.add.text(W/2, cy, 'ÌÄòÏä§Ìä∏ Î™©Î°ù', {
          fontSize: '14px', fontFamily: 'monospace', color: '#FFD700', stroke: '#000', strokeThickness: 2
        }).setOrigin(0.5).setDepth(303);
        contentItems.push(headerT);
        cy += 26;

        for (let i = 0; i < QUESTS.length; i++) {
          const q = QUESTS[i];
          const icon = i < totalCompleted ? '‚úÖ' : (i === totalCompleted ? '‚ñ∂' : '‚ñ°');
          const color = i < totalCompleted ? '#88DDAA' : (i === totalCompleted ? '#FFFFFF' : '#556677');
          const line = `${icon} ${q.name}  ${q.desc}`;
          const t = this.add.text(leftX, cy, line, {
            fontSize: '11px', fontFamily: 'monospace', color, wordWrap: { width: textW }
          }).setDepth(303);
          contentItems.push(t);
          cy += 20;
          if (cy > contentY + contentH - 40) break;
        }

        // Summary
        cy = Math.max(cy, contentY + contentH - 30);
        const sumT = this.add.text(W/2, cy, `Ï†ÑÏ≤¥ ÌÄòÏä§Ìä∏ ÏôÑÎ£å ÎàÑÍ≥Ñ: ${totalCompleted}Ìöå`, {
          fontSize: '12px', fontFamily: 'monospace', color: '#AABB88', stroke: '#000', strokeThickness: 1
        }).setOrigin(0.5).setDepth(303);
        contentItems.push(sumT);
      } else if (activeTab === 'runhistory') {
        // ‚ïê‚ïê‚ïê üìú Îü∞ Í∏∞Î°ù ÌÉ≠ ‚ïê‚ïê‚ïê
        const rhm = new RunHistoryManager();
        const runs = rhm.runs;
        const CLASS_ICONS = {};
        Object.entries(PLAYER_CLASSES).forEach(([k,v]) => { CLASS_ICONS[k] = v.icon + ' ' + v.name; });
        const DIFF_NAMES = { normal: 'ÏùºÎ∞ò', hard: 'ÌïòÎìú', hell: 'ÏßÄÏò•' };
        const GRADE_ICONS = { common: '‚¨ú', rare: 'üü¶', epic: 'üü™', legendary: 'üü®', unique: 'üüß' };

        // üåü Î≤†Ïä§Ìä∏ Îü∞ ÌïòÏù¥ÎùºÏù¥Ìä∏
        if (runs.length > 0) {
          const best = rhm.getBest();
          const bestHeaderT = this.add.text(W/2, cy, 'üåü ÎÇ¥ Î≤†Ïä§Ìä∏ Îü∞', {
            fontSize: '13px', fontFamily: 'monospace', color: '#FFD700', stroke: '#000', strokeThickness: 2, fontStyle: 'bold'
          }).setOrigin(0.5).setDepth(303);
          contentItems.push(bestHeaderT);
          cy += 20;

          const bestCards = [
            { label: '‚è±Ô∏èÏµúÏû•ÏÉùÏ°¥', run: best.longestSurvival, val: RunHistoryManager.formatTime(best.longestSurvival.survivalTime) },
            { label: '‚öîÔ∏èÏµúÎã§ÌÇ¨', run: best.mostKills, val: best.mostKills.kills + 'ÌÇ¨' },
            { label: '‚≠êÏµúÍ≥†Î†àÎ≤®', run: best.highestLevel, val: 'Lv.' + best.highestLevel.level },
          ];
          const cardW2 = (pw - 40) / 3;
          bestCards.forEach((bc, ci) => {
            const bx = px + 15 + ci * (cardW2 + 5);
            const bg2 = this.add.graphics().setDepth(302);
            bg2.fillStyle(0x1A2244, 0.9); bg2.fillRoundedRect(bx, cy, cardW2, 36, 4);
            bg2.lineStyle(1, 0xFFD700, 0.3); bg2.strokeRoundedRect(bx, cy, cardW2, 36, 4);
            contentItems.push(bg2);
            const t1 = this.add.text(bx + cardW2/2, cy + 10, bc.label, {
              fontSize: '9px', fontFamily: 'monospace', color: '#AABBCC', stroke: '#000', strokeThickness: 1
            }).setOrigin(0.5).setDepth(303);
            contentItems.push(t1);
            const t2 = this.add.text(bx + cardW2/2, cy + 26, bc.val, {
              fontSize: '10px', fontFamily: 'monospace', color: '#FFFFFF', stroke: '#000', strokeThickness: 1, fontStyle: 'bold'
            }).setOrigin(0.5).setDepth(303);
            contentItems.push(t2);
          });
          cy += 44;
        }

        // Îü∞ Î™©Î°ù
        const listHeaderT = this.add.text(W/2, cy, `üìú Îü∞ Í∏∞Î°ù (ÏµúÍ∑º ${runs.length}Ìöå)`, {
          fontSize: '12px', fontFamily: 'monospace', color: '#AADDFF', stroke: '#000', strokeThickness: 1
        }).setOrigin(0.5).setDepth(303);
        contentItems.push(listHeaderT);
        cy += 20;

        if (runs.length === 0) {
          const emptyT = this.add.text(W/2, cy + 30, 'ÏïÑÏßÅ Í∏∞Î°ùÏù¥ ÏóÜÏäµÎãàÎã§\nÍ≤åÏûÑÏùÑ ÌîåÎ†àÏù¥Ìï¥Î≥¥ÏÑ∏Ïöî!', {
            fontSize: '12px', fontFamily: 'monospace', color: '#556677', align: 'center'
          }).setOrigin(0.5).setDepth(303);
          contentItems.push(emptyT);
        }

        // Scrollable run entries
        let expandedIdx = -1;
        const renderRuns = () => {
          // Clear only run items (keep headers)
          const runItemStart = contentItems.length;
          let ry = cy;
          runs.forEach((run, idx) => {
            if (ry > contentY + contentH - 20) return;
            const isExpanded = expandedIdx === idx;
            const classLabel = CLASS_ICONS[run.playerClass] || run.playerClass;
            const diffLabel = DIFF_NAMES[run.difficulty] || run.difficulty;
            const timeStr = RunHistoryManager.formatTime(run.survivalTime);
            const resultIcon = run.isWin ? '‚úÖ' : '‚ùå';
            const resultStr = run.isWin ? 'ÌÅ¥Î¶¨Ïñ¥ üèÜ' : 'Ïã§Ìå®';

            // Run card background
            const cardH2 = isExpanded ? 80 : 36;
            const rbg = this.add.graphics().setDepth(302);
            rbg.fillStyle(run.isWin ? 0x1A2A1A : 0x1A1A2A, 0.9);
            rbg.fillRoundedRect(leftX, ry, textW, cardH2, 4);
            rbg.lineStyle(1, run.isWin ? 0xFFD700 : 0x444466, 0.5);
            rbg.strokeRoundedRect(leftX, ry, textW, cardH2, 4);
            contentItems.push(rbg);

            // Main line
            const mainLine = `#${idx+1} ${classLabel} | ${diffLabel} | ${timeStr}`;
            const mt = this.add.text(leftX + 6, ry + 4, mainLine, {
              fontSize: '10px', fontFamily: 'monospace', color: '#DDDDEE', stroke: '#000', strokeThickness: 1
            }).setDepth(303);
            contentItems.push(mt);

            // Stats line
            const statsLine2 = `ÌÇ¨ ${run.kills} | Lv.${run.level} | ÏΩ§Î≥¥ ${run.maxCombo} | ${resultIcon} ${resultStr}`;
            const st = this.add.text(leftX + 6, ry + 18, statsLine2, {
              fontSize: '9px', fontFamily: 'monospace', color: '#8899AA', stroke: '#000', strokeThickness: 1
            }).setDepth(303);
            contentItems.push(st);

            // Expanded details
            if (isExpanded) {
              // Equipment
              const eqParts = [];
              for (const [slot, item] of Object.entries(run.equippedItems || {})) {
                if (item) eqParts.push((GRADE_ICONS[item.grade] || '') + (SLOT_ICONS[slot] || slot));
              }
              const eqStr = eqParts.length > 0 ? 'Ïû•ÎπÑ: ' + eqParts.join(' ') : 'Ïû•ÎπÑ: ÏóÜÏùå';

              // Synergies
              const synStr = (run.synergiesActivated || []).length > 0
                ? 'ÏãúÎÑàÏßÄ: ' + run.synergiesActivated.map(s => { const found = typeof SKILL_SYNERGIES !== 'undefined' ? SKILL_SYNERGIES.find(ss => ss.id === s) : null; return found ? found.name : s; }).join(', ')
                : '';

              // Top upgrades
              const upCounts = {};
              (run.upgrades || []).forEach(k => { upCounts[k] = (upCounts[k] || 0) + 1; });
              const topUp = Object.entries(upCounts).sort((a,b) => b[1] - a[1]).slice(0, 5);
              const upStr = topUp.map(([k,c]) => { const u = UPGRADES[k]; return u ? `${u.icon}${c > 1 ? 'x'+c : ''}` : k; }).join(' ');

              let detailStr = eqStr;
              if (synStr) detailStr += '\n' + synStr;
              if (upStr) detailStr += '\nÎπåÎìú: ' + upStr;

              const dt2 = this.add.text(leftX + 6, ry + 32, detailStr, {
                fontSize: '9px', fontFamily: 'monospace', color: '#7788AA', stroke: '#000', strokeThickness: 1,
                wordWrap: { width: textW - 12 }, lineSpacing: 3
              }).setDepth(303);
              contentItems.push(dt2);
            }

            // Click to expand/collapse
            const hitArea = this.add.rectangle(leftX + textW/2, ry + cardH2/2, textW, cardH2)
              .setDepth(304).setOrigin(0.5).setInteractive({ useHandCursor: true }).setAlpha(0.001);
            hitArea.on('pointerdown', () => {
              expandedIdx = expandedIdx === idx ? -1 : idx;
              // Re-render content
              clearContent();
              renderContent();
            });
            contentItems.push(hitArea);

            ry += cardH2 + 4;
          });
        };
        renderRuns();
      }
    };

    // Close button
    const closeBtn = this.add.text(W/2, py + ph - 28, '‚úï Îã´Í∏∞', {
      fontSize: '16px', fontFamily: 'monospace', color: '#aabbcc',
      stroke: '#000', strokeThickness: 2, backgroundColor: '#2A2E3E',
      padding: { x: 20, y: 8 }
    }).setOrigin(0.5).setDepth(303).setInteractive({ useHandCursor: true });
    container.push(closeBtn);

    const cleanup = () => { clearContent(); tabBtns.forEach(t => t.destroy()); container.forEach(el => el.destroy()); };
    closeBtn.on('pointerdown', cleanup);
    ovHit.on('pointerdown', cleanup);

    renderTabs();
    renderContent();
  }

  _showStatsPopup() {
    const W = this.scale.width, H = this.scale.height;
    const rec = RecordManager.load();
    const container = [];

    // Overlay
    const ov = this.add.graphics().setDepth(200);
    ov.fillStyle(0x000000, 0.7); ov.fillRect(0, 0, W, H);
    container.push(ov);
    const ovHit = this.add.rectangle(W/2, H/2, W, H).setDepth(200).setOrigin(0.5).setInteractive().setAlpha(0.001);
    container.push(ovHit);

    // Panel
    const pw = Math.min(320, W - 40), ph = 380;
    const panel = this.add.graphics().setDepth(201);
    panel.fillStyle(0x1A1E2E, 0.95);
    panel.fillRoundedRect(W/2 - pw/2, H/2 - ph/2, pw, ph, 16);
    panel.lineStyle(2, 0x4466aa, 0.6);
    panel.strokeRoundedRect(W/2 - pw/2, H/2 - ph/2, pw, ph, 16);
    container.push(panel);

    // Title
    const title = this.add.text(W/2, H/2 - ph/2 + 30, 'üìä ÎÇòÏùò Í∏∞Î°ù', {
      fontSize: '22px', fontFamily: 'monospace', color: '#e0e8ff',
      stroke: '#000', strokeThickness: 3, fontStyle: 'bold'
    }).setOrigin(0.5).setDepth(202);
    container.push(title);

    // Stats content
    const bestTime = RecordManager.formatTime(rec.bestSurvivalTime);
    const totalTime = RecordManager.formatTime(rec.totalPlayTime);
    const totalAch = ACHIEVEMENTS ? ACHIEVEMENTS.length : 10;
    const lines = [
      `‚è±Ô∏è ÏµúÏû• ÏÉùÏ°¥:      ${bestTime}`,
      `‚ò†Ô∏è ÏµúÎã§ ÌÇ¨:        ${rec.bestKills.toLocaleString()}ÎßàÎ¶¨`,
      `‚≠ê ÏµúÍ≥† Î†àÎ≤®:       ${rec.bestLevel}`,
      `üî• ÏµúÎåÄ ÏΩ§Î≥¥:       ${rec.bestCombo}ÌÇ¨`,
      `‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ`,
      `üéÆ Ï¥ù ÌîåÎ†àÏù¥:       ${rec.totalPlays}Ìöå`,
      `üíÄ ÎàÑÏ†Å ÌÇ¨:         ${rec.totalKills.toLocaleString()}ÎßàÎ¶¨`,
      `‚è∞ Ï¥ù ÌîåÎ†àÏù¥ ÏãúÍ∞Ñ:  ${totalTime}`,
      `üèÜ 60Î∂Ñ ÌÅ¥Î¶¨Ïñ¥:     ${rec.wins}Ìöå`,
      (rec.ngPlusClears || 0) > 0 ? `‚≠ê NG+ Îã¨ÏÑ±:        ${rec.ngPlusClears}Ìöå` : null,
      rec.longestEndlessSurvival > 0 ? `üî• ÏµúÏû•ÏÉùÏ°¥: ${Math.floor(rec.longestEndlessSurvival/60)}Î∂Ñ ${Math.floor(rec.longestEndlessSurvival%60)}Ï¥à` : null,
      `ü•á Îã¨ÏÑ± ÏÑ±Ï∑®:       ${rec.achievementsUnlocked} / ${totalAch}`,
    ];
    const statsText = this.add.text(W/2, H/2 - 20, lines.filter(Boolean).join('\n'), {
      fontSize: '13px', fontFamily: 'monospace', color: '#CCDDEE',
      stroke: '#000', strokeThickness: 1, lineSpacing: 5
    }).setOrigin(0.5).setDepth(202);
    container.push(statsText);

    // Close button
    const closeBtn = this.add.text(W/2, H/2 + ph/2 - 40, '‚úï Îã´Í∏∞', {
      fontSize: '16px', fontFamily: 'monospace', color: '#aabbcc',
      stroke: '#000', strokeThickness: 2, backgroundColor: '#2A2E3E',
      padding: { x: 20, y: 8 }
    }).setOrigin(0.5).setDepth(202).setInteractive({ useHandCursor: true });
    container.push(closeBtn);

    const cleanup = () => { container.forEach(el => el.destroy()); };
    closeBtn.on('pointerdown', cleanup);
    ovHit.on('pointerdown', cleanup);
  }

  _createTitleAnimalTextures() {
    // ÌÜ†ÎÅº (titleÏö©)
    if (!this.textures.exists('title_rabbit')) {
      const g = this.add.graphics();
      g.fillStyle(0xFFEEDD); g.fillEllipse(12, 14, 16, 12); // body
      g.fillStyle(0xFFEEDD); g.fillEllipse(12, 6, 6, 10); // head
      g.fillStyle(0xFFDDCC); g.fillEllipse(10, 0, 3, 7); g.fillEllipse(14, 0, 3, 7); // ears
      g.fillStyle(0x332222); g.fillCircle(10, 5, 1.5); g.fillCircle(14, 5, 1.5); // eyes
      g.generateTexture('title_rabbit', 24, 24); g.destroy();
    }
    // ÏÇ¨Ïä¥ (titleÏö©)
    if (!this.textures.exists('title_deer')) {
      const g = this.add.graphics();
      g.fillStyle(0xC4A46C); g.fillEllipse(14, 18, 20, 14); // body
      g.fillStyle(0xC4A46C); g.fillEllipse(14, 8, 10, 10); // head
      g.fillStyle(0x8B7355); g.fillEllipse(8, 2, 2, 8); g.fillEllipse(20, 2, 2, 8); // antlers
      g.fillStyle(0x332222); g.fillCircle(11, 7, 1.5); g.fillCircle(17, 7, 1.5); // eyes
      g.fillStyle(0xC4A46C);
      // legs
      g.fillRect(8, 24, 3, 8); g.fillRect(18, 24, 3, 8);
      g.generateTexture('title_deer', 28, 32); g.destroy();
    }
  }
  
  _spawnTitleAnimal(initial) {
    const W = this.scale.width;
    const H = this.scale.height;
    const isRabbit = Math.random() < 0.5;
    const goRight = Math.random() < 0.5;
    const speed = 40 + Math.random() * 40; // 40~80 px/s
    const yPos = H * 0.65 + Math.random() * (H * 0.2); // on the snowy ground area
    const startX = goRight ? -40 : W + 40;
    
    const sprite = this.add.image(
      initial ? Math.random() * W : startX,
      yPos,
      isRabbit ? 'title_rabbit' : 'title_deer'
    ).setDepth(5).setFlipX(!goRight).setScale(isRabbit ? 1.2 : 1.4);
    
    this.scrollAnimals.push({ sprite, speed: goRight ? speed : -speed, goRight });
  }
  
  update(time, delta) {
    this.elapsed += delta * 0.001;
    const dt = delta * 0.001;
    const W = this.scale.width;
    const H = this.scale.height;
    
    // ‚ïê‚ïê‚ïê ÎèôÎ¨º Ïä§ÌÅ¨Î°§ ÏóÖÎç∞Ïù¥Ìä∏ ‚ïê‚ïê‚ïê
    this._animalSpawnTimer -= dt;
    if (this._animalSpawnTimer <= 0) {
      if (this.scrollAnimals.length < 6) this._spawnTitleAnimal(false);
      this._animalSpawnTimer = 2 + Math.random() * 2; // 2~4Ï¥àÎßàÎã§
    }
    for (let i = this.scrollAnimals.length - 1; i >= 0; i--) {
      const a = this.scrollAnimals[i];
      a.sprite.x += a.speed * dt;
      // ÏÇ¥Ïßù ÏúÑÏïÑÎûò ÌùîÎì§Î¶º
      a.sprite.y += Math.sin(time * 0.002 + i * 1.5) * 0.3;
      // ÌôîÎ©¥ Î∞ñÏúºÎ°ú ÎÇòÍ∞ÄÎ©¥ Ï†úÍ±∞
      if ((a.speed > 0 && a.sprite.x > W + 60) || (a.speed < 0 && a.sprite.x < -60)) {
        a.sprite.destroy();
        this.scrollAnimals.splice(i, 1);
      }
    }
    
    // ‚ïê‚ïê‚ïê Snow particles ‚ïê‚ïê‚ïê
    this.snowGfx.clear();
    this.snowParticles.forEach(p => {
      p.x += p.speedX;
      p.y += p.speedY;
      p.wobble += 0.02 * (p.wobbleSpeed || 1);
      p.x += Math.sin(p.wobble) * (p.wobbleAmp || 0.3);
      if (p.y > H + 10) { p.y = -10; p.x = Math.random() * W; p.size = 0.5 + Math.random() * 4; }
      if (p.x < -10) { p.x = W + 10; }
      const _sAlpha = p.alpha * (0.6 + Math.sin(this.elapsed * 0.8 + p.wobble) * 0.4);
      this.snowGfx.fillStyle(0xffffff, Math.max(0.05, _sAlpha));
      this.snowGfx.fillCircle(p.x, p.y, p.size);
    });
  }
}
// ‚ïê‚ïê‚ïê END TITLE SCENE ‚ïê‚ïê‚ïê

class BootScene extends Phaser.Scene {
  constructor() { super('Boot'); }
  
  create() {
    // ‚ïê‚ïê‚ïê Loading Screen ‚ïê‚ïê‚ïê
    const W = this.scale.width, H = this.scale.height;
    this.cameras.main.setBackgroundColor('#0A0E1A');
    const snowIcon = this.add.text(W/2, H*0.35, '‚ùÑÔ∏è', { fontSize: '64px' }).setOrigin(0.5);
    this.tweens.add({ targets: snowIcon, scaleX: 1.2, scaleY: 1.2, duration: 800, yoyo: true, repeat: -1, ease: 'Sine.InOut' });
    const loadTitle = this.add.text(W/2, H*0.50, 'ÌôîÏù¥Ìä∏ÏïÑÏõÉ ÏÑúÎ∞îÏù¥Î≤å', {
      fontSize: '22px', fontFamily: 'monospace', color: '#e0e8ff', stroke: '#000', strokeThickness: 3
    }).setOrigin(0.5);
    const barW = Math.min(260, W*0.6), barH = 14, barX = W/2-barW/2, barY = H*0.62;
    const barBg = this.add.graphics();
    barBg.fillStyle(0x1a1e2e, 1); barBg.fillRoundedRect(barX, barY, barW, barH, 7);
    const barFill = this.add.graphics();
    const loadPct = this.add.text(W/2, barY + barH + 14, 'Î°úÎî© Ï§ë... 0%', {
      fontSize: '12px', fontFamily: 'monospace', color: '#667788'
    }).setOrigin(0.5);

    // Simulate loading progress during texture creation
    const textureMethods = [
      'createPlayerTexture', 'createPlayerBackTexture', 'createPlayerAttackTexture',
      'createRabbitTexture', 'createRabbitBackTexture', 'createDeerTexture', 'createDeerBackTexture',
      'createPenguinTexture', 'createPenguinBackTexture', 'createSealTexture', 'createSealBackTexture',
      'createWolfTexture', 'createWolfBackTexture', 'createBearTexture', 'createBearBackTexture',
      'createIceGolemTexture', 'createSnowLeopardTexture',
      'createIceHunterTexture', 'createSplittingSlimeTexture', 'createBlizzardShamanTexture',
      'createNPCTextures', 'createNPCBackTextures',
      'createTreeTexture', 'createRockTexture', 'createDropTextures', 'createParticleTextures', 'createCrateTexture'
    ];
    let idx = 0;
    const total = textureMethods.length;
    const processNext = () => {
      if (idx < total) {
        this[textureMethods[idx]]();
        idx++;
        const pct = Math.round((idx / total) * 100);
        barFill.clear();
        barFill.fillStyle(0x2266cc, 1);
        barFill.fillRoundedRect(barX, barY, barW * (idx/total), barH, 7);
        barFill.fillStyle(0x4488ff, 0.5);
        barFill.fillRoundedRect(barX, barY, barW * (idx/total), barH/2, { tl: 7, tr: 7, bl: 0, br: 0 });
        loadPct.setText(`Î°úÎî© Ï§ë... ${pct}%`);
        this.time.delayedCall(16, processNext);
      } else {
        // All textures loaded, proceed
        const loadSave = this.scene.settings.data?.loadSave || false;
        const playerClass = this.scene.settings.data?.playerClass || null;
        const difficulty = this.scene.settings.data?.difficulty || null;
        const dailyChallenge = this.scene.settings.data?.dailyChallenge || null;
        const endlessMode = this.scene.settings.data?.endlessMode || false;
        const ngPlus = this.scene.settings.data?.ngPlus || false;
        const bossRush = this.scene.settings.data?.bossRush || false;
        const speedrun = this.scene.settings.data?.speedrun || false;
        const handicap = this.scene.settings.data?.handicap || 'none';
        this.time.delayedCall(200, () => {
          this.scene.start('Game', { loadSave, playerClass, difficulty, dailyChallenge, endlessMode, ngPlus, bossRush, speedrun, handicap });
        });
      }
    };

    initAudio();
    processNext();
  }

  createPlayerTexture() {
    const g = this.add.graphics();
    const s = 40;
    g.fillStyle(0xCC2222, 1);
    g.fillRect(12, 2, 16, 8);
    g.fillRect(11, 5, 18, 4);
    g.fillStyle(0xFFDDBB, 1);
    g.fillRect(13, 10, 14, 9);
    g.fillStyle(0x222222, 1);
    g.fillRect(16, 13, 3, 3);
    g.fillRect(22, 13, 3, 3);
    g.fillStyle(0xFFFFFF, 1);
    g.fillRect(17, 13, 1, 1);
    g.fillRect(23, 13, 1, 1);
    g.fillStyle(0xDD8866, 1);
    g.fillRect(17, 17, 6, 1);
    g.fillStyle(0x2299CC, 1);
    g.fillRect(11, 19, 18, 12);
    g.fillStyle(0xEEDDCC, 1);
    g.fillRect(11, 19, 18, 3);
    g.fillRect(11, 19, 3, 12);
    g.fillRect(26, 19, 3, 12);
    g.fillStyle(0x2299CC, 1);
    g.fillRect(7, 20, 4, 9);
    g.fillRect(29, 20, 4, 9);
    g.fillStyle(0x884422, 1);
    g.fillRect(7, 29, 4, 3);
    g.fillRect(29, 29, 4, 3);
    g.fillStyle(0x555566, 1);
    g.fillRect(13, 31, 6, 6);
    g.fillRect(21, 31, 6, 6);
    g.fillStyle(0x664422, 1);
    g.fillRect(12, 36, 7, 4);
    g.fillRect(21, 36, 7, 4);
    g.generateTexture('player', s, s);
    g.destroy();
  }

  createPlayerBackTexture() {
    const g = this.add.graphics();
    const s = 40;
    // Î™®Ïûê (Îí∑Î™®Ïäµ)
    g.fillStyle(0xCC2222, 1);
    g.fillRect(12, 2, 16, 8);
    g.fillRect(11, 5, 18, 4);
    // Îí§ÌÜµÏàò (Î®∏Î¶¨Ïπ¥ÎùΩ)
    g.fillStyle(0x553322, 1);
    g.fillRect(13, 10, 14, 9);
    g.fillStyle(0x442211, 1);
    g.fillRect(14, 11, 12, 7);
    // ÏΩîÌä∏ Îí∑Î©¥
    g.fillStyle(0x2299CC, 1);
    g.fillRect(11, 19, 18, 12);
    // ÏΩîÌä∏ Îí§Ï™Ω ÎùºÏù∏
    g.fillStyle(0x1188BB, 1);
    g.fillRect(19, 19, 2, 12);
    // Î∞∞ÎÇ≠
    g.fillStyle(0x885522, 1);
    g.fillRect(13, 20, 14, 10);
    g.fillStyle(0x774411, 1);
    g.fillRect(14, 21, 12, 8);
    g.fillStyle(0xAA7733, 1);
    g.fillRect(15, 22, 4, 3);
    // Î∞∞ÎÇ≠ ÎÅà
    g.fillStyle(0x664411, 1);
    g.fillRect(11, 20, 2, 8);
    g.fillRect(27, 20, 2, 8);
    // Ìåî
    g.fillStyle(0x2299CC, 1);
    g.fillRect(7, 20, 4, 9);
    g.fillRect(29, 20, 4, 9);
    g.fillStyle(0x884422, 1);
    g.fillRect(7, 29, 4, 3);
    g.fillRect(29, 29, 4, 3);
    // Îã§Î¶¨
    g.fillStyle(0x555566, 1);
    g.fillRect(13, 31, 6, 6);
    g.fillRect(21, 31, 6, 6);
    g.fillStyle(0x664422, 1);
    g.fillRect(12, 36, 7, 4);
    g.fillRect(21, 36, 7, 4);
    g.generateTexture('player_back', s, s);
    g.destroy();
  }

  createPlayerAttackTexture() {
    const g = this.add.graphics();
    const s = 44;
    g.fillStyle(0xCC2222, 1);
    g.fillRect(14, 2, 16, 8);
    g.fillRect(13, 5, 18, 4);
    g.fillStyle(0xFFDDBB, 1);
    g.fillRect(15, 10, 14, 9);
    g.fillStyle(0x222222, 1);
    g.fillRect(18, 13, 3, 3);
    g.fillRect(24, 13, 3, 3);
    g.fillStyle(0xDD8866, 1);
    g.fillRect(19, 17, 6, 1);
    g.fillStyle(0x2299CC, 1);
    g.fillRect(13, 19, 18, 12);
    g.fillStyle(0xEEDDCC, 1);
    g.fillRect(13, 19, 18, 3);
    g.fillStyle(0x2299CC, 1);
    g.fillRect(31, 18, 10, 4);
    g.fillRect(10, 20, 4, 9);
    g.fillStyle(0xAAAAAA, 1);
    g.fillRect(38, 12, 3, 10);
    g.fillStyle(0x884422, 1);
    g.fillRect(37, 21, 5, 3);
    g.fillStyle(0x555566, 1);
    g.fillRect(15, 31, 6, 6);
    g.fillRect(23, 31, 6, 6);
    g.fillStyle(0x664422, 1);
    g.fillRect(14, 36, 7, 4);
    g.fillRect(23, 36, 7, 4);
    g.generateTexture('player_attack', s, s);
    g.destroy();
  }

  createRabbitTexture() {
    const g = this.add.graphics();
    const sz = 28;
    g.fillStyle(0xFFEEDD, 1);
    g.fillRoundedRect(7, 12, 14, 12, 5);
    g.fillRoundedRect(9, 6, 10, 8, 4);
    g.fillStyle(0xEEDDBB, 1);
    g.fillRect(10, 0, 3, 8);
    g.fillRect(15, 0, 3, 8);
    g.fillStyle(0xFFAAAA, 1);
    g.fillRect(11, 1, 1, 5);
    g.fillRect(16, 1, 1, 5);
    g.fillStyle(0x000000, 1);
    g.fillCircle(12, 9, 1.5);
    g.fillCircle(16, 9, 1.5);
    g.fillStyle(0xFFFFFF, 1);
    g.fillRect(12, 8, 1, 1);
    g.fillRect(16, 8, 1, 1);
    g.fillStyle(0xFF8899, 1);
    g.fillRect(13, 11, 2, 2);
    g.fillStyle(0xFFFFFF, 1);
    g.fillCircle(7, 18, 3);
    g.fillStyle(0xEEDDBB, 1);
    g.fillRect(8, 23, 4, 3);
    g.fillRect(16, 23, 4, 3);
    g.generateTexture('rabbit', sz, sz);
    g.destroy();
  }

  createDeerTexture() {
    const g = this.add.graphics();
    const sz = 32;
    g.fillStyle(0xC4A46C, 1);
    g.fillRoundedRect(7, 14, 18, 12, 4);
    g.fillRoundedRect(9, 6, 14, 10, 4);
    g.fillStyle(0x8B6914, 1);
    g.fillRect(11, 1, 2, 6);
    g.fillRect(19, 1, 2, 6);
    g.fillRect(9, 2, 2, 3);
    g.fillRect(21, 2, 2, 3);
    g.fillStyle(0x000000, 1);
    g.fillCircle(13, 9, 1.5);
    g.fillCircle(19, 9, 1.5);
    g.fillStyle(0x333333, 1);
    g.fillRect(15, 12, 2, 2);
    g.fillStyle(0xE8D8B8, 1);
    g.fillRect(11, 22, 10, 3);
    g.fillStyle(0xA08050, 1);
    g.fillRect(10, 25, 3, 6);
    g.fillRect(19, 25, 3, 6);
    g.fillStyle(0x444444, 1);
    g.fillRect(10, 30, 3, 2);
    g.fillRect(19, 30, 3, 2);
    g.generateTexture('deer', sz, sz);
    g.destroy();
  }

  createPenguinTexture() {
    const g = this.add.graphics();
    const sz = 28;
    g.fillStyle(0x222222, 1);
    g.fillRoundedRect(7, 4, 14, 18, 5);
    g.fillStyle(0xFFFFFF, 1);
    g.fillRoundedRect(9, 8, 10, 12, 4);
    g.fillCircle(11, 6, 2.5);
    g.fillCircle(17, 6, 2.5);
    g.fillStyle(0x000000, 1);
    g.fillCircle(11, 6, 1);
    g.fillCircle(17, 6, 1);
    g.fillStyle(0xFF8800, 1);
    g.fillRect(12, 9, 4, 3);
    g.fillRect(8, 22, 5, 3);
    g.fillRect(15, 22, 5, 3);
    g.fillStyle(0x333333, 1);
    g.fillRect(4, 9, 3, 8);
    g.fillRect(21, 9, 3, 8);
    g.generateTexture('penguin', sz, sz);
    g.destroy();
  }

  createSealTexture() {
    const g = this.add.graphics();
    const sz = 32;
    g.fillStyle(0x7B8D9E, 1);
    g.fillEllipse(16, 14, 28, 16);
    g.fillStyle(0x8B9DAE, 1);
    g.fillCircle(7, 12, 7);
    g.fillStyle(0x000000, 1);
    g.fillCircle(5, 10, 1.5);
    g.fillStyle(0x333333, 1);
    g.fillCircle(3, 13, 1.5);
    g.fillStyle(0x6B7D8E, 1);
    g.fillEllipse(26, 16, 8, 5);
    g.fillStyle(0x9BAABB, 0.5);
    g.fillEllipse(16, 16, 20, 8);
    g.generateTexture('seal', sz, sz);
    g.destroy();
  }

  createWolfTexture() {
    const g = this.add.graphics();
    const sz = 32;
    g.fillStyle(0x555566, 1);
    g.fillRoundedRect(6, 12, 20, 12, 4);
    g.fillStyle(0x666677, 1);
    g.fillRoundedRect(3, 5, 14, 10, 4);
    g.fillStyle(0x777788, 1);
    g.fillRect(1, 8, 5, 5);
    g.fillStyle(0x444455, 1);
    g.fillTriangle(5, 0, 3, 6, 9, 6);
    g.fillTriangle(14, 0, 11, 6, 17, 6);
    g.fillStyle(0xFF3333, 1);
    g.fillCircle(7, 8, 2);
    g.fillCircle(13, 8, 2);
    g.fillStyle(0xFFFF00, 1);
    g.fillCircle(7, 7, 0.8);
    g.fillCircle(13, 7, 0.8);
    g.fillStyle(0xFFFFFF, 1);
    g.fillRect(2, 12, 2, 3);
    g.fillRect(5, 12, 2, 3);
    g.fillStyle(0x222222, 1);
    g.fillRect(1, 9, 2, 2);
    g.fillStyle(0x444455, 1);
    g.fillRect(26, 10, 5, 3);
    g.fillRect(29, 8, 3, 3);
    g.fillRect(9, 23, 3, 6);
    g.fillRect(14, 23, 3, 6);
    g.fillRect(21, 23, 3, 6);
    g.fillStyle(0x333344, 1);
    g.fillRect(8, 28, 4, 3);
    g.fillRect(13, 28, 4, 3);
    g.fillRect(20, 28, 4, 3);
    g.generateTexture('wolf', sz, sz);
    g.destroy();
  }

  createBearTexture() {
    const g = this.add.graphics();
    const sz = 44;
    g.fillStyle(0xF0EEE8, 1);
    g.fillRoundedRect(6, 14, 32, 20, 10);
    g.fillStyle(0xF5F3EE, 1);
    g.fillCircle(22, 12, 12);
    g.fillStyle(0xE0DDD5, 1);
    g.fillCircle(13, 3, 4);
    g.fillCircle(31, 3, 4);
    g.fillStyle(0xDDBBAA, 1);
    g.fillCircle(13, 3, 2);
    g.fillCircle(31, 3, 2);
    g.fillStyle(0x222222, 1);
    g.fillCircle(17, 11, 2);
    g.fillCircle(27, 11, 2);
    g.fillStyle(0x333333, 1);
    g.fillCircle(22, 16, 3);
    g.lineStyle(1, 0x666666, 0.5);
    g.lineBetween(22, 18, 19, 20);
    g.lineBetween(22, 18, 25, 20);
    g.fillStyle(0xE8E5DD, 1);
    g.fillRoundedRect(9, 32, 8, 10, 4);
    g.fillRoundedRect(27, 32, 8, 10, 4);
    g.fillStyle(0xDDDAD2, 1);
    g.fillRoundedRect(8, 38, 10, 5, 3);
    g.fillRoundedRect(26, 38, 10, 5, 3);
    g.fillStyle(0x888888, 1);
    for (let i = 0; i < 3; i++) {
      g.fillRect(9 + i*3, 42, 1, 2);
      g.fillRect(27 + i*3, 42, 1, 2);
    }
    g.generateTexture('bear', sz, sz);
    g.destroy();
  }

  createRabbitBackTexture() {
    const g = this.add.graphics();
    const sz = 28;
    // Î™∏ÌÜµ Îí∑Î©¥
    g.fillStyle(0xFFEEDD, 1);
    g.fillRoundedRect(7, 12, 14, 12, 5);
    g.fillRoundedRect(9, 6, 10, 8, 4);
    // Í∑Ä Îí∑Î©¥
    g.fillStyle(0xEEDDBB, 1);
    g.fillRect(10, 0, 3, 8);
    g.fillRect(15, 0, 3, 8);
    // Îàà ÏóÜÏùå - Îí§ÌÜµÏàò
    g.fillStyle(0xEEDDCC, 1);
    g.fillRoundedRect(10, 7, 8, 6, 3);
    // Íº¨Î¶¨ (ÏÜúÎ≠âÏπò)
    g.fillStyle(0xFFFFFF, 1);
    g.fillCircle(14, 24, 4);
    // Î∞ú
    g.fillStyle(0xEEDDBB, 1);
    g.fillRect(8, 23, 4, 3);
    g.fillRect(16, 23, 4, 3);
    g.generateTexture('rabbit_back', sz, sz);
    g.destroy();
  }

  createDeerBackTexture() {
    const g = this.add.graphics();
    const sz = 32;
    // Î™∏ÌÜµ Îí∑Î©¥
    g.fillStyle(0xC4A46C, 1);
    g.fillRoundedRect(7, 14, 18, 12, 4);
    g.fillRoundedRect(9, 6, 14, 10, 4);
    // Îøî
    g.fillStyle(0x8B6914, 1);
    g.fillRect(11, 1, 2, 6);
    g.fillRect(19, 1, 2, 6);
    g.fillRect(9, 2, 2, 3);
    g.fillRect(21, 2, 2, 3);
    // Îí§ÌÜµÏàò (Îàà ÏóÜÏùå)
    g.fillStyle(0xB89458, 1);
    g.fillRoundedRect(11, 8, 10, 6, 3);
    // Íº¨Î¶¨
    g.fillStyle(0xE8D8B8, 1);
    g.fillRect(14, 12, 4, 3);
    // Îã§Î¶¨
    g.fillStyle(0xA08050, 1);
    g.fillRect(10, 25, 3, 6);
    g.fillRect(19, 25, 3, 6);
    g.fillStyle(0x444444, 1);
    g.fillRect(10, 30, 3, 2);
    g.fillRect(19, 30, 3, 2);
    g.generateTexture('deer_back', sz, sz);
    g.destroy();
  }

  createPenguinBackTexture() {
    const g = this.add.graphics();
    const sz = 28;
    // Í≤ÄÏùÄ Îì±
    g.fillStyle(0x222222, 1);
    g.fillRoundedRect(7, 4, 14, 18, 5);
    // Î®∏Î¶¨ Îí∑Î©¥ (Í≤ÄÏùÄÏÉâ)
    g.fillStyle(0x1a1a1a, 1);
    g.fillRoundedRect(9, 2, 10, 8, 4);
    // ÎÇ†Í∞ú
    g.fillStyle(0x333333, 1);
    g.fillRect(4, 9, 3, 8);
    g.fillRect(21, 9, 3, 8);
    // Î∞ú
    g.fillStyle(0xFF8800, 1);
    g.fillRect(8, 22, 5, 3);
    g.fillRect(15, 22, 5, 3);
    g.generateTexture('penguin_back', sz, sz);
    g.destroy();
  }

  createSealBackTexture() {
    const g = this.add.graphics();
    const sz = 32;
    // Î™∏ÌÜµ Îí∑Î©¥
    g.fillStyle(0x7B8D9E, 1);
    g.fillEllipse(16, 14, 28, 16);
    // Î®∏Î¶¨ Îí∑Î©¥
    g.fillStyle(0x6B7D8E, 1);
    g.fillCircle(7, 12, 7);
    // Íº¨Î¶¨
    g.fillStyle(0x6B7D8E, 1);
    g.fillEllipse(26, 16, 8, 5);
    // Îì± Î¨¥Îä¨
    g.fillStyle(0x5B6D7E, 0.5);
    g.fillEllipse(16, 13, 18, 6);
    g.generateTexture('seal_back', sz, sz);
    g.destroy();
  }

  createWolfBackTexture() {
    const g = this.add.graphics();
    const sz = 32;
    // Î™∏ÌÜµ Îí∑Î©¥
    g.fillStyle(0x555566, 1);
    g.fillRoundedRect(6, 12, 20, 12, 4);
    // Î®∏Î¶¨ Îí∑Î©¥ (Îàà ÏóÜÏùå)
    g.fillStyle(0x666677, 1);
    g.fillRoundedRect(3, 5, 14, 10, 4);
    // Í∑Ä
    g.fillStyle(0x444455, 1);
    g.fillTriangle(5, 0, 3, 6, 9, 6);
    g.fillTriangle(14, 0, 11, 6, 17, 6);
    // Îí§ÌÜµÏàò ÌÑ∏
    g.fillStyle(0x777788, 1);
    g.fillRoundedRect(4, 6, 12, 7, 3);
    // Íº¨Î¶¨ (ÏúÑÎ°ú Ïò¨Î¶º)
    g.fillStyle(0x555566, 1);
    g.fillRect(26, 8, 4, 4);
    g.fillRect(28, 5, 3, 5);
    // Îã§Î¶¨
    g.fillStyle(0x444455, 1);
    g.fillRect(9, 23, 3, 6);
    g.fillRect(14, 23, 3, 6);
    g.fillRect(21, 23, 3, 6);
    g.fillStyle(0x333344, 1);
    g.fillRect(8, 28, 4, 3);
    g.fillRect(13, 28, 4, 3);
    g.fillRect(20, 28, 4, 3);
    g.generateTexture('wolf_back', sz, sz);
    g.destroy();
  }

  createBearBackTexture() {
    const g = this.add.graphics();
    const sz = 44;
    // Î™∏ÌÜµ Îí∑Î©¥
    g.fillStyle(0xF0EEE8, 1);
    g.fillRoundedRect(6, 14, 32, 20, 10);
    // Î®∏Î¶¨ Îí∑Î©¥
    g.fillStyle(0xF5F3EE, 1);
    g.fillCircle(22, 12, 12);
    // Í∑Ä
    g.fillStyle(0xE0DDD5, 1);
    g.fillCircle(13, 3, 4);
    g.fillCircle(31, 3, 4);
    g.fillStyle(0xDDBBAA, 1);
    g.fillCircle(13, 3, 2);
    g.fillCircle(31, 3, 2);
    // Îí§ÌÜµÏàò (Îàà ÏóÜÏùå)
    g.fillStyle(0xE8E5DD, 1);
    g.fillCircle(22, 12, 10);
    // Îì± Î¨¥Îä¨
    g.fillStyle(0xDDD8D0, 1);
    g.fillEllipse(22, 22, 24, 12);
    // Îã§Î¶¨
    g.fillStyle(0xE8E5DD, 1);
    g.fillRoundedRect(9, 32, 8, 10, 4);
    g.fillRoundedRect(27, 32, 8, 10, 4);
    g.fillStyle(0xDDDAD2, 1);
    g.fillRoundedRect(8, 38, 10, 5, 3);
    g.fillRoundedRect(26, 38, 10, 5, 3);
    g.generateTexture('bear_back', sz, sz);
    g.destroy();
  }

  createIceGolemTexture() {
    const g = this.add.graphics();
    const sz = 48;
    // Body - large gray-blue circle
    g.lineStyle(4, 0x6699BB, 1);
    g.fillStyle(0x88CCEE, 1);
    g.fillCircle(24, 24, 22);
    g.strokeCircle(24, 24, 22);
    // Inner ice cracks
    g.lineStyle(1, 0xAADDFF, 0.6);
    g.lineBetween(14, 16, 24, 24);
    g.lineBetween(24, 24, 34, 18);
    g.lineBetween(24, 24, 20, 34);
    // Eyes
    g.fillStyle(0x4477AA, 1);
    g.fillCircle(18, 20, 3);
    g.fillCircle(30, 20, 3);
    g.fillStyle(0xCCEEFF, 1);
    g.fillCircle(19, 19, 1);
    g.fillCircle(31, 19, 1);
    g.generateTexture('ice_golem', sz, sz);
    g.destroy();
  }

  createSnowLeopardTexture() {
    const g = this.add.graphics();
    const sz = 28;
    // Body - white circle
    g.fillStyle(0xF8F8FF, 1);
    g.fillCircle(14, 14, 12);
    // Spots (gray dots)
    g.fillStyle(0x999999, 1);
    g.fillCircle(10, 11, 2);
    g.fillCircle(18, 13, 2);
    g.fillCircle(14, 18, 2);
    // Eyes
    g.fillStyle(0x44AA44, 1);
    g.fillCircle(10, 10, 1.5);
    g.fillCircle(18, 10, 1.5);
    // Ears
    g.fillStyle(0xEEEEEE, 1);
    g.fillTriangle(7, 4, 10, 2, 12, 6);
    g.fillTriangle(16, 6, 18, 2, 21, 4);
    g.generateTexture('snow_leopard', sz, sz);
    g.destroy();
  }

  createIceHunterTexture() {
    const g = this.add.graphics(); const sz = 40;
    // Diamond body shape (blue)
    g.fillStyle(0x4488CC, 1);
    g.fillTriangle(20, 2, 38, 20, 20, 38);
    g.fillTriangle(20, 2, 2, 20, 20, 38);
    // Inner lighter diamond
    g.fillStyle(0x66AADD, 1);
    g.fillTriangle(20, 8, 32, 20, 20, 32);
    g.fillTriangle(20, 8, 8, 20, 20, 32);
    // Eyes
    g.fillStyle(0xCCEEFF, 1);
    g.fillCircle(15, 18, 2); g.fillCircle(25, 18, 2);
    g.fillStyle(0x112244, 1);
    g.fillCircle(15, 18, 1); g.fillCircle(25, 18, 1);
    g.generateTexture('ice_hunter', sz, sz); g.destroy();
  }

  createSplittingSlimeTexture() {
    const g = this.add.graphics(); const sz = 48;
    // Big green circle
    g.fillStyle(0x44CC44, 1);
    g.fillCircle(24, 26, 20);
    // Highlight
    g.fillStyle(0x88EE88, 0.6);
    g.fillCircle(18, 20, 8);
    // Eyes
    g.fillStyle(0xFFFFFF, 1);
    g.fillCircle(17, 22, 4); g.fillCircle(31, 22, 4);
    g.fillStyle(0x115511, 1);
    g.fillCircle(18, 23, 2); g.fillCircle(32, 23, 2);
    g.generateTexture('splitting_slime', sz, sz); g.destroy();
    // Mini slime texture
    const g2 = this.add.graphics(); const sz2 = 24;
    g2.fillStyle(0x44CC44, 1);
    g2.fillCircle(12, 14, 10);
    g2.fillStyle(0x88EE88, 0.6);
    g2.fillCircle(9, 11, 4);
    g2.fillStyle(0xFFFFFF, 1);
    g2.fillCircle(9, 12, 2); g2.fillCircle(15, 12, 2);
    g2.fillStyle(0x115511, 1);
    g2.fillCircle(9, 12, 1); g2.fillCircle(15, 12, 1);
    g2.generateTexture('mini_slime', sz2, sz2); g2.destroy();
  }

  createBlizzardShamanTexture() {
    const g = this.add.graphics(); const sz = 36;
    // Star shape (purple)
    g.fillStyle(0xAA55FF, 1);
    const cx = 18, cy = 18, outerR = 16, innerR = 7;
    const pts = [];
    for (let i = 0; i < 10; i++) {
      const a = (Math.PI * 2 * i / 10) - Math.PI / 2;
      const r = i % 2 === 0 ? outerR : innerR;
      pts.push({ x: cx + Math.cos(a) * r, y: cy + Math.sin(a) * r });
    }
    g.beginPath(); g.moveTo(pts[0].x, pts[0].y);
    for (let i = 1; i < pts.length; i++) g.lineTo(pts[i].x, pts[i].y);
    g.closePath(); g.fillPath();
    // Inner glow
    g.fillStyle(0xCC88FF, 0.6);
    g.fillCircle(cx, cy, 6);
    // Eyes
    g.fillStyle(0xFFFFFF, 1);
    g.fillCircle(14, 16, 2); g.fillCircle(22, 16, 2);
    g.fillStyle(0x440088, 1);
    g.fillCircle(14, 16, 1); g.fillCircle(22, 16, 1);
    g.generateTexture('blizzard_shaman', sz, sz); g.destroy();
  }

  createNPCTextures() {
    let g = this.add.graphics();
    g.fillStyle(0x8B6914, 1); g.fillRect(10, 15, 12, 10);
    g.fillStyle(0xFFDDBB, 1); g.fillRect(12, 6, 8, 8);
    g.fillStyle(0x6B4914, 1); g.fillRect(11, 3, 10, 5);
    g.fillStyle(0x222222, 1); g.fillRect(14, 9, 1, 1); g.fillRect(17, 9, 1, 1);
    g.lineStyle(2, 0x884422, 1);
    g.beginPath(); g.arc(25, 15, 8, -1.2, 1.2); g.strokePath();
    g.lineStyle(1, 0xCCCCCC, 1); g.lineBetween(25, 7, 25, 23);
    g.fillStyle(0x555555, 1); g.fillRect(12, 25, 3, 5); g.fillRect(17, 25, 3, 5);
    g.generateTexture('npc_hunter', 32, 32); g.destroy();

    g = this.add.graphics();
    g.fillStyle(0xEEDDCC, 1); g.fillRect(10, 15, 12, 10);
    g.fillStyle(0xFFDDBB, 1); g.fillRect(12, 6, 8, 8);
    g.fillStyle(0x44AA44, 1); g.fillRect(11, 2, 10, 5);
    g.fillStyle(0xFFFFFF, 1); g.fillRect(10, 15, 12, 2);
    g.fillStyle(0x222222, 1); g.fillRect(14, 9, 1, 1); g.fillRect(17, 9, 1, 1);
    g.fillStyle(0xDD8866, 1); g.fillRect(14, 11, 4, 1);
    g.fillStyle(0xFFDD00, 1); g.fillCircle(25, 20, 4);
    g.fillStyle(0xFFAA00, 1); g.fillCircle(25, 20, 2);
    g.fillStyle(0x555555, 1); g.fillRect(12, 25, 3, 5); g.fillRect(17, 25, 3, 5);
    g.generateTexture('npc_merchant', 32, 32); g.destroy();

    g = this.add.graphics();
    g.fillStyle(0x66AA44, 1); g.fillRect(10, 15, 12, 10);
    g.fillStyle(0xFFDDBB, 1); g.fillRect(12, 6, 8, 8);
    g.fillStyle(0x558833, 1); g.fillRect(11, 3, 10, 5);
    g.fillStyle(0x222222, 1); g.fillRect(14, 9, 1, 1); g.fillRect(17, 9, 1, 1);
    g.fillStyle(0x884422, 1); g.fillRect(5, 12, 2, 14);
    g.fillStyle(0x555555, 1); g.fillRect(12, 25, 3, 5); g.fillRect(17, 25, 3, 5);
    g.generateTexture('npc_gatherer', 32, 32); g.destroy();

    g = this.add.graphics();
    g.fillStyle(0x3366AA, 1); g.fillRect(10, 15, 12, 10);
    g.fillStyle(0x4477BB, 1); g.fillRect(10, 15, 12, 3);
    g.fillStyle(0xFFDDBB, 1); g.fillRect(12, 6, 8, 8);
    g.fillStyle(0x5588CC, 1); g.fillRect(11, 3, 10, 4);
    g.fillStyle(0x222222, 1); g.fillRect(14, 9, 1, 1); g.fillRect(17, 9, 1, 1);
    g.fillStyle(0xCCCCCC, 1); g.fillRect(24, 8, 2, 14);
    g.fillStyle(0x884422, 1); g.fillRect(23, 21, 4, 3);
    g.fillStyle(0x3355AA, 1); g.fillRoundedRect(2, 14, 8, 10, 2);
    g.fillStyle(0xFFDD00, 1); g.fillCircle(6, 19, 2);
    g.fillStyle(0x555566, 1); g.fillRect(12, 25, 3, 5); g.fillRect(17, 25, 3, 5);
    g.generateTexture('npc_warrior', 32, 32); g.destroy();
  }

  createNPCBackTextures() {
    // ÏÇ¨ÎÉ•Íæº Îí∑Î™®Ïäµ
    let g = this.add.graphics();
    g.fillStyle(0x8B6914, 1); g.fillRect(10, 15, 12, 10);
    g.fillStyle(0x553322, 1); g.fillRect(12, 6, 8, 8); // Îí§ÌÜµÏàò
    g.fillStyle(0x6B4914, 1); g.fillRect(11, 3, 10, 5); // Î™®Ïûê
    // Îì±Ïóê Ìôú
    g.lineStyle(2, 0x884422, 1);
    g.beginPath(); g.arc(16, 18, 6, -1.2, 1.2); g.strokePath();
    g.fillStyle(0x555555, 1); g.fillRect(12, 25, 3, 5); g.fillRect(17, 25, 3, 5);
    g.generateTexture('npc_hunter_back', 32, 32); g.destroy();

    // ÏÉÅÏù∏ Îí∑Î™®Ïäµ
    g = this.add.graphics();
    g.fillStyle(0xEEDDCC, 1); g.fillRect(10, 15, 12, 10);
    g.fillStyle(0x553322, 1); g.fillRect(12, 6, 8, 8);
    g.fillStyle(0x44AA44, 1); g.fillRect(11, 2, 10, 5);
    // Î∞∞ÎÇ≠
    g.fillStyle(0x885522, 1); g.fillRect(12, 16, 8, 8);
    g.fillStyle(0x774411, 1); g.fillRect(13, 17, 6, 6);
    g.fillStyle(0x555555, 1); g.fillRect(12, 25, 3, 5); g.fillRect(17, 25, 3, 5);
    g.generateTexture('npc_merchant_back', 32, 32); g.destroy();

    // Ï±ÑÏßëÍæº Îí∑Î™®Ïäµ
    g = this.add.graphics();
    g.fillStyle(0x66AA44, 1); g.fillRect(10, 15, 12, 10);
    g.fillStyle(0x553322, 1); g.fillRect(12, 6, 8, 8);
    g.fillStyle(0x558833, 1); g.fillRect(11, 3, 10, 5);
    // Îì±Ïóê ÎèÑÍµ¨
    g.fillStyle(0x884422, 1); g.fillRect(20, 12, 2, 14);
    g.fillStyle(0x555555, 1); g.fillRect(12, 25, 3, 5); g.fillRect(17, 25, 3, 5);
    g.generateTexture('npc_gatherer_back', 32, 32); g.destroy();

    // Ï†ÑÏÇ¨ Îí∑Î™®Ïäµ
    g = this.add.graphics();
    g.fillStyle(0x3366AA, 1); g.fillRect(10, 15, 12, 10);
    g.fillStyle(0x553322, 1); g.fillRect(12, 6, 8, 8);
    g.fillStyle(0x5588CC, 1); g.fillRect(11, 3, 10, 4);
    // Îì±Ïóê Î∞©Ìå®
    g.fillStyle(0x3355AA, 1); g.fillRoundedRect(11, 16, 10, 8, 2);
    g.fillStyle(0xFFDD00, 1); g.fillCircle(16, 20, 2);
    // Îì±Ïóê Ïπº
    g.fillStyle(0xCCCCCC, 1); g.fillRect(22, 8, 2, 14);
    g.fillStyle(0x555566, 1); g.fillRect(12, 25, 3, 5); g.fillRect(17, 25, 3, 5);
    g.generateTexture('npc_warrior_back', 32, 32); g.destroy();
  }

  createTreeTexture() {
    const g = this.add.graphics();
    g.fillStyle(0x5D4037, 1); g.fillRect(20, 44, 8, 20);
    g.fillStyle(0xEEEEFF, 0.4); g.fillRect(20, 44, 4, 6);
    g.fillStyle(0x1B5E20, 1); g.fillTriangle(24, 4, 4, 34, 44, 34);
    g.fillStyle(0x2E7D32, 1); g.fillTriangle(24, 14, 8, 40, 40, 40);
    g.fillStyle(0x388E3C, 1); g.fillTriangle(24, 24, 10, 48, 38, 48);
    g.fillStyle(0xFFFFFF, 0.6); g.fillTriangle(24, 4, 14, 18, 34, 18);
    g.fillStyle(0xFFFFFF, 0.3); g.fillRect(10, 38, 28, 3);
    g.generateTexture('tree_node', 48, 64);
    g.destroy();
  }

  createRockTexture() {
    const g = this.add.graphics();
    g.fillStyle(0x666666, 1); g.fillRoundedRect(2, 6, 24, 16, 6);
    g.fillStyle(0x888888, 1); g.fillRoundedRect(4, 4, 14, 10, 5);
    g.fillStyle(0x999999, 0.6); g.fillRoundedRect(6, 6, 8, 6, 3);
    g.fillStyle(0xFFFFFF, 0.5); g.fillRoundedRect(4, 3, 16, 4, 3);
    g.lineStyle(1, 0x444444, 0.4); g.lineBetween(10, 8, 14, 16); g.lineBetween(18, 6, 20, 14);
    g.generateTexture('rock_node', 28, 24);
    g.destroy();
  }

  createDropTextures() {
    let g = this.add.graphics();
    g.fillStyle(0xCC4422, 1); g.fillRoundedRect(3, 3, 18, 14, 5);
    g.fillStyle(0xEE6644, 1); g.fillRoundedRect(5, 5, 14, 8, 4);
    g.fillStyle(0xFFAA88, 0.6); g.fillRoundedRect(7, 6, 4, 4, 2);
    g.fillStyle(0xEEDDCC, 1); g.fillRect(1, 8, 4, 3); g.fillCircle(2, 8, 2); g.fillCircle(2, 11, 2);
    g.generateTexture('meat_drop', 24, 20); g.destroy();

    g = this.add.graphics();
    g.fillStyle(0x8B6914, 1); g.fillRect(4, 2, 6, 18);
    g.fillStyle(0xA07B28, 1); g.fillRect(5, 3, 4, 16);
    g.fillStyle(0x7B5914, 1); g.fillRect(4, 2, 6, 2); g.fillRect(4, 18, 6, 2);
    g.generateTexture('wood_drop', 14, 22); g.destroy();

    g = this.add.graphics();
    g.fillStyle(0x888888, 1); g.fillRoundedRect(2, 4, 14, 10, 4);
    g.fillStyle(0xAAAAAA, 0.6); g.fillRoundedRect(4, 5, 6, 5, 3);
    g.generateTexture('stone_drop', 18, 18); g.destroy();

    g = this.add.graphics();
    g.fillStyle(0xC4A46C, 1); g.fillRoundedRect(2, 2, 14, 14, 3);
    g.fillStyle(0xB09458, 0.6); g.fillRect(4, 4, 10, 10);
    g.generateTexture('leather_drop', 18, 18); g.destroy();
  }

  createParticleTextures() {
    let g = this.add.graphics();
    g.fillStyle(0xFFFFFF, 0.9); g.fillCircle(4, 4, 3);
    g.fillStyle(0xFFFFFF, 0.5); g.fillCircle(4, 4, 4);
    g.generateTexture('snowflake', 8, 8); g.destroy();

    g = this.add.graphics();
    g.fillStyle(0xFF4444, 1); g.fillCircle(4, 4, 4);
    g.fillStyle(0xFF8844, 0.7); g.fillCircle(4, 4, 2);
    g.generateTexture('hit_particle', 8, 8); g.destroy();

    g = this.add.graphics();
    g.fillStyle(0xFFDD00, 1); g.fillCircle(4, 4, 3);
    g.fillStyle(0xFFFF88, 0.7); g.fillCircle(3, 3, 1.5);
    g.generateTexture('gold_particle', 8, 8); g.destroy();

    g = this.add.graphics();
    g.lineStyle(3, 0xFFFFFF, 0.9);
    g.beginPath(); g.arc(16, 16, 12, -0.8, 0.8); g.strokePath();
    g.generateTexture('slash_fx', 32, 32); g.destroy();

    g = this.add.graphics();
    g.fillStyle(0xFFDD44, 1); g.fillCircle(4, 4, 4);
    g.fillStyle(0xFFFFAA, 0.7); g.fillCircle(3, 3, 2);
    g.generateTexture('sparkle', 8, 8); g.destroy();

    g = this.add.graphics();
    g.fillStyle(0xFF6600, 1); g.fillCircle(4, 4, 4);
    g.fillStyle(0xFFAA00, 0.8); g.fillCircle(4, 3, 2.5);
    g.fillStyle(0xFFDD44, 0.5); g.fillCircle(4, 2, 1.5);
    g.generateTexture('fire_particle', 8, 8); g.destroy();
  }

  createCrateTexture() {
    const g = this.add.graphics();
    // Wooden crate with golden trim
    g.fillStyle(0x8B6914, 1); g.fillRoundedRect(4, 6, 28, 24, 3);
    g.fillStyle(0xA07B28, 1); g.fillRoundedRect(6, 8, 24, 20, 2);
    g.lineStyle(2, 0xFFDD44, 0.8); g.strokeRoundedRect(4, 6, 28, 24, 3);
    // Cross bands
    g.fillStyle(0x664411, 1);
    g.fillRect(4, 16, 28, 3);
    g.fillRect(16, 6, 3, 24);
    // Lock/star
    g.fillStyle(0xFFDD44, 1); g.fillCircle(18, 18, 4);
    g.fillStyle(0xFFAA00, 1); g.fillCircle(18, 18, 2);
    g.generateTexture('supply_crate', 36, 36);
    g.destroy();
  }
}

class GameScene extends Phaser.Scene {
  constructor() { super('Game'); }

  create() {
    this.cameras.main.fadeIn(500);
    this.res = { meat: 0, wood: 0, stone: 0, leather: 0, gold: 0 };
    this.playerHP = 100; this.playerMaxHP = 100;
    this.playerDamage = 10;
    this.playerSpeed = 120;
    this.playerBaseSpeed = 120;
    this.warmthResist = 0;
    this.woodBonus = 0; this.stoneBonus = 0;
    this.temperature = 100; this.maxTemp = 100;
    this.hunger = 100; this.maxHunger = 100;
    this.attackCooldown = 0;
    this.baseAttackSpeed = 0.35;
    this.moveDir = { x: 0, y: 0 };
    this.npcsOwned = [];
    this.placedBuildings = [];
    
    // ‚ïê‚ïê‚ïê Apply Meta Progression Bonuses ‚ïê‚ïê‚ïê
    const meta = MetaManager.getBonusStats();
    this.playerMaxHP += meta.bonusHP;
    this.playerHP = this.playerMaxHP;
    this.warmthResist += meta.bonusTempResist;
    this.res.wood += meta.bonusWood;
    this.extraCardChoices = meta.extraCardChoices || 0;

    // ‚ïê‚ïê‚ïê Equipment Manager (init early, before bonuses) ‚ïê‚ïê‚ïê
    if (!this.equipmentManager) this.equipmentManager = new EquipmentManager();

    // ‚ïê‚ïê‚ïê Apply Equipment Bonuses ‚ïê‚ïê‚ïê
    const eqBonus = this.equipmentManager.getTotalBonuses();
    this.playerMaxHP += eqBonus.hpFlat;
    this.playerHP = this.playerMaxHP;
    this.warmthResist += eqBonus.coldRes;
    this._equipBonuses = eqBonus; // cache for runtime use

    // ‚ïê‚ïê‚ïê Apply Player Class ‚ïê‚ïê‚ïê
    this._playerClass = this.scene.settings.data?.playerClass || localStorage.getItem('whiteout_class') || null;
    this._classRoarCD = 0; // warrior roar cooldown
    this._classBlizzardCD = 0; // mage blizzard cooldown
    this._classSprintCD = 0; // survivor sprint cooldown
    this._classSprintActive = false;
    this._classSpiritCD = 0; // shaman spirit cooldown
    this._classShamanStormCD = 0; // shaman storm cooldown
    this._classHunterVolleyCD = 0; // hunter volley cooldown
    this._hunterTraps = []; // hunter trap positions
    this._hunterTrapTimer = 0; // 15s trap placement timer
    this._hunterSniperHits = 0; // sniper bonus hit count for HUD
    this._spiritOrbs = []; // soul harvest orbs
    this._shamanSpirit = null; // active spirit entity
    this._shamanSpiritTimer = 0;
    this._natureBlessing = false; // nature's blessing active
    if (this._playerClass && PLAYER_CLASSES[this._playerClass]) {
      const cls = PLAYER_CLASSES[this._playerClass];
      // Override HP
      this.playerMaxHP = cls.stats.hp + meta.bonusHP + eqBonus.hpFlat;
      this.playerHP = this.playerMaxHP;
      // Apply multipliers
      this.playerDamage = Math.round(this.playerDamage * cls.stats.damageMul);
      this.playerBaseSpeed = Math.round(this.playerBaseSpeed * cls.stats.speedMul);
      this.playerSpeed = this.playerBaseSpeed;
      this.baseAttackSpeed *= (1 / cls.stats.attackSpeedMul); // faster = lower cooldown
      this._classAttackRangeMul = cls.stats.attackRangeMul;
      this.warmthResist += cls.stats.warmthResist;
      // Survivor: blizzard cloak by default
      if (this._playerClass === 'survivor') {
        this._survivorBlizzardCloak = true;
      }
      // Shaman: XP multiplier
      if (this._playerClass === 'shaman' && cls.stats.xpMul) {
        this._shamanXpMul = cls.stats.xpMul;
      }
      // Start item
      if (cls.startItem) {
        this.equipmentManager.tryEquip(cls.startItem.slot, cls.startItem.itemId, cls.startItem.grade);
        // Recompute equipment bonuses
        const eqBonus2 = this.equipmentManager.getTotalBonuses();
        this._equipBonuses = eqBonus2;
      }
    } else {
      this._classAttackRangeMul = 1;
    }

    // ‚ïê‚ïê‚ïê Apply Difficulty Mode ‚ïê‚ïê‚ïê
    this._difficulty = this.scene.settings.data?.difficulty || localStorage.getItem('whiteout_difficulty') || 'normal';
    this._diffMode = DIFFICULTY_MODES[this._difficulty] || DIFFICULTY_MODES.normal;

    // ‚ïê‚ïê‚ïê Apply Daily Challenge ‚ïê‚ïê‚ïê
    this._dailyChallenge = this.scene.settings.data?.dailyChallenge || null;
    this._dailyModifier = this._dailyChallenge ? this._dailyChallenge.modifier : {};
    this._endlessMode = this.scene.settings.data?.endlessMode || localStorage.getItem('whiteout_endless') === 'true';
    this._ngPlus = this.scene.settings.data?.ngPlus || false;
    this._bossRushMode = this.scene.settings.data?.bossRush || false;
    this._bossRushWave = 0; // current boss rush wave (0 = not started, 1-4)
    this._bossRushWaveSpawned = [false, false, false, false];
    this._bossRushBossAlive = false;
    this._bossRushBossSpawnTime = 0;
    this._bossRushPrepPhase = false;
    this._bossRushPrepTimer = 0;
    this._bossRushCleared = false;
    // ‚ïê‚ïê‚ïê Speedrun Mode ‚ïê‚ïê‚ïê
    this._speedrunMode = this.scene.settings.data?.speedrun || false;
    this._speedrunTimer = 1800; // 30 minutes countdown
    this._speedrunBossKills = 0;
    this._speedrunCleared = false;
    // ‚ïê‚ïê‚ïê Handicap Mode ‚ïê‚ïê‚ïê
    this._handicap = this.scene.settings.data?.handicap || 'none';
    this._fogGraphics = null;
    this._fogFrameCount = 0;
    this._endlessMultiplier = 1.0;
    this._endlessBossCount = 0;
    this._milestone5Shown = false;
    this._milestone10Shown = false;
    this._milestone20Shown = false;
    this._milestone30Shown = false;
    this._milestone45Shown = false;
    this._milestone60Shown = false;
    // Wave drama system
    this._waveWarningActive = false;
    this._waveWarningTimer = 0;
    this._lastKillstreakTier = 0; // for RAMPAGE/UNSTOPPABLE/GODLIKE
    this._killstreakText = null;
    this._visitedZonesForBanner = new Set(); // session-based zone discovery
    // glass_cannon modifier
    if (this._dailyModifier.hp) {
      this.playerMaxHP = this._dailyModifier.hp;
      this.playerHP = this.playerMaxHP;
    }
    if (this._dailyModifier.damageMult) {
      this.playerDamage = Math.round(this.playerDamage * this._dailyModifier.damageMult);
    }
    // alwaysBlizzard handled in update
    // noEquipDrop handled in _tryDropEquipment
    // ‚ïê‚ïê‚ïê Handicap: Glass Body ‚ïê‚ïê‚ïê
    if (this._handicap === 'glass_body') {
      this.playerMaxHP = Math.floor(this.playerMaxHP / 2);
      this.playerHP = this.playerMaxHP;
    }

    // ‚ïê‚ïê‚ïê Apply New Game+ Mode ‚ïê‚ïê‚ïê
    if (this._ngPlus) {
      // Enemy strength 1.3x (applied via diffMode override)
      this._ngPlusEnemyMul = 1.3;
      this._ngPlusColdMul = 1.5;
      // Start weapon from previous run's best (simplified: give uncommon weapon)
      this.equipmentManager.tryEquip('weapon', 'knife', 'uncommon');
    } else {
      this._ngPlusEnemyMul = 1.0;
      this._ngPlusColdMul = 1.0;
    }

    this.gameOver = false;
    this.isRespawning = false;
    this.buildMode = null;
    this.storageCapacity = 50;
    this.upgradeManager = new UpgradeManager();
    // NG+ starting upgrades (3 random)
    if (this._ngPlus) {
      const basicUpgrades = ['DAMAGE_UP', 'MAX_HP', 'MOVEMENT', 'ATTACK_SPEED', 'REGEN', 'DODGE', 'ARMOR', 'MAGNET', 'CRITICAL'];
      const shuffled = basicUpgrades.sort(() => Math.random() - 0.5);
      for (let i = 0; i < 3; i++) {
        this.upgradeManager.apply(shuffled[i], this);
      }
    }
    this.synergyManager = new SynergyManager();
    this._synergyBlockChance = 0;
    this._synergyExtraDropRate = 0;
    this._synergyColdImmunity = false;
    this._coldImmunePulse = false;
    this.equipmentManager = new EquipmentManager();
    this.equipmentDrops = []; // world items awaiting pickup
    this.supplyCrates = [];
    this.upgradeUIActive = false;
    this.playerXP = 0;
    this.playerLevel = 1;
    this.pendingLevelUps = 0;
    this.levelUpQueue = 0; // compat alias

    // ‚ïê‚ïê‚ïê Kill Combo System ‚ïê‚ïê‚ïê
    this.killCombo = 0;
    this.killComboTimer = 0; // seconds remaining
    this.killComboText = null;
    this._hitStopActive = false; // hitstop flag
    this._killAuraGfx = null; // kill streak aura
    this._killAuraParticles = null;
    this._killAuraAngle = 0;
    
    // ‚ïê‚ïê‚ïê Streak Buff System ‚ïê‚ïê‚ïê
    this.streakBuff = { dmgMul: 1, spdMul: 1, timer: 0, tier: 0 };

    // ‚ïê‚ïê‚ïê Tutorial Hints ‚ïê‚ïê‚ïê
    this.tutorialShown = false;

    // ‚ïê‚ïê‚ïê FTUE Context Hints ‚ïê‚ïê‚ïê
    this._ftueHints = { bear: false, boss: false, lowHP: 0, equip: false, blizzard: false, movement: false, attack: false, levelup: false };
    FTUEManager.reset();

    // Mobile-first: always use touch/joystick controls
    this.facingRight = true;

    // ‚ïê‚ïê‚ïê Phase 2: Game Timer & Act System ‚ïê‚ïê‚ïê
    this.gameElapsed = 0; // seconds since game start
    this.currentAct = 1;
    this.waveTimer = 0; // 30s wave spawn timer

    // ‚ïê‚ïê‚ïê Act 3: Special Wave Events ‚ïê‚ïê‚ïê
    this._eliteWaveTriggered = {}; // { 15: true, 30: true, 45: true }
    this._siegeWaveTriggered = {}; // { 25: true, 50: true }
    this._siegeWaveActive = false;
    this._siegeWaveEndTime = 0;
    this._challengeActive = false;
    this._challengeEndTime = 0;
    this._lastChallengeMin = 0;
    this._challengeHUD = null;
    this._iceGolemSpawnTimer = 0;
    this._snowLeopardSpawnTimer = 0;
    this.waveNumber = 0;

    // ‚ïê‚ïê‚ïê Blizzard (ÌïúÌåå) System ‚ïê‚ïê‚ïê
    this.blizzardActive = (this._dailyModifier && this._dailyModifier.alwaysBlizzard) ? true : false;
    this.blizzardMultiplier = (this._dailyModifier && this._dailyModifier.alwaysBlizzard) ? 2.0 : 1;
    this.blizzardIndex = 0;
    this.blizzardWarned = false;
    this.blizzardWarningEndTime = 0;
    this.blizzardCountdownTimer = null;
    this.coldWaveOverlay = null;
    // Compat aliases for save/load
    this.coldWaveActive = false;
    this.coldWaveTimer = 0;
    this.coldWaveDuration = 0;
    this.coldWaveIntensity = 0;
    this.coldWaveCount = 0;
    this.nextColdWaveTime = 999999;

    // ‚ïê‚ïê‚ïê Phase 2: Rhythm System (15-20s events) ‚ïê‚ïê‚ïê
    this.rhythmTimer = 0;
    this.nextRhythmInterval = 15;

    // ‚ïê‚ïê‚ïê Phase 2: Boss System ‚ïê‚ïê‚ïê
    this.boss1Spawned = false;
    this._boss1Warned = false;
    this.boss2Spawned = false;
    this.act2MinibossSpawned = false;
    this.act4MinibossSpawned = false;

    // ‚ïê‚ïê‚ïê HIDDEN BOSS: Î∞±ÏÉâ Íµ∞Ï£º ‚ïê‚ïê‚ïê
    this._hiddenBossSpawned = false;
    this._hiddenBossDefeated = false;
    this._extremeZoneTimer = 0; // seconds in extreme zone (top-right)
    try { this._hiddenBossDefeated = JSON.parse(localStorage.getItem('whiteout_hidden_boss_defeated') || 'false'); } catch(e) {}

    // ‚ïê‚ïê‚ïê SECRET EVENTS ‚ïê‚ïê‚ïê
    this._secretEventTimer = 0;
    this._ghostMerchantUsed = false;
    this._ghostMerchantActive = false;
    this._ghostMerchantSprite = null;
    this._secretKillCounter = 0; // for snow leopard pack

    // ‚ïê‚ïê‚ïê KONAMI CODE ‚ïê‚ïê‚ïê
    this._konamiSequence = ['ArrowUp','ArrowUp','ArrowDown','ArrowDown','ArrowLeft','ArrowRight','ArrowLeft','ArrowRight','b','a'];
    this._konamiIndex = 0;
    this._konamiActivated = false;
    this.input.keyboard.on('keydown', (evt) => {
      if (this._konamiActivated) return;
      const expected = this._konamiSequence[this._konamiIndex];
      if (evt.key === expected || evt.key === expected.toLowerCase()) {
        this._konamiIndex++;
        if (this._konamiIndex >= this._konamiSequence.length) {
          this._konamiActivated = true;
          this._activateKonamiCode();
        }
      } else {
        this._konamiIndex = (evt.key === this._konamiSequence[0]) ? 1 : 0;
      }
    });

    // ‚ïê‚ïê‚ïê EXTREME ZONE SURVIVAL (for achievement) ‚ïê‚ïê‚ïê
    this._extremeZoneTotalTime = 0;

    // Safe area bottom - compute from DOM
    this.safeBottom = 0;
    try {
      const d = document.createElement('div');
      d.style.cssText = 'position:fixed;bottom:0;height:env(safe-area-inset-bottom,0px);visibility:hidden;';
      document.body.appendChild(d);
      this.safeBottom = d.offsetHeight || 0;
      document.body.removeChild(d);
    } catch(e) {}
    if (!this.safeBottom && /iPhone/.test(navigator.userAgent) && window.screen.height >= 812) {
      this.safeBottom = 34;
    }

    this.stats = { kills: {}, woodGathered: 0, built: {}, crafted: 0, npcsHired: 0, maxCombo: 0, meatCollected: 0, bossKills: 0 };
    this._warmthNearFireTime = 0; // ÌôîÎçï Í∑ºÏ≤ò Ï≤¥Ïò® Ïú†ÏßÄ ÏãúÍ∞Ñ (ÌÄòÏä§Ìä∏Ïö©)

    // ‚ïê‚ïê‚ïê üèÜ Achievement & Random Event System ‚ïê‚ïê‚ïê
    this.achievementUnlocked = {}; // { id: true } for this session
    this._currentRunUpgrades = []; // track upgrades chosen this run
    this._runHistoryManager = new RunHistoryManager();
    this.achievementCheckTimer = 0;
    this.bossKillCount = 0;
    this.gotRareEquip = false;
    this.gotEpicEquip = false;
    this.randomEventTimer = 0;
    this.activeRandomEvents = {}; // { action: { endTime } }
    // Load previously unlocked achievements from localStorage
    try {
      const saved = JSON.parse(localStorage.getItem('achievements_whiteout') || '{}');
      this._savedAchievements = saved;
    } catch(e) { this._savedAchievements = {}; }

    this.gameWon = false;
    this.questIndex = 0;
    this.questCompleted = [];
    this.currentZone = 'safe';
    this._visitedZones = new Set(['safe']);
    this._revivalUsed = false;
    this._questProgress = { equipment_collected: 0, boss_damage_dealt: 0, synergy_activated: 0, critical_hits: 0, zones_visited: 1 };
    this._newQuestsDone = new Set();
    this.questSpawnTimer = 0;

    this.physics.world.setBounds(0, 0, WORLD_W, WORLD_H);
    this.drawBackground();

    this.player = this.physics.add.sprite(WORLD_W/2, WORLD_H/2, 'player');
    this.player.setCollideWorldBounds(true).setDepth(10).setDamping(true).setDrag(0.9);
    this.player.body.setSize(18, 22).setOffset(11, 14);

    // üé® Apply skin tint
    this._currentSkin = SkinManager.getCurrentSkin();
    if (this._currentSkin.id !== 'default') {
      this.player.setTint(this._currentSkin.color);
    }

    this.animals = this.physics.add.group();
    this._iceBolts = [];
    this._playerSlowed = false;
    this._shamanHintShown = false;

    // ‚ïê‚ïê‚ïê PERF: Object Pooling ‚ïê‚ïê‚ïê
    this._particlePool = [];
    this._particlePoolMax = 200;
    this._textPool = [];
    this._textPoolMax = 20;
    this._frameCount = 0;
    this._timerIds = []; // track setTimeout/setInterval for cleanup

    // ‚ïê‚ïê‚ïê PERF: FPS Debug Counter ‚ïê‚ïê‚ïê
    if (new URLSearchParams(window.location.search).get('debug') === '1') {
      this._debugFPS = true;
      this._fpsText = this.add.text(10, 10, 'FPS: --', { fontSize: '12px', fontFamily: 'monospace', color: '#00FF00', stroke: '#000', strokeThickness: 2 }).setScrollFactor(0).setDepth(999);
      this._fpsHistory = [];
      this._fpsLastTime = performance.now();
      this._fpsFrameCount = 0;
      this._fpsSpikeCount = 0;
    }
    this.drops = this.physics.add.group();
    this.npcSprites = this.physics.add.group();
    this.resourceNodes = [];
    this.buildingSprites = [];

    this.cameras.main.startFollow(this.player, true, 0.08, 0.08);
    this.cameras.main.setBounds(0, 0, WORLD_W, WORLD_H);

    this.add.particles(0, 0, 'snowflake', {
      x: { min: 0, max: WORLD_W }, y: -10,
      lifespan: 12000, speedY: { min: 10, max: 30 }, speedX: { min: -20, max: 10 },
      scale: { min: 0.3, max: 1.5 }, alpha: { start: 0.8, end: 0 },
      frequency: 60, quantity: 1, rotate: { min: 0, max: 360 },
    }).setDepth(50);

    this.add.particles(0, 0, 'snowflake', {
      x: { min: 0, max: WORLD_W }, y: -10,
      lifespan: 10000, speedY: { min: 20, max: 50 }, speedX: { min: -10, max: 20 },
      scale: { min: 1, max: 2.5 }, alpha: { start: 0.3, end: 0 },
      frequency: 200, quantity: 1,
    }).setDepth(55);

    this.campfireGlow = this.add.graphics().setDepth(1);

    // ‚ïê‚ïê‚ïê üåç WORLD OBJECTS ‚ïê‚ïê‚ïê
    this._worldObjects = { campfires: [], crates: [], iceWalls: [], flares: [] };
    this._flareXpBuff = 0; // remaining seconds of 2x XP
    this._worldObjCrateTimer = 0; // timer for periodic crate spawn
    this._worldObjFlareTimer = Phaser.Math.Between(300, 420); // 5~7 min first flare
    this._campfireHudText = null;
    this._flareHudText = null;
    this._flareAura = null;
    this._spawnWorldObjects();

    // Cold wave blue overlay (screen-space)
    this.coldWaveOverlay = this.add.graphics().setScrollFactor(0).setDepth(60).setAlpha(0);

    // Blizzard scheduler
    this.gameStartTime = this.time.now;
    this.time.addEvent({
      delay: 1000, loop: true,
      callback: this.checkBlizzardSchedule, callbackScope: this
    });

    this.spawnResourceNodes();
    this.spawnWave();

    this.input.on('pointerdown', (p) => {
      resumeAudio();
      if (this.gameOver) return;
      if (this.isUIArea(p)) return;
      if (this.buildMode) { this.placeBuilding(p); return; }
    });

    this.createVirtualJoystick();
    // ‚ïê‚ïê‚ïê WASD + Arrow Key Support ‚ïê‚ïê‚ïê
    this.wasd = this.input.keyboard.addKeys('W,A,S,D,UP,LEFT,DOWN,RIGHT');
    // ‚ïê‚ïê‚ïê Pause (ESC / P) ‚ïê‚ïê‚ïê
    this._gamePaused = false;
    this._pauseOverlay = null;
    this.input.keyboard.on('keydown-ESC', () => this._togglePause());
    this.input.keyboard.on('keydown-P', () => this._togglePause());
    // ‚ïê‚ïê‚ïê BUFF ITEM SYSTEM ‚ïê‚ïê‚ïê
    this._initBuffSystem();
    this.createUI();
    window._gameScene = this;
    this.physics.add.overlap(this.player, this.drops, (_, d) => this.collectDrop(d));
    this.physics.add.overlap(this.player, this.buffDropGroup, (_, bd) => this._collectBuffDrop(bd));
    this.campfireParticleTimer = 0;

    // ‚ïê‚ïê‚ïê BOSS HP BAR (top center UI) ‚ïê‚ïê‚ïê
    this._initBossHPBar();
    // ‚ïê‚ïê‚ïê Ice Crystal Border Overlay ‚ïê‚ïê‚ïê
    this._iceBorderGfx = this.add.graphics().setScrollFactor(0).setDepth(95);
    const _iceCam = this.cameras.main;
    const _iceW = _iceCam.width, _iceH = _iceCam.height;
    this._iceBorderGfx.fillStyle(0x88CCFF, 0.06);
    // Top-left corner frost
    this._iceBorderGfx.fillTriangle(0, 0, 60, 0, 0, 60);
    this._iceBorderGfx.fillTriangle(0, 0, 40, 0, 0, 40);
    // Top-right corner frost
    this._iceBorderGfx.fillTriangle(_iceW, 0, _iceW - 60, 0, _iceW, 60);
    this._iceBorderGfx.fillTriangle(_iceW, 0, _iceW - 40, 0, _iceW, 40);
    // Bottom-left corner frost
    this._iceBorderGfx.fillTriangle(0, _iceH, 50, _iceH, 0, _iceH - 50);
    // Bottom-right corner frost
    this._iceBorderGfx.fillTriangle(_iceW, _iceH, _iceW - 50, _iceH, _iceW, _iceH - 50);
    // Subtle top/bottom edge frost lines
    this._iceBorderGfx.fillStyle(0x88CCFF, 0.03);
    this._iceBorderGfx.fillRect(0, 0, _iceW, 3);
    this._iceBorderGfx.fillRect(0, _iceH - 3, _iceW, 3);
    this._iceBorderGfx.fillRect(0, 0, 3, _iceH);
    this._iceBorderGfx.fillRect(_iceW - 3, 0, 3, _iceH);

    // ‚ïê‚ïê‚ïê Day/Night color temp overlay ‚ïê‚ïê‚ïê
    this._dayNightOverlay = this.add.rectangle(_iceW/2, _iceH/2, _iceW, _iceH, 0xFFDDAA, 0)
      .setScrollFactor(0).setDepth(94).setBlendMode(Phaser.BlendModes.ADD);

    // ‚ïê‚ïê‚ïê MINIMAP ‚ïê‚ïê‚ïê
    this._initMinimap();
    // ‚ïê‚ïê‚ïê HIT VIGNETTE ‚ïê‚ïê‚ïê
    this._initVignette();
    // M key for minimap toggle
    this.input.keyboard.on('keydown-M', () => {
      this._minimapVisible = !this._minimapVisible;
      if (this._minimapContainer) this._minimapContainer.setVisible(this._minimapVisible);
    });

    // ‚îÄ‚îÄ Load Save Data ‚îÄ‚îÄ
    const loadSave = this.scene.settings.data?.loadSave;
    if (loadSave) {
      const save = SaveManager.load();
      if (save) {
        try {
          this._applySaveData(save);
        } catch (e) {
          console.error('Save data corrupt, starting fresh:', e);
          SaveManager.delete();
        }
      }
      // If save requested but not found ‚Üí safe fallback (no crash)
    }
    
    // ‚îÄ‚îÄ Tutorial Overlay (ÏÉà Í≤åÏûÑ ÏãúÏûë Ïãú Ïπ¥Ïö¥Ìä∏Îã§Ïö¥ + Í∞ÄÏù¥Îìú) ‚îÄ‚îÄ
    if (!loadSave) {
      this._showStartCountdown();
      this._showTutorialOverlay();
      // Act 1 story text (delayed to show after countdown)
      this.time.delayedCall(3500, () => this.showActStoryText(ACT_STORY.start));

      // ‚ïê‚ïê‚ïê FTUE: Spawn 2 rabbits near player for early kill ‚ïê‚ïê‚ïê
      for (let i = 0; i < 2; i++) {
        const ang = Phaser.Math.FloatBetween(0, Math.PI * 2);
        const dist = Phaser.Math.Between(80, 120);
        const rx = this.player.x + Math.cos(ang) * dist;
        const ry = this.player.y + Math.sin(ang) * dist;
        const def = ANIMALS['rabbit'], type = 'rabbit';
        const a = this.physics.add.sprite(
          Phaser.Math.Clamp(rx, 60, WORLD_W-60),
          Phaser.Math.Clamp(ry, 60, WORLD_H-60),
          type
        ).setCollideWorldBounds(true).setDepth(5);
        a.animalType = type; a.def = def;
        this._applyDifficultyToAnimal(a, def);
        a.wanderTimer = 0; a.wanderDir = {x:0,y:0}; a.hitFlash = 0; a.atkCD = 0; a.fleeTimer = 0;
        const lc = '#AADDFF';
        a.nameLabel = this.add.text(a.x, a.y - def.size - 10, def.name, {
          fontSize: '11px', fontFamily: 'monospace', color: lc, stroke: '#000', strokeThickness: 3
        }).setDepth(6).setOrigin(0.5);
        this.animals.add(a);
      }

      // ‚ïê‚ïê‚ïê FTUE: Hint text (disappears after 10s or first level-up) ‚ïê‚ïê‚ïê
      this._ftueHint = this.add.text(
        this.cameras.main.width / 2,
        this.cameras.main.height - 80,
        'Ï†ÅÏùÑ Ï≤òÏπòÌïòÎ©¥ Í≤ΩÌóòÏπòÎ•º ÏñªÏäµÎãàÎã§',
        { fontSize: '16px', fontFamily: 'monospace', color: '#FFFFFF',
          stroke: '#000', strokeThickness: 4, fontStyle: 'bold' }
      ).setOrigin(0.5).setDepth(100).setScrollFactor(0).setAlpha(0.9);
      this.time.delayedCall(10000, () => {
        if (this._ftueHint && this._ftueHint.active) {
          this.tweens.add({ targets: this._ftueHint, alpha: 0, duration: 500,
            onComplete: () => { if(this._ftueHint) this._ftueHint.destroy(); this._ftueHint = null; } });
        }
      });
    }

    // ‚îÄ‚îÄ Auto-Save Timer (60Ï¥à) ‚îÄ‚îÄ
    this.autoSaveTimer = this.time.addEvent({
      delay: 60000,
      callback: () => {
        if (!this.gameOver) {
          SaveManager.save(this);
          this._showSaveIndicator();
        }
      },
      loop: true
    });
  }

  _applySaveData(save) {
    // Player stats
    if (save.player) {
      this.player.setPosition(save.player.x, save.player.y);
      this.playerHP = save.player.hp;
      this.playerMaxHP = save.player.maxHP;
      this.playerDamage = save.player.damage;
      this.playerSpeed = save.player.speed;
      this.playerBaseSpeed = save.player.baseSpeed;
      this.warmthResist = save.player.warmthResist;
      this.woodBonus = save.player.woodBonus;
      this.stoneBonus = save.player.stoneBonus;
      this.baseAttackSpeed = save.player.baseAttackSpeed;
      this.facingRight = save.player.facingRight;
    }
    // Resources
    if (save.resources) this.res = save.resources;
    if (save.temperature != null) this.temperature = save.temperature;
    if (save.maxTemp != null) this.maxTemp = save.maxTemp;
    if (save.hunger != null) this.hunger = save.hunger;
    if (save.maxHunger != null) this.maxHunger = save.maxHunger;
    if (save.storageCapacity != null) this.storageCapacity = save.storageCapacity;
    if (save.stats) this.stats = save.stats;
    if (save.questCompleted) this.questCompleted = save.questCompleted;
    if (save.questIndex != null) this.questIndex = save.questIndex;
    // XP system
    if (save.playerXP != null) this.playerXP = save.playerXP;
    if (save.playerLevel != null) this.playerLevel = save.playerLevel;
    // Buildings
    if (save.buildings) {
      save.buildings.forEach(b => {
        this.buildMode = b.type;
        this._restoreBuilding(b);
      });
      this.buildMode = null;
    }
    // Upgrades
    if (save.upgrades) {
      this.upgradeManager.fromJSON(save.upgrades, this);
      if (save.synergies) {
        this.synergyManager.fromJSON(save.synergies, this);
        this.synergyManager.renderHUD(this);
      }
    }
    // Phase 2 state
    if (save.gameElapsed != null) this.gameElapsed = save.gameElapsed;
    if (save.coldWaveCount != null) this.coldWaveCount = save.coldWaveCount;
    if (save.nextColdWaveTime != null) this.nextColdWaveTime = save.nextColdWaveTime;
    if (save.boss1Spawned != null) this.boss1Spawned = save.boss1Spawned;
    if (save.boss2Spawned != null) this.boss2Spawned = save.boss2Spawned;
    if (save.act2MinibossSpawned != null) this.act2MinibossSpawned = save.act2MinibossSpawned;
    if (save.act4MinibossSpawned != null) this.act4MinibossSpawned = save.act4MinibossSpawned;
    if (save.waveNumber != null) this.waveNumber = save.waveNumber;
    this.currentAct = this.getCurrentAct();
    // NPCs
    if (save.npcs) {
      save.npcs.forEach(n => {
        this._restoreNPC(n);
      });
    }
  }

  _restoreBuilding(b) {
    const def = BUILDINGS[b.type];
    if (!def) return;
    // Re-draw building graphics (same as placeBuilding)
    const wx = b.x, wy = b.y;
    const g = this.add.graphics().setDepth(2);
    if (b.type === 'campfire') {
      g.fillStyle(0x884422, 1); g.fillRect(wx-12, wy+6, 24, 6);
      g.fillStyle(0x664411, 1); g.fillRect(wx-10, wy+3, 20, 5);
      g.fillStyle(0x777777, 1);
      for (let i = 0; i < 8; i++) { const a2 = (i / 8) * Math.PI * 2; g.fillCircle(wx + Math.cos(a2)*14, wy + Math.sin(a2)*14, 3); }
      g.fillStyle(0xFF4400, 0.9); g.fillCircle(wx, wy, 10);
      g.fillStyle(0xFF8800, 0.8); g.fillCircle(wx, wy-2, 7);
      g.fillStyle(0xFFCC00, 0.6); g.fillCircle(wx, wy-4, 4);
    } else if (b.type === 'tent') {
      g.fillStyle(0x8B6914, 0.9); g.fillTriangle(wx, wy-26, wx-24, wy+12, wx+24, wy+12);
      g.fillStyle(0xA07B28, 0.7); g.fillTriangle(wx, wy-22, wx-20, wy+10, wx+20, wy+10);
      g.fillStyle(0x5D4037, 1); g.fillRect(wx-5, wy+2, 10, 10);
    } else if (b.type === 'storage') {
      g.fillStyle(0x795548, 1); g.fillRect(wx-18, wy-16, 36, 32);
      g.fillStyle(0x8D6E63, 1); g.fillTriangle(wx, wy-24, wx-20, wy-14, wx+20, wy-14);
      g.fillStyle(0x5D4037, 1); g.fillRect(wx-5, wy+4, 10, 12);
    } else if (b.type === 'workshop') {
      g.fillStyle(0x795548, 1); g.fillRect(wx-16, wy-14, 32, 28);
      g.fillStyle(0x8D6E63, 1); g.fillTriangle(wx, wy-22, wx-18, wy-12, wx+18, wy-12);
      g.fillStyle(0x5D4037, 1); g.fillRect(wx-5, wy+4, 10, 10);
    } else if (b.type === 'wall') {
      g.fillStyle(0x9E9E9E, 1); g.fillRect(wx-20, wy-10, 40, 20);
      g.fillStyle(0xBBBBBB, 0.5);
      g.fillRect(wx-18, wy-8, 10, 8); g.fillRect(wx-5, wy-8, 10, 8); g.fillRect(wx+8, wy-8, 10, 8);
    }
    const label = this.add.text(wx, wy-32, def.icon, {fontSize:'22px'}).setDepth(3).setOrigin(0.5);
    const bld = { type: b.type, x: wx, y: wy, graphic: g, label, def };
    this.placedBuildings.push(bld);
    this.buildingSprites.push(bld);
    if (def.storageBonus) this.storageCapacity += def.storageBonus;
    if (!this.stats.built[b.type]) this.stats.built[b.type] = 0;
  }

  _restoreNPC(n) {
    const npcDef = NPC_DEFS.find(d => d.type === n.type);
    if (!npcDef) return;
    const npc = this.physics.add.sprite(n.x, n.y, 'npc_' + n.type).setDepth(5);
    npc.npcType = n.type;
    npc.npcDef = npcDef;
    npc.setCollideWorldBounds(true);
    npc.body.setSize(16, 20).setOffset(8, 10);
    npc.actionTimer = 0;
    npc.state = 'idle';
    this.npcSprites.add(npc);
    this.npcsOwned.push(npc);
  }

  _showSaveIndicator() {
    const cam = this.cameras.main;
    const txt = this.add.text(cam.scrollX + cam.width - 10, cam.scrollY + 10, 'üíæ Ï†ÄÏû•Îê®', {
      fontSize: '14px', fontFamily: 'monospace', color: '#88ccff',
      stroke: '#000', strokeThickness: 2
    }).setOrigin(1, 0).setDepth(200);
    this.tweens.add({
      targets: txt, alpha: 0, y: txt.y - 20,
      duration: 1500, ease: 'Power2',
      onComplete: () => txt.destroy()
    });
  }

  drawBackground() {
    const bg = this.add.graphics();
    // Zone colors: safe=#E8E8F0, normal=#B0C4DE, danger=#6A7A8A, extreme=#2D2D3A
    // Îçî Î∂ÄÎìúÎü¨Ïö¥ ÎààÎ∞≠ ÏÉâÏÉÅÏúºÎ°ú Í∞úÏÑ†
    const zoneColors = [
      { r: 0xEE, g: 0xEE, b: 0xF5 }, // safe - Î∞ùÏùÄ ÎààÏÉâ
      { r: 0xC8, g: 0xD4, b: 0xE0 }, // normal - Ïó∞Ìïú ÌååÎûë
      { r: 0x7A, g: 0x88, b: 0x96 }, // danger - Ï§ëÍ∞Ñ ÌöåÏÉâ
      { r: 0x35, g: 0x3D, b: 0x45 }, // extreme - Ïñ¥ÎëêÏö¥ ÌöåÏÉâ
    ];
    const zoneRadii = [ZONE_RADII.safe, ZONE_RADII.normal, ZONE_RADII.danger, Math.hypot(WORLD_W, WORLD_H)];
    const cx = MAP_CENTER.x, cy = MAP_CENTER.y;
    const tileSize = 32; // Îçî ÏûëÏùÄ ÌÉÄÏùºÎ°ú Î∂ÄÎìúÎü¨Ïö¥ Ï†ÑÌôò
    const gradientWidth = 120; // Í∑∏ÎùºÎç∞Ïù¥ÏÖò Ìè≠ Ï¶ùÍ∞Ä

    for (let tx = 0; tx < WORLD_W; tx += tileSize) {
      for (let ty = 0; ty < WORLD_H; ty += tileSize) {
        const dist = Math.hypot(tx + tileSize/2 - cx, ty + tileSize/2 - cy);
        // Determine zone index with gradient blending
        let zoneIdx = 3;
        for (let z = 0; z < zoneRadii.length; z++) {
          if (dist <= zoneRadii[z]) { zoneIdx = z; break; }
        }
        // Blend between current zone and next zone at boundary (Îçî Î∂ÄÎìúÎü¨Ïö¥ Ï†ÑÌôò)
        let c = zoneColors[zoneIdx];
        if (zoneIdx < 3) {
          const edge = zoneRadii[zoneIdx];
          const distToEdge = edge - dist;
          if (distToEdge < gradientWidth && distToEdge >= 0) {
            // smoothstep Ìï®ÏàòÎ°ú Îçî ÏûêÏó∞Ïä§Îü¨Ïö¥ Ï†ÑÌôò
            const t = 1 - distToEdge / gradientWidth;
            const smoothT = t * t * (3 - 2 * t);
            const nc = zoneColors[zoneIdx + 1];
            c = {
              r: Math.round(c.r + (nc.r - c.r) * smoothT),
              g: Math.round(c.g + (nc.g - c.g) * smoothT),
              b: Math.round(c.b + (nc.b - c.b) * smoothT),
            };
          }
        }
        // ÎÖ∏Ïù¥Ï¶à Í∏∞Î∞ò ÌÉÄÏùº Î≥ÄÌôî (Perlin-like)
        const noiseX = Math.floor(tx / tileSize);
        const noiseY = Math.floor(ty / tileSize);
        const noiseVal = Math.sin(noiseX * 0.5) * Math.cos(noiseY * 0.5) * 0.5 + 0.5;
        const variation = (noiseVal - 0.5) * 16; // -8 ~ 8 Î≤îÏúÑ
        const cr = Phaser.Math.Clamp(c.r + variation, 0, 255);
        const cg = Phaser.Math.Clamp(c.g + variation, 0, 255);
        const cb = Phaser.Math.Clamp(c.b + variation, 0, 255);
        const color = (cr << 16) | (cg << 8) | cb;
        bg.fillStyle(color, 1);
        bg.fillRect(tx, ty, tileSize, tileSize);
      }
    }
    // ÏûêÏó∞Ïä§Îü¨Ïö¥ Îàà Ìå®ÌÑ¥ Ïò§Î≤ÑÎ†àÏù¥
    for (let i = 0; i < 150; i++) {
      const x = Phaser.Math.Between(0, WORLD_W);
      const y = Phaser.Math.Between(0, WORLD_H);
      const w = Phaser.Math.Between(30, 150);
      const h = Phaser.Math.Between(15, 60);
      const alpha = Phaser.Math.FloatBetween(0.02, 0.12);
      bg.fillStyle(0xFFFFFF, alpha);
      bg.fillEllipse(x, y, w, h);
    }
    // ÏûëÏùÄ Îàà Í≤∞Ï†ï Ìå®ÌÑ¥
    for (let i = 0; i < 300; i++) {
      const x = Phaser.Math.Between(0, WORLD_W);
      const y = Phaser.Math.Between(0, WORLD_H);
      const size = Phaser.Math.Between(2, 8);
      bg.fillStyle(0xFFFFFF, Phaser.Math.FloatBetween(0.05, 0.15));
      bg.fillCircle(x, y, size);
    }
  }

  spawnResourceNodes() {
    for (let i = 0; i < 40; i++) this.createResourceNode('tree', Phaser.Math.Between(80, WORLD_W-80), Phaser.Math.Between(80, WORLD_H-80));
    for (let i = 0; i < 25; i++) this.createResourceNode('rock', Phaser.Math.Between(80, WORLD_W-80), Phaser.Math.Between(80, WORLD_H-80));
  }

  createResourceNode(type, x, y) {
    const def = RESOURCE_NODES[type];
    const spr = this.add.sprite(x, y, type+'_node').setDepth(3);
    if (type === 'tree') spr.setOrigin(0.5, 0.85);
    spr.nodeType = type; spr.nodeDef = def;
    spr.nodeHP = def.hp; spr.nodeMaxHP = def.hp;
    spr.depleted = false; spr.regenTimer = 0;
    this.resourceNodes.push(spr);
    return spr;
  }

  harvestNode(node) {
    if (node.depleted) return;
    node.nodeHP--; playChop();
    this.tweens.add({ targets: node, x: node.x + 4, duration: 40, yoyo: true, repeat: 3 });
    for (let i = 0; i < 3; i++) {
      const p = this.add.image(node.x, node.y, node.nodeType === 'tree' ? 'wood_drop' : 'stone_drop')
        .setDepth(15).setScale(0.5).setAlpha(0.8);
      this.tweens.add({ targets: p, x: node.x + Phaser.Math.Between(-30, 30),
        y: node.y + Phaser.Math.Between(-30, 10), alpha: 0, scale: 0.1, duration: 400,
        onComplete: () => p.destroy() });
    }
    if (node.nodeHP <= 0) {
      const def = node.nodeDef;
      const amount = def.yield + (def.resource === 'wood' ? this.woodBonus : def.resource === 'stone' ? this.stoneBonus : 0);
      for (let i = 0; i < amount; i++)
        this.spawnDrop(def.resource, node.x + Phaser.Math.Between(-20, 20), node.y + Phaser.Math.Between(-10, 10));
      if (def.resource === 'wood') this.stats.woodGathered += amount;
      this.gainXP(XP_SOURCES[node.nodeType] || 1);
      node.depleted = true; node.setAlpha(0.15); node.regenTimer = def.regen;
    }
  }

  spawnWave() {
    [{ type: 'rabbit', count: 8 }, { type: 'deer', count: 4 }, { type: 'penguin', count: 4 },
     { type: 'seal', count: 2 }, { type: 'wolf', count: 2 }]
    .forEach(e => { for (let i = 0; i < e.count; i++) this.spawnAnimal(e.type); });
  }

  _applyDifficultyToAnimal(a, def) {
    const srMul = this._speedrunMode ? 1.2 : 1;
    const hpMul = (this._diffMode ? this._diffMode.enemyHP : 1) * (this._endlessMultiplier || 1) * (this._ngPlusEnemyMul || 1) * srMul;
    a.hp = Math.round(def.hp * hpMul);
    a.maxHP = a.hp;
    a._diffDmgMul = (this._diffMode ? this._diffMode.enemyDmg : 1) * (this._endlessMultiplier || 1) * (this._ngPlusEnemyMul || 1) * srMul;
  }

  spawnAnimal(type) {
    const def = ANIMALS[type], m = 60;
    let x = Phaser.Math.Between(m, WORLD_W-m), y = Phaser.Math.Between(m, WORLD_H-m);
    if (Phaser.Math.Distance.Between(x, y, this.player?.x || WORLD_W/2, this.player?.y || WORLD_H/2) < 200)
      { x = Phaser.Math.Between(m, WORLD_W-m); y = Phaser.Math.Between(m, WORLD_H-m); }
    const a = this.physics.add.sprite(x, y, type).setCollideWorldBounds(true).setDepth(5);
    a.animalType = type; a.def = def;
    this._applyDifficultyToAnimal(a, def);
    // FTUE context hints
    if (type === 'bear') this._ftueOnEnemySpawn('bear');
    else if (type === 'blizzard_shaman' && !this._shamanHintShown) {
      this._shamanHintShown = true;
      this.showCenterAlert('üîÆ ÏÉ§Î®ºÏùÑ Î®ºÏ†Ä Ï≤òÏπòÌïòÏÑ∏Ïöî!', '#AA55FF');
    }
    else if (def.behavior === 'chase') this._ftueOnFirstEnemy();
    a.wanderTimer = 0; a.wanderDir = {x:0,y:0}; a.hitFlash = 0; a.atkCD = 0; a.fleeTimer = 0;
    if (a.maxHP > 2) a.hpBar = this.add.graphics().setDepth(6);
    const lc = def.behavior === 'chase' ? '#FF4444' : def.behavior === 'flee' ? '#88DDFF' : '#AADDFF';
    a.nameLabel = this.add.text(x, y - def.size - 10, def.name, {
      fontSize: '11px', fontFamily: 'monospace', color: lc, stroke: '#000', strokeThickness: 3
    }).setDepth(6).setOrigin(0.5);
    this.animals.add(a);
  }

  performAttack(pointer) {
    if (this.attackCooldown > 0) return;
    this.attackCooldown = this.getAttackCooldown();
    const wx = pointer.worldX, wy = pointer.worldY, range = 55 * (this._classAttackRangeMul || 1);
    this.player.setTexture('player_attack');
    this.time.delayedCall(150, () => { if(this.player.active) this.player.setTexture('player'); });
    let hit = false;
    this.animals.getChildren().forEach(a => {
      if (!a.active) return;
      if (Phaser.Math.Distance.Between(wx, wy, a.x, a.y) < range) { this.damageAnimal(a, Math.round(this.playerDamage * (this.streakBuff?.dmgMul || 1))); hit = true; }
    });
    this.resourceNodes.forEach(n => {
      if (n.depleted) return;
      if (Phaser.Math.Distance.Between(wx, wy, n.x, n.y) < range) { this.harvestNode(n); hit = true; }
    });
    if(hit){playSlash();this.cameras.main.shake(60,0.003);}else playWhiff();
    this.showAttackFX(wx, wy, hit);
  }

  performAttackNearest() {
    if (this.attackCooldown > 0) return;
    const range = 55 * (this._classAttackRangeMul || 1);
    // Multi-hit: find N nearest
    const nearAnimals = [];
    this.animals.getChildren().forEach(a => {
      if (!a.active) return;
      const d = Phaser.Math.Distance.Between(this.player.x, this.player.y, a.x, a.y);
      if (d < range) nearAnimals.push({ a, d });
    });
    nearAnimals.sort((a, b) => a.d - b.d);
    let best = nearAnimals.length > 0 ? nearAnimals[0].a : null;
    let bestD = nearAnimals.length > 0 ? nearAnimals[0].d : Infinity;
    let bestNode = null, bestND = Infinity;
    this.resourceNodes.forEach(n => {
      if (n.depleted) return;
      const d = Phaser.Math.Distance.Between(this.player.x, this.player.y, n.x, n.y);
      if (d < range && d < bestND) { bestNode = n; bestND = d; }
    });
    this.attackCooldown = this.getAttackCooldown();
    this.player.setTexture('player_attack');
    this.time.delayedCall(150, () => { if(this.player.active) this.player.setTexture('player'); });
    if (best && bestD <= bestND) {
      // Multi-hit (mage: pierce all)
      const hitCount = (this._playerClass === 'mage') ? nearAnimals.length : Math.min(this.upgradeManager.multiHitCount, nearAnimals.length);
      for (let h = 0; h < hitCount; h++) {
        this.damageAnimal(nearAnimals[h].a, Math.round(this.playerDamage * (this.streakBuff?.dmgMul || 1)));
        this.showAttackFX(nearAnimals[h].a.x, nearAnimals[h].a.y, true);
      }
      this.upgradeManager.attackCounter++; // Increment attack counter for successful hit
      playSlash();
      this.cameras.main.shake(60, 0.004);
    } else if (bestNode) {
      this.harvestNode(bestNode);
      this.upgradeManager.attackCounter++; // Increment attack counter for successful hit
      this.showAttackFX(bestNode.x, bestNode.y, true);
    } else {
      playWhiff();
      const dx = this.moveDir.x || (this.facingRight ? 1 : -1);
      this.showAttackFX(this.player.x + dx*40, this.player.y + (this.moveDir.y||0)*40, false);
    }
  }

  getAttackCooldown() {
    let cd = this.baseAttackSpeed;
    if (this._nearCampfire) cd /= (this._campfireAttackBonus || 1);
    cd *= this.upgradeManager.cooldownReduction;

    // SWIFT_STRIKE Lvl 2: instant cooldown every 3rd attack
    if (this.upgradeManager.getLevel('SWIFT_STRIKE') >= 2 &&
        this.upgradeManager.attackCounter > 0 &&
        this.upgradeManager.attackCounter % 3 === 0) {
      return 0; // Instant cooldown
    }
    // SWIFT_STRIKE Lvl 1 (or initial Lvl 2 bonus): 50% reduced cooldown for the next attack
    else if (this.upgradeManager.swiftStrikeActive && !this.upgradeManager.swiftStrikeApplied) {
      cd *= 0.5;
      this.upgradeManager.swiftStrikeApplied = true;
    }
    // Adrenaline: +50% attack speed when HP <= 30%
    if (this._adrenalineActive) cd *= 0.5;
    return cd;
  }

  damageAnimal(a, dmg) {
    if (!a || !a.active) return;
    // Hunter Sniper passive: distance-based damage
    if (this._playerClass === 'hunter' && this.player && this.player.active) {
      const dist = Phaser.Math.Distance.Between(this.player.x, this.player.y, a.x, a.y);
      if (dist >= 100) { dmg = Math.round(dmg * 1.5); this._hunterSniperHits = (this._hunterSniperHits || 0) + 1; }
      else if (dist <= 50) { dmg = Math.round(dmg * 0.7); }
    }
    // Hunter Poison DoT
    if (this._playerClass === 'hunter' && this.upgradeManager._classHunterPoison) {
      if (!a._poisonStacks) a._poisonStacks = [];
      a._poisonStacks.push({ dmgPerSec: 10, remaining: 5 });
    }
    // Warrior rage mode: 1.5x damage when HP <= 50%
    if (this._warriorRageActive) dmg = Math.round(dmg * 1.5);
    // Shaman: Nature's Blessing +15% damage near campfire
    if (this._natureBlessing) dmg = Math.round(dmg * 1.15);
    // Shield Bash: stun on ready
    if (this.upgradeManager.shieldBashReady && a.body) {
      this.upgradeManager.shieldBashReady = false;
      a.body.setVelocity(0, 0); a.body.moves = false;
      this.showFloatingText(a.x, a.y - 30, 'üõ°Ô∏èÏä§ÌÑ¥!', '#FFD700');
      this.time.delayedCall(500, () => { if (a.active) a.body.moves = true; });
    }
    // Equipment attack bonus
    if (this._equipBonuses && this._equipBonuses.atkMul > 0) {
      dmg = Math.round(dmg * (1 + this._equipBonuses.atkMul));
    }
    // Critical hit check (base 5%, mage 10%, luck bonus)
    let critChance = this.upgradeManager.critChance > 0 ? this.upgradeManager.critChance : 0.05;
    if (this._playerClass === 'mage') critChance = Math.max(critChance, 0.10);
    if (this._equipBonuses && this._equipBonuses.luckFlat) critChance += this._equipBonuses.luckFlat * 0.001;
    if (Math.random() < critChance) {
      dmg = Math.ceil(dmg * 2);
      a._lastHitCrit = true;
      this.showFloatingText(a.x + 15, a.y - 30, 'üí•CRITICAL!', '#FFD700');
      if (this._questProgress) this._questProgress.critical_hits++;
      this._hitStop(120); playCriticalHit(); // strong hitstop for crits
      // ‚ïê‚ïê‚ïê CRIT! yellow text effect ‚ïê‚ïê‚ïê
      const critText = this.add.text(a.x, a.y - 50, 'CRIT!', {
        fontSize: '36px', fontFamily: 'monospace', color: '#FFFF00',
        stroke: '#FF8800', strokeThickness: 5, fontStyle: 'bold'
      }).setDepth(20).setOrigin(0.5).setScale(0.3).setAlpha(0);
      this.tweens.add({ targets: critText, scale: 1.8, alpha: 1, duration: 150, ease: 'Back.Out',
        onComplete: () => this.tweens.add({ targets: critText, scale: 1, alpha: 0, y: critText.y - 40,
          duration: 500, onComplete: () => critText.destroy() }) });
    }
    const isCrit = a._lastHitCrit || false; a._lastHitCrit = false;
    // Boss hitstop (every 5th hit to avoid annoyance)
    if (a.isBoss && !isCrit) {
      a._hitCount = (a._hitCount || 0) + 1;
      if (a._hitCount % 5 === 1) this._hitStop(80);
    }
    if (a.hp == null) a.hp = 0;
    // SHAMAN_HUNTER: +30% damage per level vs blizzard_shaman
    if (a.animalType === 'blizzard_shaman' && this.upgradeManager._shamanHunterLevel > 0) {
      dmg = Math.round(dmg * (1 + this.upgradeManager._shamanHunterLevel * 0.3));
    }
    // GLACIAL_WALL: +15% defense near ice walls
    // (applied as damage reduction to incoming enemy attacks in enemy attack section instead)
    a.hp -= dmg; a.hitFlash = 0.2; a.setTint(0xFF4444); playHitEnemy(a.isBoss?'boss':a._isElite?'elite':'normal');
    if (a.isBoss && this._questProgress) this._questProgress.boss_damage_dealt += dmg;
    const fs = isCrit ? '28px' : dmg >= 3 ? '20px' : '16px';
    const c = isCrit ? '#FF2222' : '#FFFFFF';
    const t = this.add.text(a.x + Phaser.Math.Between(-10, 10), a.y - 20, '-'+dmg, {
      fontSize: fs, fontFamily: 'monospace', color: c, stroke: '#000', strokeThickness: 3, fontStyle: 'bold'
    }).setDepth(15).setOrigin(0.5);
    this.tweens.add({ targets: t, y: t.y - 40, alpha: 0, scale: { from: 1.3, to: 0.8 },
      duration: 600, ease: 'Back.Out', onComplete: () => t.destroy() });
    const ang = Phaser.Math.Angle.Between(this.player.x, this.player.y, a.x, a.y);
    const kb = 120 + this.upgradeManager.knockbackBonus;
    if (a.body) a.body.setVelocity(Math.cos(ang) * kb, Math.sin(ang) * kb);
    const pCount = isCrit ? 10 : 5;
    const pColor = isCrit ? 0xFF8800 : null;
    for (let i = 0; i < pCount; i++) {
      const p = this.getParticle(a.x, a.y, 'hit_particle');
      p.setScale(Phaser.Math.FloatBetween(0.5, isCrit ? 1.8 : 1.2));
      if (pColor) p.setTint(pColor);
      this.tweens.add({ targets: p, x: a.x + Phaser.Math.Between(-40, 40), y: a.y + Phaser.Math.Between(-40, 40),
        alpha: 0, scale: 0, duration: isCrit ? 400 : 300, onComplete: () => this.returnParticle(p) });
    }
    // White flash on knockback
    const whiteFlash = this.add.circle(a.x, a.y, 12, 0xFFFFFF, 0.7).setDepth(15);
    this.tweens.add({ targets: whiteFlash, scale: 2, alpha: 0, duration: 150, onComplete: () => whiteFlash.destroy() });
    // Life Steal %
    if (this.upgradeManager.lifeStealPct > 0) {
      const heal = Math.ceil(dmg * this.upgradeManager.lifeStealPct);
      this.playerHP = Math.min(this.playerMaxHP, this.playerHP + heal);
    }
    // Chain Lightning
    if (this.upgradeManager.chainLightningLevel > 0 && !a._chainSource) {
      const chainDmg = Math.round(dmg * 0.3);
      const chainCount = this.upgradeManager.chainLightningLevel;
      let chained = 0;
      this.animals.getChildren().forEach(b => {
        if (!b.active || b === a || chained >= chainCount) return;
        if (Phaser.Math.Distance.Between(a.x, a.y, b.x, b.y) < 120) {
          b._chainSource = true;
          this.damageAnimal(b, chainDmg);
          delete b._chainSource;
          this.showFloatingText(b.x, b.y - 30, '‚ö°', '#FFFF00');
          chained++;
        }
      });
    }
    // Double Shot
    if (this.upgradeManager.doubleShotChance > 0 && !a._doubleShot && Math.random() < this.upgradeManager.doubleShotChance) {
      a._doubleShot = true;
      this.time.delayedCall(100, () => { if (a.active) { this.damageAnimal(a, dmg); delete a._doubleShot; } });
    }
    if (a.hp <= 0) this.killAnimal(a);
  }

  killAnimal(a) { if (!a || !a.active) return; playKill(); this._hitStop(40); // kill hitstop
    // ‚ïê‚ïê‚ïê Type-specific death effects ‚ïê‚ïê‚ïê
    if (a.animalType === 'ice_golem') {
      // Ice shard explosion + shockwave
      const sw = this.add.circle(a.x, a.y, 10, 0x88CCFF, 0.6).setDepth(15);
      this.tweens.add({ targets: sw, scale: 8, alpha: 0, duration: 500, onComplete: () => sw.destroy() });
      for (let i = 0; i < 12; i++) {
        const sa = Phaser.Math.FloatBetween(0, Math.PI * 2);
        const sd = Phaser.Math.Between(20, 80);
        const shard = this.add.rectangle(a.x, a.y, Phaser.Math.Between(3, 8), Phaser.Math.Between(6, 14), 0xAADDFF).setDepth(15).setAlpha(0.9).setAngle(Phaser.Math.Between(0, 360));
        this.tweens.add({ targets: shard, x: a.x + Math.cos(sa)*sd, y: a.y + Math.sin(sa)*sd, alpha: 0, angle: shard.angle + 180, duration: 600, onComplete: () => shard.destroy() });
      }
      // Damage nearby player
      const pdist = Phaser.Math.Distance.Between(a.x, a.y, this.player.x, this.player.y);
      if (pdist < 80) {
        this.playerHP -= 10;
        this.showFloatingText(this.player.x, this.player.y - 25, 'üßä-10 ÌååÌé∏!', '#88CCFF');
        // Apply slow
        if (!this._iceGolemSlowed) {
          this._iceGolemSlowed = true;
          const origSpeed = this.playerSpeed;
          this.playerSpeed *= 0.5;
          this.time.delayedCall(1000, () => { this.playerSpeed = Math.max(this.playerSpeed, origSpeed); this._iceGolemSlowed = false; });
        }
        if (this.playerHP <= 0) this.endGame();
      }
    } else if (a.animalType === 'snow_leopard') {
      // White flash + fast disappear
      for (let i = 0; i < 8; i++) {
        const sa = Phaser.Math.FloatBetween(0, Math.PI * 2);
        const p = this.add.circle(a.x, a.y, Phaser.Math.Between(2, 4), 0xFFFFFF).setDepth(15);
        this.tweens.add({ targets: p, x: a.x + Math.cos(sa)*40, y: a.y + Math.sin(sa)*40, alpha: 0, duration: 250, onComplete: () => p.destroy() });
      }
    } else if (a.animalType === 'rabbit') {
      // Small white fur particles
      for (let i = 0; i < 5; i++) {
        const sa = Phaser.Math.FloatBetween(0, Math.PI * 2);
        const p = this.add.circle(a.x, a.y, 2, 0xFFEEDD).setDepth(15);
        this.tweens.add({ targets: p, x: a.x + Math.cos(sa)*25, y: a.y + Math.sin(sa)*25, alpha: 0, duration: 500, onComplete: () => p.destroy() });
      }
    } else if (a.animalType === 'wolf') {
      // Gray particles + howl text
      for (let i = 0; i < 6; i++) {
        const sa = Phaser.Math.FloatBetween(0, Math.PI * 2);
        const p = this.add.circle(a.x, a.y, 3, 0x666677).setDepth(15);
        this.tweens.add({ targets: p, x: a.x + Math.cos(sa)*35, y: a.y + Math.sin(sa)*35, alpha: 0, duration: 500, onComplete: () => p.destroy() });
      }
      const howl = this.add.text(a.x, a.y - 15, 'üê∫ Awooo~', { fontSize: '12px', fontFamily: 'monospace', color: '#AAAACC', stroke: '#000', strokeThickness: 2 }).setDepth(15).setOrigin(0.5);
      this.tweens.add({ targets: howl, y: howl.y - 25, alpha: 0, duration: 500, onComplete: () => howl.destroy() });
    } else if (a.animalType === 'ice_hunter') {
      // Blue particles + ice crystal effect
      for (let i = 0; i < 8; i++) {
        const sa = Phaser.Math.FloatBetween(0, Math.PI * 2);
        const sd = Phaser.Math.Between(20, 60);
        const p = this.add.circle(a.x, a.y, Phaser.Math.Between(2, 5), 0x44AAFF).setDepth(15);
        this.tweens.add({ targets: p, x: a.x + Math.cos(sa)*sd, y: a.y + Math.sin(sa)*sd, alpha: 0, duration: 500, onComplete: () => p.destroy() });
      }
      // Ice crystal shatter
      for (let i = 0; i < 4; i++) {
        const sa = Phaser.Math.FloatBetween(0, Math.PI * 2);
        const cr = this.add.rectangle(a.x, a.y, 4, 10, 0x88DDFF).setDepth(15).setAngle(Phaser.Math.Between(0, 360));
        this.tweens.add({ targets: cr, x: a.x + Math.cos(sa)*40, y: a.y + Math.sin(sa)*40, alpha: 0, angle: cr.angle + 90, duration: 600, onComplete: () => cr.destroy() });
      }
    } else if (a.animalType === 'splitting_slime' && !a._isMiniSlime) {
      // Spawn 2 mini slimes
      for (let i = 0; i < 2; i++) {
        const ox = (i === 0 ? -15 : 15);
        const mini = this.physics.add.sprite(a.x + ox, a.y, 'mini_slime').setCollideWorldBounds(true).setDepth(5);
        mini.animalType = 'splitting_slime';
        mini._isMiniSlime = true;
        const miniDef = { ...ANIMALS.splitting_slime, hp: Math.round(ANIMALS.splitting_slime.hp * 0.3), size: 12, name: 'üíß ÎØ∏ÎãàÏä¨ÎùºÏûÑ' };
        mini.def = miniDef;
        this._applyDifficultyToAnimal(mini, miniDef);
        mini.setScale(0.5);
        mini.wanderTimer = 0; mini.wanderDir = {x:0,y:0}; mini.hitFlash = 0; mini.atkCD = 0; mini.fleeTimer = 0;
        mini.hpBar = this.add.graphics().setDepth(6);
        mini.nameLabel = this.add.text(mini.x, mini.y - 10, miniDef.name, {
          fontSize: '9px', fontFamily: 'monospace', color: '#FF4444', stroke: '#000', strokeThickness: 3
        }).setDepth(6).setOrigin(0.5);
        this.animals.add(mini);
      }
      // Green splatter
      for (let i = 0; i < 10; i++) {
        const sa = Phaser.Math.FloatBetween(0, Math.PI * 2);
        const p = this.add.circle(a.x, a.y, Phaser.Math.Between(3, 6), 0x44CC44).setDepth(15);
        this.tweens.add({ targets: p, x: a.x + Math.cos(sa)*50, y: a.y + Math.sin(sa)*50, alpha: 0, duration: 600, onComplete: () => p.destroy() });
      }
      this.showFloatingText(a.x, a.y - 20, 'üí• Î∂ÑÏó¥!', '#44CC44');
      // SPLIT_EXPLOSION: mini slimes explode on spawn dealing area damage
      if (this.upgradeManager._splitExplosionLevel > 0) {
        const explodeDmg = 15 * this.upgradeManager._splitExplosionLevel;
        this.animals.getChildren().forEach(e => {
          if (!e.active || e === a) return;
          const ed = Phaser.Math.Distance.Between(a.x, a.y, e.x, e.y);
          if (ed < 50) {
            e.hp -= explodeDmg;
            this.showFloatingText(e.x, e.y - 15, 'üí•' + explodeDmg, '#FF6600');
          }
        });
      }
    } else if (a.animalType === 'splitting_slime' && a._isMiniSlime) {
      // Small green puff
      for (let i = 0; i < 4; i++) {
        const sa = Phaser.Math.FloatBetween(0, Math.PI * 2);
        const p = this.add.circle(a.x, a.y, 2, 0x88EE88).setDepth(15);
        this.tweens.add({ targets: p, x: a.x + Math.cos(sa)*20, y: a.y + Math.sin(sa)*20, alpha: 0, duration: 400, onComplete: () => p.destroy() });
      }
    } else if (a.animalType === 'blizzard_shaman') {
      // Remove buffs from nearby enemies
      this.animals.getChildren().forEach(b => {
        if (b._shamanBuffed && b._shamanBuffSource === a) {
          b._shamanBuffed = false;
          b._shamanBuffSource = null;
        }
      });
      // Purple explosion
      const sw = this.add.circle(a.x, a.y, 10, 0xAA55FF, 0.5).setDepth(15);
      this.tweens.add({ targets: sw, scale: 5, alpha: 0, duration: 600, onComplete: () => sw.destroy() });
      for (let i = 0; i < 8; i++) {
        const sa = Phaser.Math.FloatBetween(0, Math.PI * 2);
        const p = this.add.star(a.x, a.y, 5, 2, 5, 0xCC88FF).setDepth(15);
        this.tweens.add({ targets: p, x: a.x + Math.cos(sa)*50, y: a.y + Math.sin(sa)*50, alpha: 0, angle: 180, duration: 700, onComplete: () => p.destroy() });
      }
      this.showFloatingText(a.x, a.y - 20, 'üîÆ ÏÉ§Î®º Ï≤òÏπò!', '#AA55FF');
    } else if (a.animalType === 'bear') {
      // Brown big particle explosion
      for (let i = 0; i < 14; i++) {
        const sa = Phaser.Math.FloatBetween(0, Math.PI * 2);
        const sd = Phaser.Math.Between(30, 80);
        const p = this.add.circle(a.x, a.y, Phaser.Math.Between(3, 7), 0x8B6914).setDepth(15);
        this.tweens.add({ targets: p, x: a.x + Math.cos(sa)*sd, y: a.y + Math.sin(sa)*sd, alpha: 0, scale: { from: 1.3, to: 0 }, duration: 700, onComplete: () => p.destroy() });
      }
    } else {
    // ‚ïê‚ïê‚ïê Default death particle effect (circles spreading) ‚ïê‚ïê‚ïê
    for (let i = 0; i < 10; i++) {
      const ang = Phaser.Math.FloatBetween(0, Math.PI * 2);
      const dist = Phaser.Math.Between(30, 70);
      const colors = [0xFFFFFF, 0xCCDDFF, 0xFF8888, 0xFFCC44];
      const p = this.add.circle(a.x, a.y, Phaser.Math.Between(2, 5), Phaser.Utils.Array.GetRandom(colors))
        .setDepth(15).setAlpha(1);
      this.tweens.add({ targets: p,
        x: a.x + Math.cos(ang) * dist, y: a.y + Math.sin(ang) * dist,
        alpha: 0, scale: { from: 1.2, to: 0 }, duration: Phaser.Math.Between(400, 800),
        ease: 'Quad.Out', onComplete: () => p.destroy() });
    }
    }
    // Miniboss death: custom message + XP
    if (a.isMiniboss && a._minibossKillMsg) {
      this.cameras.main.shake(600, 0.02);
      this.cameras.main.flash(400, 255, 200, 50, true);
      if (a._minibossXP) this.gainXP(a._minibossXP);
      const mbText = this.add.text(this.cameras.main.centerX, this.cameras.main.centerY - 80,
        a._minibossKillMsg, {
        fontSize: '28px', fontFamily: 'monospace', color: '#FFD700',
        stroke: '#000', strokeThickness: 5, fontStyle: 'bold'
      }).setOrigin(0.5).setDepth(100).setScrollFactor(0);
      this.tweens.add({ targets: mbText, y: mbText.y - 50, alpha: 0, scale: { from: 1.2, to: 0.5 },
        duration: 3000, ease: 'Quad.Out', onComplete: () => mbText.destroy() });
    }
    // Boss death special effects
    if (a.isBoss && !a.isMiniboss) {
      playBossDefeated();
      this.bossKillCount = (this.bossKillCount || 0) + 1;
      this.stats.bossKills = (this.stats.bossKills || 0) + 1;
      // Speedrun mode: track boss kills for win condition
      if (this._speedrunMode && !this._speedrunCleared) {
        this._speedrunBossKills = (this._speedrunBossKills || 0) + 1;
        if (this._speedrunBossKills >= 2) {
          this._speedrunCleared = true;
          this._triggerSpeedrunVictory();
        }
      }
      // Boss Rush mode: handle wave completion
      if (this._bossRushMode && a._bossRushWaveIdx != null) {
        this._onBossRushBossKilled(a._bossRushWaveIdx);
      }
      // Hidden boss kill check
      if (a.isHiddenBoss) { this._onHiddenBossKilled(); }
      this.cameras.main.shake(800, 0.03);
      this.cameras.main.flash(500, 255, 50, 50, true);
      const bossText = this.add.text(this.cameras.main.centerX, this.cameras.main.centerY - 80,
        'üèÜ Î≥¥Ïä§ Ï≤òÏπò!', {
        fontSize: '52px', fontFamily: 'monospace', color: '#FF4444',
        stroke: '#000', strokeThickness: 6, fontStyle: 'bold'
      }).setOrigin(0.5).setDepth(100).setScrollFactor(0);
      this.tweens.add({ targets: bossText, y: bossText.y - 50, alpha: 0, scale: { from: 1.3, to: 0.5 },
        duration: 2500, ease: 'Quad.Out', onComplete: () => bossText.destroy() });
      // Burst particles for boss loot
      for (let i = 0; i < 24; i++) {
        const ang = Phaser.Math.FloatBetween(0, Math.PI * 2);
        const dist = Phaser.Math.Between(20, 60);
        const colors = [0xFFD700, 0xFF4444, 0xFF8800, 0xFFFFFF];
        const p = this.add.circle(a.x, a.y, Phaser.Math.Between(3, 6), Phaser.Utils.Array.GetRandom(colors))
          .setDepth(15).setAlpha(1);
        this.tweens.add({ targets: p,
          x: a.x + Math.cos(ang) * dist * 2, y: a.y + Math.sin(ang) * dist * 2,
          alpha: 0, scale: { from: 1.5, to: 0 }, duration: Phaser.Math.Between(600, 1200),
          ease: 'Quad.Out', onComplete: () => p.destroy() });
      }
      // 25min boss: guaranteed rare+ equipment drop
      if (a.isFirstBoss) {
        const luck = (this._equipBonuses ? this._equipBonuses.luckFlat : 0);
        // Force rare or better grade
        const grades = ['rare', 'epic', 'legendary'];
        const grade = grades[Math.floor(Math.random() * grades.length)];
        const slots = Object.keys(EQUIPMENT_TABLE);
        const slot = slots[Math.floor(Math.random() * slots.length)];
        const items = EQUIPMENT_TABLE[slot];
        const item = items[Math.floor(Math.random() * items.length)];
        const drop = { slot, grade, ...item };
        const color = EQUIP_GRADE_COLORS[grade];
        const label = this.add.text(a.x, a.y - 10, drop.icon + ' ' + drop.name, {
          fontSize: '14px', fontFamily: 'monospace', color: color,
          stroke: '#000', strokeThickness: 3, fontStyle: 'bold'
        }).setDepth(15).setOrigin(0.5);
        const glow = this.add.circle(a.x, a.y, 14, Phaser.Display.Color.HexStringToColor(color).color, 0.4).setDepth(8);
        this.tweens.add({ targets: glow, scale: { from: 0.5, to: 1.5 }, alpha: { from: 0.6, to: 0.2 }, yoyo: true, repeat: -1, duration: 800 });
        this.tweens.add({ targets: label, y: label.y - 8, yoyo: true, repeat: -1, duration: 1000, ease: 'Sine.InOut' });
        this.equipmentDrops.push({ x: a.x, y: a.y, ...drop, label, glow, lifetime: 30 });
        this.showCenterAlert('‚öóÔ∏è Ìù¨Í∑Ä Ïû•ÎπÑ ÎìúÎ°≠ ÌôïÏ†ï!', '#2196F3');
      }
    }
    // ‚ïê‚ïê‚ïê Í≥†Í∏∞ ÎìúÎûç ÏãúÏä§ÌÖú (ÌôïÎ•† Í∏∞Î∞ò) ‚ïê‚ïê‚ïê
    const meatDropChance = { rabbit: 0.3, deer: 0.5, wolf: 0.7, bear: 1.0, ice_hunter: 0.6, splitting_slime: 0.5, blizzard_shaman: 0.4 };
    const dropChance = meatDropChance[a.animalType] || 0;
    if (dropChance > 0 && Math.random() < dropChance) {
      this.stats.meatCollected = (this.stats.meatCollected || 0) + 1;
    }

    const def = a.def || ANIMALS[a.animalType] || { name: '?', drops: {}, hp: 1 };
    const lootMul = 1 + (this.upgradeManager ? this.upgradeManager.lootBonus || 0 : 0);
    Object.entries(def.drops || {}).forEach(([res, amt]) => {
      const finalAmt = Math.floor(amt * lootMul) + (Math.random() < (amt * lootMul) % 1 ? 1 : 0);
      for (let i = 0; i < finalAmt; i++) {
        const ang = Phaser.Math.FloatBetween(0, Math.PI*2), dist = Phaser.Math.Between(15, 40);
        this.spawnDrop(res, a.x + Math.cos(ang)*dist, a.y + Math.sin(ang)*dist, a.x, a.y);
      }
    });
    if (!this.stats.kills[a.animalType]) this.stats.kills[a.animalType] = 0;
    this.stats.kills[a.animalType]++;
    // ‚ïê‚ïê‚ïê Buff item drop chance ‚ïê‚ïê‚ïê
    this._tryDropBuff(a.x, a.y);

    // ‚ïê‚ïê‚ïê Equipment drop chance ‚ïê‚ïê‚ïê
    this._tryDropEquipment(a.x, a.y);

    // ‚ïê‚ïê‚ïê Kill Combo ‚ïê‚ïê‚ïê
    this.killCombo++;
    this.killComboTimer = 3; // 3 seconds to maintain combo
    if (this.killCombo > (this.stats.maxCombo || 0)) this.stats.maxCombo = this.killCombo;
    this._updateComboDisplay();
    // Secret event: snow leopard pack trigger
    this.onEnemyKilled_secretCheck();
    this._applyStreakBuff(a.x, a.y);

    // XP gain on kill with combo bonus
    let _xpAmt = XP_SOURCES[a.animalType] || 3;
    if (a._isElite) _xpAmt *= 2; // Elite wave: double XP
    let _comboGoldBonus = 0;
    if (this.killCombo >= 10) {
      _xpAmt = Math.floor(_xpAmt * 2); // +100% XP
      _comboGoldBonus = 1;
    }
    if (this.killCombo >= 5) {
      _comboGoldBonus = 1; // gold +50% handled in drop
    }
    // SPLIT_EXPLOSION: +50% XP per level for splitting slimes
    if (a.animalType === 'splitting_slime' && this.upgradeManager._splitExplosionLevel > 0) {
      _xpAmt = Math.floor(_xpAmt * (1 + this.upgradeManager._splitExplosionLevel * 0.5));
    }
    this.gainXP(_xpAmt);
    this.showFloatingText(a.x + 15, a.y - 30, '+' + _xpAmt + ' XP' + (this.killCombo >= 10 ? ' üî•x2' : ''), '#44AAFF');
    // SHAMAN_HUNTER: HP+15 on shaman kill
    if (a.animalType === 'blizzard_shaman' && this.upgradeManager._shamanHunterLevel > 0) {
      const shamanHeal = 15;
      this.playerHP = Math.min(this.playerMaxHP, this.playerHP + shamanHeal);
      this.showFloatingText(a.x, a.y - 40, 'üîÆ HP+' + shamanHeal, '#AA55FF');
    }

    // ‚ïê‚ïê‚ïê Class Kill Passives ‚ïê‚ïê‚ïê
    if (this._playerClass === 'warrior') {
      // 5% chance HP+2
      if (Math.random() < 0.05) {
        this.playerHP = Math.min(this.playerMaxHP, this.playerHP + 2);
        this.showFloatingText(this.player.x, this.player.y - 30, 'ü™ì+2 HP', '#FF8888');
      }
    }
    if (this._playerClass === 'mage') {
      // 10% ice explosion on kill
      if (Math.random() < 0.10) {
        const iceR = 80;
        const iceVfx = this.add.circle(a.x, a.y, 10, 0x88CCFF, 0.6).setDepth(15);
        this.tweens.add({ targets: iceVfx, scale: iceR/10, alpha: 0, duration: 400, onComplete: () => iceVfx.destroy() });
        this.showFloatingText(a.x, a.y - 20, 'üßä ÏñºÏùå Ìè≠Î∞ú!', '#88CCFF');
        this.animals.getChildren().forEach(b => {
          if (!b.active || b === a) return;
          if (Phaser.Math.Distance.Between(a.x, a.y, b.x, b.y) < iceR) {
            b.body.setVelocity(0, 0); b.body.moves = false; b.setTint(0x88CCFF);
            this.time.delayedCall(3000, () => { if (b.active) { b.body.moves = true; b.clearTint(); } });
          }
        });
      }
    }

    // ‚ïê‚ïê‚ïê Hunter: no specific kill passive (passives are sniper + traps) ‚ïê‚ïê‚ïê

    // ‚ïê‚ïê‚ïê Shaman: Soul Harvest (10% chance spirit orb on kill) ‚ïê‚ïê‚ïê
    if (this._playerClass === 'shaman') {
      if (Math.random() < 0.10 && this._spiritOrbs.length < 10) {
        const orb = this.add.circle(a.x, a.y, 8, 0x4488FF, 0.7).setDepth(15);
        this.tweens.add({ targets: orb, scale: { from: 0.8, to: 1.2 }, alpha: { from: 0.5, to: 0.9 }, yoyo: true, repeat: -1, duration: 600 });
        const glow = this.add.circle(a.x, a.y, 14, 0x4488FF, 0.2).setDepth(14);
        this.tweens.add({ targets: glow, scale: { from: 0.8, to: 1.5 }, alpha: { from: 0.3, to: 0.1 }, yoyo: true, repeat: -1, duration: 800 });
        this._spiritOrbs.push({ x: a.x, y: a.y, lifetime: 10, orb, glow });
        this.showFloatingText(a.x, a.y - 20, 'üîÆ ÏòÅÌòº Íµ¨Ïä¨!', '#4488FF');
      }
    }

    // Combo gold bonus drops
    if (this.killCombo >= 5) {
      const bonusGold = Math.max(1, Math.floor((a.def.drops.gold || 0) * 0.5));
      if (bonusGold > 0) {
        for (let i = 0; i < bonusGold; i++) {
          const cAng = Phaser.Math.FloatBetween(0, Math.PI*2);
          this.spawnDrop('gold', a.x + Math.cos(cAng)*20, a.y + Math.sin(cAng)*20, a.x, a.y);
        }
        this.showFloatingText(a.x - 15, a.y - 45, '+' + bonusGold + 'üí∞ ÏΩ§Î≥¥!', '#FFD700');
      }
    }

    // Combo 5+ particle burst
    if (this.killCombo >= 5 && this.killCombo < 10) {
      for (let i = 0; i < 6; i++) {
        const cAng = (Math.PI*2/6)*i;
        const cp = this.add.circle(a.x, a.y, 3, 0xFFD700).setDepth(15).setAlpha(0.8);
        this.tweens.add({ targets: cp, x: a.x+Math.cos(cAng)*35, y: a.y+Math.sin(cAng)*35,
          alpha: 0, scale: {from:1.2,to:0}, duration: 500, onComplete:()=>cp.destroy() });
      }
    }
    // Combo 10+ special effect
    if (this.killCombo >= 10) {
      this.cameras.main.flash(150, 255, 100, 0, true);
      for (let i = 0; i < 12; i++) {
        const cAng = (Math.PI*2/12)*i;
        const colors = [0xFF4400, 0xFFAA00, 0xFFDD00];
        const cp = this.add.circle(a.x, a.y, 4, Phaser.Utils.Array.GetRandom(colors)).setDepth(15);
        this.tweens.add({ targets: cp, x: a.x+Math.cos(cAng)*50, y: a.y+Math.sin(cAng)*50,
          alpha: 0, scale: {from:2,to:0}, duration: 700, ease:'Quad.Out', onComplete:()=>cp.destroy() });
      }
    }
    if (this.upgradeManager.explosionLevel > 0) this.triggerExplosion(a.x, a.y);
    if (this.upgradeManager.lifestealAmount > 0) {
      this.playerHP = Math.min(this.playerMaxHP, this.playerHP + this.upgradeManager.lifestealAmount);
      this.showFloatingText(a.x, a.y - 10, '+' + this.upgradeManager.lifestealAmount + '‚ù§Ô∏è', '#FF8888');
    }
    // ‚ïê‚ïê‚ïê Color-coded death particles: normal=white, elite=orange, boss=red ‚ïê‚ïê‚ïê
    const _deathColor = a.isBoss ? 0xFF2222 : a._isElite ? 0xFF8800 : 0xFFFFFF;
    const _deathColors = a.isBoss ? [0xFF0000, 0xFF4444, 0xFF6666, 0xFFAAAA]
      : a._isElite ? [0xFF8800, 0xFFAA00, 0xFFCC44, 0xFFDD88]
      : [0xFFFFFF, 0xDDEEFF, 0xCCDDFF, 0xAABBDD];
    const _deathCount = a.isBoss ? 16 : a._isElite ? 12 : 8;
    for (let i = 0; i < _deathCount; i++) {
      const _dc = Phaser.Utils.Array.GetRandom(_deathColors);
      const _sz = Phaser.Math.FloatBetween(0.8, a.isBoss ? 2.5 : 1.5);
      const p = this.add.circle(a.x, a.y, 4, _dc).setDepth(15).setScale(_sz).setAlpha(0.9);
      this.tweens.add({ targets: p, x: a.x + Phaser.Math.Between(-50, 50), y: a.y + Phaser.Math.Between(-50, 50),
        alpha: 0, scale: 0, duration: 400 + Math.random() * 200, ease: 'Quad.Out', onComplete: () => p.destroy() });
    }
    const kt = this.add.text(a.x, a.y - 25, 'üíÄ ' + def.name, {
      fontSize: '14px', fontFamily: 'monospace', color: '#FFDD44', stroke: '#000', strokeThickness: 3
    }).setDepth(15).setOrigin(0.5).setScale(0.3);
    // ‚ïê‚ïê‚ïê Kill text pop animation ‚ïê‚ïê‚ïê
    this.tweens.add({ targets: kt, scale: 1.3, duration: 120, ease: 'Back.Out',
      onComplete: () => this.tweens.add({ targets: kt, scale: 1, y: kt.y - 30, alpha: 0, duration: 700, onComplete: () => kt.destroy() }) });
    if (a.hpBar) a.hpBar.destroy();
    if (a.nameLabel) a.nameLabel.destroy();
    a.destroy();
  }

  // ‚ïê‚ïê‚ïê Kill Combo Display ‚ïê‚ïê‚ïê
  _updateComboDisplay() {
    if (this.killCombo < 2) {
      if (this.killComboText) { this.killComboText.destroy(); this.killComboText = null; }
      return;
    }
    const comboStr = this.killCombo >= 20
      ? `üí• ${this.killCombo}x COMBO! Í¥ëÏ†ÑÏÇ¨ Î™®Îìú!`
      : `üî• ${this.killCombo}x COMBO` + (this.killCombo >= 10 ? ' ¬∑ XP√ó2' : this.killCombo >= 5 ? ' ¬∑ üí∞+50%' : '');
    const color = this.killCombo >= 20 ? '#FF0044' : this.killCombo >= 10 ? '#FF4400' : this.killCombo >= 5 ? '#FFD700' : '#FFDD88';
    const fontSize = this.killCombo >= 20 ? '32px' : this.killCombo >= 10 ? '24px' : '18px';
    if (!this.killComboText) {
      this.killComboText = this.add.text(this.cameras.main.width - 10, 100, comboStr, {
        fontSize, fontFamily: 'monospace', color, stroke: '#000', strokeThickness: 4, fontStyle: 'bold'
      }).setOrigin(1, 0).setDepth(100).setScrollFactor(0);
    } else {
      this.killComboText.setText(comboStr).setColor(color).setFontSize(fontSize);
    }
    // Pulse effect
    this.tweens.add({ targets: this.killComboText, scale: { from: 1.3, to: 1 }, duration: 200 });

    // ‚ïê‚ïê‚ïê Screen shake for 10+ combo ‚ïê‚ïê‚ïê
    if (this.killCombo >= 10) {
      this.cameras.main.shake(100, 0.005 + Math.min(0.01, this.killCombo * 0.001));
    }

    // Big combo milestone popup (10, 20, 30...)
    if (this.killCombo >= 10 && this.killCombo % 10 === 0) {
      const milestoneText = this.killCombo >= 20
        ? `üí• ${this.killCombo} COMBO! Í¥ëÏ†ÑÏÇ¨ Î™®Îìú!`
        : `üî• ${this.killCombo} COMBO!`;
      const milestoneColor = this.killCombo >= 20 ? '#FF0044' : '#FF4400';
      const mt = this.add.text(this.cameras.main.centerX, this.cameras.main.centerY - 60, milestoneText, {
        fontSize: '36px', fontFamily: 'monospace', color: milestoneColor, stroke: '#000', strokeThickness: 6, fontStyle: 'bold'
      }).setScrollFactor(0).setDepth(250).setOrigin(0.5).setAlpha(0);
      this.tweens.add({ targets: mt, alpha: 1, scale: { from: 0.5, to: 1.5 }, duration: 300, ease: 'Back.Out',
        onComplete: () => this.tweens.add({ targets: mt, alpha: 0, y: mt.y - 40, duration: 1200, onComplete: () => mt.destroy() })
      });
      if (this.killCombo >= 20) this.cameras.main.flash(200, 255, 0, 68, true);
    }
    // ‚ïê‚ïê‚ïê Killstreak Drama: RAMPAGE / UNSTOPPABLE / GODLIKE ‚ïê‚ïê‚ïê
    this._updateKillstreakDrama();
  }

  // ‚ïê‚ïê‚ïê Streak Buff System ‚ïê‚ïê‚ïê
  _applyStreakBuff(killX, killY) {
    const c = this.killCombo;
    let newTier = 0;
    let dmgMul = 1, spdMul = 1, timer = 0, label = '', color = '#FFFFFF';
    
    if (c >= 15) {
      newTier = 4; dmgMul = 1.5; spdMul = 1.3; timer = 10;
      label = '‚ò†Ô∏è Ï†ÑÎ©∏!'; color = '#FF0000';
    } else if (c >= 10) {
      newTier = 3; dmgMul = 1.5; spdMul = 1.3; timer = 10;
      label = 'üíÄ ÌïôÏÇ¥Ïûê!'; color = '#FF4400';
    } else if (c >= 5) {
      newTier = 2; dmgMul = 1.3; spdMul = 1; timer = 8;
      label = 'üî• Ïó∞ÏáÑ Ï≤òÏπò!'; color = '#FF8800';
    } else if (c >= 3) {
      newTier = 1; dmgMul = 1; spdMul = 1.15; timer = 8;
      label = '‚ö° ÏæåÏÜç!'; color = '#FFDD00';
    }
    
    if (newTier > 0 && newTier > this.streakBuff.tier) {
      this.streakBuff = { dmgMul, spdMul, timer, tier: newTier };
      
      // Show center alert
      const cam = this.cameras.main;
      const alert = this.add.text(cam.width / 2, cam.height * 0.35, label, {
        fontSize: '32px', fontFamily: 'monospace', color, stroke: '#000', strokeThickness: 6, fontStyle: 'bold'
      }).setScrollFactor(0).setDepth(350).setOrigin(0.5).setAlpha(0);
      this.tweens.add({
        targets: alert, alpha: { from: 0, to: 1 }, y: { from: cam.height * 0.35, to: cam.height * 0.3 },
        duration: 300, ease: 'Back.Out',
        onComplete: () => this.tweens.add({ targets: alert, alpha: 0, duration: 400, delay: 600, onComplete: () => alert.destroy() })
      });
      
      // Visual feedback
      if (newTier >= 3) {
        cam.flash(200, 255, 100, 0, true);
        cam.shake(300, 0.01);
      } else if (newTier >= 2) {
        cam.flash(150, 255, 140, 0, true);
      }
      
      // Area explosion at tier 4+
      if (newTier >= 4 && killX && killY) {
        const radius = 150;
        const toKill = [];
        this.animals.getChildren().forEach(en => {
          if (!en || !en.active) return;
          const dx = en.x - killX, dy = en.y - killY;
          if (Math.sqrt(dx*dx + dy*dy) < radius) {
            const dmg = 50;
            en.hp = (en.hp || 0) - dmg;
            this.showFloatingText(en.x, en.y - 20, `-${dmg}`, '#FF4400');
            if (en.hp <= 0) toKill.push(en);
          }
        });
        toKill.forEach(en => { if (en.active) this.killAnimal(en); });
        // Explosion ring
        for (let i = 0; i < 16; i++) {
          const ang = (Math.PI * 2 / 16) * i;
          const ep = this.add.circle(killX, killY, 5, 0xFF4400).setDepth(15).setAlpha(0.9);
          this.tweens.add({ targets: ep, x: killX + Math.cos(ang)*radius, y: killY + Math.sin(ang)*radius,
            alpha: 0, scale: { from: 2, to: 0 }, duration: 600, ease: 'Quad.Out', onComplete: () => ep.destroy() });
        }
      }
    }
  }
  
  _updateStreakBuff(dt) {
    if (this.streakBuff.timer <= 0) return;
    this.streakBuff.timer -= dt;
    if (this.streakBuff.timer <= 0) {
      this.streakBuff = { dmgMul: 1, spdMul: 1, timer: 0, tier: 0 };
      // Remove aura
      if (this._killAuraGfx) { this._killAuraGfx.destroy(); this._killAuraGfx = null; }
      if (this._killAuraParticles) { this._killAuraParticles.forEach(p => p.destroy()); this._killAuraParticles = null; }
    }
  }

  // ‚ïê‚ïê‚ïê Kill Streak Aura ‚ïê‚ïê‚ïê
  _updateKillAura(dt) {
    const combo = this.killCombo || 0;
    if (combo < 3) {
      if (this._killAuraGfx) { this._killAuraGfx.destroy(); this._killAuraGfx = null; }
      if (this._killAuraParticles) { this._killAuraParticles.forEach(p => p.destroy()); this._killAuraParticles = null; }
      return;
    }
    if (!this._killAuraGfx) this._killAuraGfx = this.add.graphics().setDepth(4);
    this._killAuraAngle = (this._killAuraAngle || 0) + dt * 2;
    const px = this.player.x, py = this.player.y;
    const g = this._killAuraGfx;
    g.clear();
    let color = 0xFF4444, alpha = 0.12, radius = 35;
    if (combo >= 15) { color = 0xFF6600; alpha = 0.25; radius = 45; }
    else if (combo >= 10) { color = 0xFF6600; alpha = 0.2; radius = 40; }
    g.fillStyle(color, alpha + Math.sin(this._killAuraAngle * 3) * 0.05);
    g.fillCircle(px, py, radius);
    // Fire particles for 15+ kills
    if (combo >= 15) {
      if (!this._killAuraParticles || this._killAuraParticles.length === 0) {
        this._killAuraParticles = [];
        for (let i = 0; i < 4; i++) {
          const fp = this.add.circle(px, py, 3, 0xFF8800).setDepth(5).setAlpha(0.7);
          fp._orbAngle = (Math.PI * 2 / 4) * i;
          this._killAuraParticles.push(fp);
        }
      }
      this._killAuraParticles.forEach(fp => {
        if (!fp.active) return;
        fp._orbAngle += dt * 3;
        fp.x = px + Math.cos(fp._orbAngle) * 28;
        fp.y = py + Math.sin(fp._orbAngle) * 28;
      });
    }
  }

  // ‚ïê‚ïê‚ïê Start Countdown (3-2-1-ÏãúÏûë!) ‚ïê‚ïê‚ïê
  _showStartCountdown() {
    this._countdownActive = true;
    this.gameOver = true; // freeze movement during countdown
    const cam = this.cameras.main;
    const nums = ['3', '2', '1', 'ÏãúÏûë!'];
    const colors = ['#FFFFFF', '#FFD700', '#FF6644', '#44FF88'];
    let idx = 0;
    const countText = this.add.text(cam.width / 2, cam.height / 2, '', {
      fontSize: '64px', fontFamily: 'monospace', color: '#FFFFFF',
      stroke: '#000', strokeThickness: 6, fontStyle: 'bold'
    }).setOrigin(0.5).setScrollFactor(0).setDepth(400).setAlpha(0);

    const showNext = () => {
      if (idx >= nums.length) {
        countText.destroy();
        this._countdownActive = false;
        this.gameOver = false;
        return;
      }
      countText.setText(nums[idx]).setStyle({ ...countText.style, color: colors[idx] });
      countText.setScale(1.5).setAlpha(1);
      this.tweens.add({
        targets: countText, scale: 1, alpha: idx === nums.length - 1 ? 0 : 0.3,
        duration: idx === nums.length - 1 ? 400 : 350, ease: 'Cubic.Out',
        onComplete: () => { idx++; this.time.delayedCall(idx >= nums.length ? 0 : 50, showNext); }
      });
    };
    this.time.delayedCall(200, showNext);
  }

  // ‚ïê‚ïê‚ïê Tutorial Hints ‚ïê‚ïê‚ïê
  _updateTutorial() {
    if (this.tutorialShown) return;
    const t = this.gameElapsed;
    if (t > 16) {
      this.tutorialShown = true;
      if (this._tutorialText) { this.tweens.add({ targets: this._tutorialText, alpha: 0, duration: 500, onComplete: () => { this._tutorialText.destroy(); this._tutorialText = null; } }); }
      return;
    }

    const isMobile = this.sys.game.device.input.touch && window.innerWidth < 900;
    const hints = [
      { start: 0, end: 5, text: isMobile ? 'üëÜ ÌôîÎ©¥ÏùÑ ÎìúÎûòÍ∑∏Ìï¥ÏÑú Ïù¥Îèô' : 'üïπÔ∏è WASD / Î∞©Ìñ•ÌÇ§Î°ú Ïù¥Îèô' },
      { start: 5, end: 10, text: '‚öîÔ∏è Ï†ÅÏóêÍ≤å Í∞ÄÍπåÏù¥ Í∞ÄÎ©¥ ÏûêÎèô Í≥µÍ≤©' },
      { start: 10, end: 15, text: '‚ùÑÔ∏è ÌïúÌååÎ•º ÌîºÌï¥ ÏÉùÏ°¥ÌïòÏÑ∏Ïöî!' },
    ];

    let activeHint = null;
    for (const h of hints) {
      if (t >= h.start && t < h.end) { activeHint = h; break; }
    }

    if (activeHint) {
      if (!this._tutorialText) {
        this._tutorialText = this.add.text(this.cameras.main.centerX, this.cameras.main.height - 80, '', {
          fontSize: '15px', fontFamily: 'monospace', color: '#FFFFFF',
          backgroundColor: 'rgba(0,0,0,0.65)', padding: { x: 16, y: 10 },
          stroke: '#000', strokeThickness: 2
        }).setOrigin(0.5).setDepth(100).setScrollFactor(0).setAlpha(0);
      }
      if (this._tutorialText.text !== activeHint.text) {
        this._tutorialText.setText(activeHint.text);
        this._tutorialText.setAlpha(0);
        this.tweens.add({ targets: this._tutorialText, alpha: 1, duration: 400 });
      }
      this._tutorialText.setVisible(true);
    } else {
      if (this._tutorialText) this._tutorialText.setVisible(false);
    }
  }

  _updateFTUEHints() {
    if (!FTUEManager.isFirstPlay()) return;
    const t = this.gameElapsed;
    // Movement hint at 3 seconds
    if (t >= 3 && !this._ftueHints.movement) {
      this._ftueHints.movement = true;
      const isMob = this.sys.game.device.input.touch && window.innerWidth < 900;
      FTUEManager.showOnce(this, 'movement', isMob ? 'üëÜ ÌôîÎ©¥ÏùÑ ÎìúÎûòÍ∑∏Ìï¥ÏÑú Ïù¥ÎèôÌïòÏÑ∏Ïöî!' : 'üïπÔ∏è WASD ÎòêÎäî ÌôîÏÇ¥ÌëúÌÇ§Î°ú Ïù¥ÎèôÌïòÏÑ∏Ïöî!', 3000);
    }
    // Low HP hint (first 3 times)
    if (this.playerHP < this.playerMaxHP * 0.3 && this._ftueHints.lowHP < 3) {
      this._ftueHints.lowHP++;
      FTUEManager.showOnce(this, 'lowHP_' + this._ftueHints.lowHP, 'üíä ÏïÑÏù¥ÌÖúÏùÑ Î®πÏúºÎ©¥ Ï≤¥Î†•Ïù¥ ÌöåÎ≥µÎê©ÎãàÎã§!', 3000);
    }
  }

  _ftueOnEnemySpawn(animalType) {
    if (!FTUEManager.isFirstPlay()) return;
    if (animalType === 'bear' && !this._ftueHints.bear) {
      this._ftueHints.bear = true;
      FTUEManager.showOnce(this, 'bear', 'üêª Í≥∞ÏùÄ Í∞ïÌïòÏßÄÎßå ÎäêÎ¶ΩÎãàÎã§. ÏòÜÏúºÎ°ú ÌîºÌïòÏÑ∏Ïöî!', 3500);
    }
  }

  _ftueOnBossSpawn() {
    if (!FTUEManager.isFirstPlay()) return;
    if (!this._ftueHints.boss) {
      this._ftueHints.boss = true;
      FTUEManager.showOnce(this, 'boss', '‚ö†Ô∏è Î≥¥Ïä§ Îì±Ïû•! Ïû•ÎπÑ ÎìúÎ°≠ ÌôïÎ•†Ïù¥ ÎÜíÏäµÎãàÎã§.', 3500);
    }
  }

  _ftueOnBlizzard() {
    if (!FTUEManager.isFirstPlay()) return;
    if (!this._ftueHints.blizzard) {
      this._ftueHints.blizzard = true;
      FTUEManager.showOnce(this, 'blizzard', '‚ùÑÔ∏è ÌïúÌåå! ÏÉùÏ°¥ÌïòÎ©¥ Î≥¥ÏÉÅÏù¥ ÏûàÏäµÎãàÎã§!', 3500);
    }
  }

  _ftueOnEquipPickup() {
    if (!FTUEManager.isFirstPlay()) return;
    if (!this._ftueHints.equip) {
      this._ftueHints.equip = true;
      FTUEManager.showOnce(this, 'equip', 'üó°Ô∏è Ïû•ÎπÑ ÌöçÎìù! Î©îÌÉÄ ÌôîÎ©¥ÏóêÏÑú ÌôïÏù∏Ìï† Ïàò ÏûàÏäµÎãàÎã§.', 3500);
    }
  }

  _ftueOnLevelUp() {
    if (!FTUEManager.isFirstPlay()) return;
    if (!this._ftueHints.levelup) {
      this._ftueHints.levelup = true;
      FTUEManager.showOnce(this, 'levelup', '‚¨ÜÔ∏è ÏóÖÍ∑∏Î†àÏù¥ÎìúÎ•º ÏÑ†ÌÉùÌïòÏÑ∏Ïöî! Ïã†Ï§ëÌïòÍ≤å Í≥®ÎùºÎ≥¥ÏÑ∏Ïöî.', 3500);
    }
  }

  _ftueOnFirstEnemy() {
    if (!FTUEManager.isFirstPlay()) return;
    if (!this._ftueHints.attack) {
      this._ftueHints.attack = true;
      FTUEManager.showOnce(this, 'attack', '‚öîÔ∏è Ï†ÅÏóêÍ≤å Îã§Í∞ÄÍ∞ÄÎ©¥ ÏûêÎèô Í≥µÍ≤©Ìï©ÎãàÎã§!', 3000);
    }
  }

  _showTutorialOverlay() {
    const cam = this.cameras.main;
    const ov = this.add.graphics().setScrollFactor(0).setDepth(300);
    ov.fillStyle(0x000000, 0.85); ov.fillRect(0, 0, cam.width, cam.height);

    const title = this.add.text(cam.width/2, cam.height*0.18, '‚ùÑÔ∏è ÏÉùÏ°¥ Í∞ÄÏù¥Îìú', {
      fontSize: '28px', fontFamily: 'monospace', color: '#e0e8ff', stroke: '#000', strokeThickness: 3
    }).setOrigin(0.5).setScrollFactor(0).setDepth(301);

    const tips = [
      'üïπÔ∏è  Ï°∞Ïù¥Ïä§Ìã±ÏúºÎ°ú Ïù¥Îèô (Ï†ÅÏóêÍ≤å Îã§Í∞ÄÍ∞ÄÎ©¥ ÏûêÎèô Í≥µÍ≤©)',
      'ü™µ  ÎÇòÎ¨¥¬∑ÎèåÏùÑ Ï±ÑÏ∑®Ìï¥ Í±¥Î¨ºÏùÑ Í±¥ÏÑ§ÌïòÏÑ∏Ïöî',
      'üî•  Î™®Îã•Î∂à Í∑ºÏ≤òÏóêÏÑú Ï≤¥Ïò®ÏùÑ Ïú†ÏßÄÌïòÏÑ∏Ïöî',
      'üå°Ô∏è  Ïò®ÎèÑ 0 Ïù¥Ìïò ‚Üí HP Í∞êÏÜå! ÌïúÌååÏóê Ï£ºÏùò',
      '‚¨ÜÔ∏è  Ï†Å Ï≤òÏπò ‚Üí XP ‚Üí Î†àÎ≤®ÏóÖ ‚Üí Í∞ïÌôî ÏÑ†ÌÉù',
    ];
    const tipTexts = tips.map((t, i) => {
      return this.add.text(cam.width/2, cam.height*0.32 + i*36, t, {
        fontSize: '14px', fontFamily: 'monospace', color: '#AABBDD', stroke: '#000', strokeThickness: 2
      }).setOrigin(0.5).setScrollFactor(0).setDepth(301).setAlpha(0);
    });

    const startMsg = this.add.text(cam.width/2, cam.height*0.78, 'ÌÉ≠ÌïòÏó¨ ÏãúÏûë', {
      fontSize: '20px', fontFamily: 'monospace', color: '#FFD700', stroke: '#000', strokeThickness: 3
    }).setOrigin(0.5).setScrollFactor(0).setDepth(301).setAlpha(0);

    // Stagger fade in tips
    tipTexts.forEach((t, i) => {
      this.tweens.add({ targets: t, alpha: 1, duration: 300, delay: 200 + i * 150 });
    });
    this.tweens.add({ targets: startMsg, alpha: 1, duration: 400, delay: 1200, yoyo: true, repeat: -1, hold: 800 });

    // Pause game until tap
    this.gameOver = true; // temporarily pause update loop
    const hitArea = this.add.rectangle(cam.width/2, cam.height/2, cam.width, cam.height, 0, 0)
      .setScrollFactor(0).setDepth(302).setInteractive();
    hitArea.once('pointerdown', () => {
      resumeAudio();
      this.gameOver = false;
      [ov, title, startMsg, hitArea, ...tipTexts].forEach(o => o.destroy());
    });
  }

  spawnDrop(resource, tx, ty, ox, oy) {
    ox = ox || tx; oy = oy || ty;
    const texMap = { meat: 'meat_drop', wood: 'wood_drop', stone: 'stone_drop', leather: 'leather_drop' };
    const d = this.physics.add.sprite(ox, oy, texMap[resource] || 'meat_drop').setDepth(4);
    d.resource = resource; d.value = 1; d.body.setAllowGravity(false);
    this.drops.add(d);
    this.tweens.add({ targets: d, x: tx, y: ty, duration: 400, ease: 'Bounce.Out' });
    this.tweens.add({ targets: d, scale: { from: 0.3, to: 1 }, duration: 300, ease: 'Back.Out' });
    this.tweens.add({ targets: d, alpha: { from: 1, to: 0.6 }, yoyo: true, repeat: -1, duration: 800 });
    // Note: group-level overlap in create() handles collection; no per-drop overlap needed
  }

  collectDrop(drop) {
    if (!drop.active) return;
    const r = drop.resource;
    const total = Object.entries(this.res).filter(([k])=>k!=='gold').reduce((a,[_,v])=>a+(v||0), 0);
    if (r !== 'gold' && total >= this.storageCapacity) {
      if (!this._fullMsg || this._fullMsg < this.time.now) {
        this.showFloatingText(this.player.x, this.player.y - 20, '‚ö†Ô∏è Î≥¥Í¥ÄÌï® Í∞ÄÎìù!', '#FF6666');
        this._fullMsg = this.time.now + 1000;
      }
      return;
    }
    this.res[r] = (this.res[r]||0) + drop.value; playCoin(); playItemPickup();
    const icons = { meat: 'ü•©', wood: 'ü™µ', stone: 'ü™®', leather: 'üß∂' };
    const t = this.add.text(drop.x, drop.y, '+1'+( icons[r]||''), {
      fontSize: '15px', fontFamily: 'monospace', color: '#FFFFFF', stroke: '#000', strokeThickness: 3, fontStyle: 'bold'
    }).setDepth(15).setOrigin(0.5);
    this.tweens.add({ targets: t, y: t.y - 25, alpha: 0, scale: { from: 1.2, to: 0.8 },
      duration: 500, ease: 'Quad.Out', onComplete: () => t.destroy() });
    // ‚ïê‚ïê‚ïê Radial glow on collection ‚ïê‚ïê‚ïê
    const _collectGlow = this.add.circle(drop.x, drop.y, 8, 0xFFDD44, 0.5).setDepth(14);
    this.tweens.add({ targets: _collectGlow, scale: 3, alpha: 0, duration: 300, onComplete: () => _collectGlow.destroy() });
    drop.destroy();
  }

  // ‚ïê‚ïê‚ïê XP SYSTEM ‚ïê‚ïê‚ïê
  _getXPRequired(lv) {
    return lv < XP_TABLE.length ? XP_TABLE[lv] : XP_TABLE[XP_TABLE.length - 1] + (lv - XP_TABLE.length + 1) * 400;
  }

  gainXP(source) {
    let amount = (typeof source === 'number') ? source : (XP_SOURCES[source] ?? XP_SOURCES.default);
    if (this._speedrunMode) amount = Math.round(amount * 2);
    if (this._diffMode) amount = Math.round(amount * this._diffMode.xpMul);
    if (this._equipBonuses && this._equipBonuses.xpMul > 0) amount = Math.round(amount * (1 + this._equipBonuses.xpMul));
    if (this._shamanXpMul) amount = Math.round(amount * this._shamanXpMul);
    // Signal Flare: XP double
    if (this._flareXpBuff > 0) amount = Math.round(amount * 2);
    // Random event: XP triple
    if (this.activeRandomEvents && this.activeRandomEvents.xp_triple) amount = Math.round(amount * 3);
    // Random event: Combo XP (3x for next N kills)
    if (this.activeRandomEvents && this.activeRandomEvents.combo_xp) {
      amount = Math.round(amount * 3);
      this.activeRandomEvents.combo_xp.charges--;
      if (this.activeRandomEvents.combo_xp.charges <= 0) delete this.activeRandomEvents.combo_xp;
    }
    this.playerXP += amount;
    while (this.playerXP >= this._getXPRequired(this.playerLevel)) {
      this.playerXP -= this._getXPRequired(this.playerLevel);
      this.playerLevel++;
      this.pendingLevelUps++;
    }
    if (this.pendingLevelUps > 0 && !this.upgradeUIActive) {
      this.pendingLevelUps--;
      this.triggerLevelUp();
    }
  }

  triggerLevelUp() {
    // Remove FTUE hint on first level-up
    if (this._ftueHint && this._ftueHint.active) {
      this._ftueHint.destroy(); this._ftueHint = null;
    }
    // Level up sound
    playLevelUp();

    // ‚ïê‚ïê‚ïê ENHANCED LEVEL UP EFFECT (Habby Ïä§ÌÉÄÏùº) ‚ïê‚ïê‚ïê
    // Camera zoom pulse (1.0 ‚Üí 1.1 ‚Üí 1.0)
    const cam = this.cameras.main;
    const origZoom = cam.zoom;
    this.tweens.add({ targets: cam, zoom: origZoom * 1.1, duration: 150, ease: 'Quad.Out', yoyo: true,
      onComplete: () => { cam.zoom = origZoom; } });
    // White flash (brief 0.1s)
    cam.flash(100, 255, 255, 255, true);
    // 1. ÌôîÎ©¥ Ï†ÑÏ≤¥ Ìô©Í∏àÏÉâ ÌîåÎûòÏãú (2Îã®Í≥Ñ)
    this.cameras.main.flash(600, 255, 200, 0, true);
    this.cameras.main.shake(400, 0.012);

    // Golden vignette overlay (more dramatic)
    const edgeFlash = this.add.rectangle(this.cameras.main.centerX, this.cameras.main.centerY,
      this.cameras.main.width, this.cameras.main.height, 0xFFD700, 0)
      .setDepth(99).setScrollFactor(0);
    this.tweens.add({ targets: edgeFlash, alpha: { from: 0.5, to: 0 }, duration: 800, ease: 'Quad.Out',
      onComplete: () => edgeFlash.destroy() });

    // 2. Î†àÎ≤® Ïà´Ïûê ÌåùÏóÖ (Ïª§Ï°åÎã§Í∞Ä ÏûëÏïÑÏßÄÎäî Ïï†ÎãàÎ©îÏù¥ÏÖò)
    const lvText = this.add.text(this.cameras.main.centerX, this.cameras.main.centerY - 60,
      `üéä Î†àÎ≤® ${this.playerLevel} Îã¨ÏÑ±!`, {
      fontSize: '52px', fontFamily: 'monospace', color: '#FFD700',
      stroke: '#000', strokeThickness: 6, fontStyle: 'bold',
      shadow: { offsetX: 0, offsetY: 0, color: '#FF8C00', blur: 20, fill: true }
    }).setOrigin(0.5).setDepth(100).setScrollFactor(0).setScale(0.2).setAlpha(0);
    // Pop in big then settle
    this.tweens.add({ targets: lvText, scale: 1.4, alpha: 1, duration: 300, ease: 'Back.Out',
      onComplete: () => {
        this.tweens.add({ targets: lvText, scale: 1, duration: 200, ease: 'Quad.Out',
          onComplete: () => {
            this.tweens.add({ targets: lvText, y: lvText.y - 50, alpha: 0, scale: 0.6,
              duration: 1500, delay: 300, ease: 'Quad.Out', onComplete: () => lvText.destroy() });
          }
        });
      }
    });

    // Level number pop (big number behind)
    const bigNum = this.add.text(this.cameras.main.centerX, this.cameras.main.centerY - 60,
      `${this.playerLevel}`, {
      fontSize: '120px', fontFamily: 'monospace', color: '#FFD700',
      stroke: '#000', strokeThickness: 2
    }).setOrigin(0.5).setDepth(98).setScrollFactor(0).setAlpha(0.3);
    this.tweens.add({ targets: bigNum, scale: { from: 0.5, to: 3 }, alpha: 0, duration: 1200,
      ease: 'Quad.Out', onComplete: () => bigNum.destroy() });

    // 3. ÌååÌã∞ÌÅ¥ Ìè≠Î∞ú (3 rings, colorful & varied sizes)
    const _lvUpColors = [0xFFFFFF, 0xFFD700, 0xFF6B35, 0x44DDFF, 0xFF44AA, 0x44FF88, 0xAA66FF, 0xFFAA00];
    for (let ring = 0; ring < 3; ring++) {
      const count = ring === 0 ? 24 : ring === 1 ? 16 : 10;
      const radius = ring === 0 ? 100 : ring === 1 ? 60 : 35;
      const delay = ring * 100;
      for (let i = 0; i < count; i++) {
        const ang = (Math.PI * 2 / count) * i + ring * 0.3 + Math.random() * 0.2;
        const size = Phaser.Math.FloatBetween(ring === 0 ? 3 : 2, ring === 0 ? 8 : 5);
        const p = this.add.circle(this.player.x, this.player.y, size, Phaser.Utils.Array.GetRandom(_lvUpColors))
          .setDepth(15).setAlpha(0.9);
        const r2 = radius + Phaser.Math.Between(-15, 15);
        this.tweens.add({ targets: p, delay,
          x: this.player.x + Math.cos(ang) * r2,
          y: this.player.y + Math.sin(ang) * r2,
          alpha: 0, scale: { from: Phaser.Math.FloatBetween(1.5, 3), to: 0 }, duration: 800 + Math.random() * 400, ease: 'Quad.Out',
          onComplete: () => p.destroy() });
      }
    }

    // Sparkle trail particles
    for (let i = 0; i < 10; i++) {
      this.time.delayedCall(i * 60, () => {
        const sp = this.add.image(
          this.player.x + Phaser.Math.Between(-50, 50),
          this.player.y + Phaser.Math.Between(-50, 50),
          'sparkle'
        ).setScrollFactor(1).setDepth(16).setScale(2).setTint(0xFFD700);
        this.tweens.add({ targets: sp, alpha: 0, scale: 0, y: sp.y - 40,
          duration: 600 + Math.random() * 400, onComplete: () => sp.destroy() });
      });
    }

    // Show upgrade card selection
    const isEndgame = this._endlessMode && this.gameElapsed >= 3600;
    const cards = this.upgradeManager.pickThreeCards(this.extraCardChoices || 0, this._playerClass, isEndgame);
    if (cards.length > 0) {
      // Handicap: Random Build - auto-select random card
      if (this._handicap === 'random_build') {
        const pick = cards[Math.floor(Math.random() * cards.length)];
        this.upgradeManager.apply(pick.id, this);
        this._showMilestoneBanner('üé≤ ' + (pick.name || pick.id), '#FFAA00', 1500);
        if (this.pendingLevelUps > 0 && !this.upgradeUIActive) {
          this.pendingLevelUps--;
          this.triggerLevelUp();
        }
      } else {
        this.showUpgradeUI(cards);
      }
    }
  }

  processLevelUpQueue() {
    if (this.pendingLevelUps > 0 && !this.upgradeUIActive) {
      this.pendingLevelUps--;
      this.triggerLevelUp();
    }
  }

  showAttackFX(x, y, hit) {
    const slash = this.add.image(x, y, 'slash_fx').setDepth(15).setAlpha(0.8).setAngle(Phaser.Math.Between(-30, 30));
    if (hit) slash.setTint(0xFF6644);
    this.tweens.add({ targets: slash, alpha: 0, scale: { from: 0.8, to: 1.8 }, duration: 200, onComplete: () => slash.destroy() });
    const g = this.add.graphics().setDepth(14);
    const c = hit ? 0xFF4444 : 0xFFFFFF;
    let ring = { r: 5, a: 0.8 };
    this.tweens.add({ targets: ring, r: 35, a: 0, duration: 250,
      onUpdate: () => { g.clear(); g.lineStyle(hit ? 3 : 2, c, ring.a); g.strokeCircle(x, y, ring.r); },
      onComplete: () => g.destroy() });
    // ‚ïê‚ïê‚ïê Slash Arc (ÌÉÄÍ≤©ÏÑ†) ‚ïê‚ïê‚ïê
    if (hit) {
      const ang = Phaser.Math.Angle.Between(this.player.x, this.player.y, x, y);
      const arcG = this.add.graphics().setDepth(15);
      let arcProg = { t: 0 };
      this.tweens.add({ targets: arcProg, t: 1, duration: 150, ease: 'Quad.Out',
        onUpdate: () => {
          arcG.clear();
          for (let i = 0; i < 3; i++) {
            const spread = (i - 1) * 0.25;
            const r = 20 + i * 8;
            const alpha = (1 - arcProg.t) * (0.6 - i * 0.15);
            arcG.lineStyle(2 - i * 0.4, 0xFFFFFF, Math.max(0, alpha));
            arcG.beginPath();
            arcG.arc(this.player.x, this.player.y, r, ang - 0.5 + spread, ang + 0.5 + spread, false, arcProg.t * 0.3);
            arcG.strokePath();
          }
        },
        onComplete: () => arcG.destroy()
      });
    }
  }

  // ‚ïê‚ïê‚ïê Hit Stop (ÌÉÄÍ≤© Ï†ïÏßÄ) ‚ïê‚ïê‚ïê
  _hitStop(duration = 80) {
    if (this._hitStopActive) return;
    this._hitStopActive = true;
    this.physics.world.timeScale = 0;
    this.time.delayedCall(duration, () => {
      this.physics.world.timeScale = 1;
      this._hitStopActive = false;
    });
  }

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // ‚ïê‚ïê‚ïê BUFF ITEM SYSTEM ‚ïê‚ïê‚ïê
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  _initBuffSystem() {
    this.buffSlots = [null, null]; // 2 slots
    this.activeBuffs = {}; // { buffType: { remaining, ... } }
    this.buffDropGroup = this.physics.add.group();
    this.buffDropItems = []; // track for expiry
    this._buffTextures();
    // Q/E keys
    this.buffKeys = {
      q: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.Q),
      e: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.E)
    };
    // HUD slots
    this._createBuffHUD();
    this._createEquipHUD();
    // Fire breath damage timer
    this._fireBreathTimer = 0;
  }

  _buffTextures() {
    const buffs = [
      { key: 'buff_fire', color: 0xFF4400, icon: 'üî•' },
      { key: 'buff_sprint', color: 0x44CCFF, icon: 'üí®' },
      { key: 'buff_shotgun', color: 0xFFDD00, icon: 'üî´' },
      { key: 'buff_wool', color: 0xFFFFFF, icon: 'üêë' }
    ];
    buffs.forEach(b => {
      if (this.textures.exists(b.key)) return;
      const g = this.add.graphics();
      g.fillStyle(0x222244, 0.9); g.fillRoundedRect(0, 0, 24, 24, 4);
      g.fillStyle(b.color, 0.8); g.fillCircle(12, 12, 8);
      g.lineStyle(2, 0xFFFFFF, 0.6); g.strokeRoundedRect(0, 0, 24, 24, 4);
      g.generateTexture(b.key, 24, 24); g.destroy();
    });
  }

  _createBuffHUD() {
    const W = this.scale.width;
    const H = this.scale.height;
    this.buffHudGfx = this.add.graphics().setScrollFactor(0).setDepth(105);
    this.buffHudTexts = [
      this.add.text(W / 2 - 35, H - 55, '', { fontSize: '11px', fontFamily: 'monospace', color: '#fff', stroke: '#000', strokeThickness: 2 }).setScrollFactor(0).setDepth(106).setOrigin(0.5),
      this.add.text(W / 2 + 35, H - 55, '', { fontSize: '11px', fontFamily: 'monospace', color: '#fff', stroke: '#000', strokeThickness: 2 }).setScrollFactor(0).setDepth(106).setOrigin(0.5)
    ];
    this.buffHudKeys = [
      this.add.text(W / 2 - 35, H - 30, '[Q]', { fontSize: '10px', fontFamily: 'monospace', color: '#888' }).setScrollFactor(0).setDepth(106).setOrigin(0.5),
      this.add.text(W / 2 + 35, H - 30, '[E]', { fontSize: '10px', fontFamily: 'monospace', color: '#888' }).setScrollFactor(0).setDepth(106).setOrigin(0.5)
    ];
    // Touch/click handlers on slots
    for (let i = 0; i < 2; i++) {
      const sx = W / 2 + (i === 0 ? -35 : 35);
      const hit = this.add.rectangle(sx, H - 45, 44, 44, 0, 0).setScrollFactor(0).setDepth(107).setInteractive();
      hit.on('pointerdown', () => this._useBuffSlot(i));
    }
  }

  _updateBuffHUD() {
    const W = this.scale.width;
    const H = this.scale.height;
    this.buffHudGfx.clear();
    const names = { fire: 'üî•Î∂àÎøúÍ∏∞', sprint: 'üí®Îã¨Î¶¨Í∏∞', shotgun: 'üî´ÏÉ∑Í±¥', wool: 'üêëÏñëÌÑ∏' };
    for (let i = 0; i < 2; i++) {
      const sx = W / 2 + (i === 0 ? -35 : 35);
      const slot = this.buffSlots[i];
      if (slot) {
        this.buffHudGfx.fillStyle(0x334466, 0.9);
        this.buffHudGfx.fillRoundedRect(sx - 22, H - 67, 44, 44, 6);
        this.buffHudGfx.lineStyle(2, 0x88CCFF, 0.8);
        this.buffHudGfx.strokeRoundedRect(sx - 22, H - 67, 44, 44, 6);
        this.buffHudTexts[i].setText(names[slot] || slot);
      } else {
        this.buffHudGfx.fillStyle(0x222233, 0.6);
        this.buffHudGfx.fillRoundedRect(sx - 22, H - 67, 44, 44, 6);
        this.buffHudGfx.lineStyle(1, 0x445566, 0.5);
        this.buffHudGfx.strokeRoundedRect(sx - 22, H - 67, 44, 44, 6);
        this.buffHudTexts[i].setText('');
      }
    }
  }

  _tryDropBuff(x, y) {
    // 3~5% chance, max 3 on map
    if (this.buffDropItems.length >= 3) return;
    if (Math.random() > 0.05) return;
    const types = ['fire', 'sprint', 'shotgun', 'wool'];
    const type = types[Math.floor(Math.random() * types.length)];
    const texKey = 'buff_' + type;
    const drop = this.physics.add.sprite(x, y, texKey).setDepth(8);
    drop.body.setAllowGravity(false);
    drop.buffType = type;
    drop.lifetime = 60; // seconds
    this.buffDropGroup.add(drop);
    this.buffDropItems.push(drop);
    // Bounce in
    this.tweens.add({ targets: drop, scale: { from: 0, to: 1.3 }, duration: 300, ease: 'Back.Out',
      onComplete: () => this.tweens.add({ targets: drop, scale: 1, duration: 200 }) });
    // Floating label
    const icons = { fire: 'üî•', sprint: 'üí®', shotgun: 'üî´', wool: 'üêë' };
    const label = this.add.text(x, y - 20, icons[type] || '?', {
      fontSize: '16px', fontFamily: 'monospace'
    }).setDepth(9).setOrigin(0.5);
    drop._label = label;
  }

  _collectBuffDrop(bd) {
    if (!bd.active) return;
    // Find empty slot (oldest first = slot 0 first)
    let slotIdx = -1;
    if (this.buffSlots[0] === null) slotIdx = 0;
    else if (this.buffSlots[1] === null) slotIdx = 1;
    if (slotIdx === -1) return; // both full
    this.buffSlots[slotIdx] = bd.buffType;
    this.showFloatingText(bd.x, bd.y - 20, 'Î≤ÑÌîÑ ÌöçÎìù!', '#88FFAA');
    if (bd._label) bd._label.destroy();
    const idx = this.buffDropItems.indexOf(bd);
    if (idx >= 0) this.buffDropItems.splice(idx, 1);
    bd.destroy();
    this._updateBuffHUD();
  }

  _useBuffSlot(idx) {
    const type = this.buffSlots[idx];
    if (!type) return;
    this.buffSlots[idx] = null;
    this._activateBuff(type);
    this._updateBuffHUD();
  }

  _activateBuff(type) {
    const px = this.player.x, py = this.player.y;
    if (type === 'fire') {
      this.activeBuffs.fire = { remaining: 5 };
      this._fireBreathTimer = 0;
      this.showFloatingText(px, py - 30, 'üî• Î∂àÎøúÍ∏∞!', '#FF4400');
    } else if (type === 'sprint') {
      this.activeBuffs.sprint = { remaining: 8, origSpeed: this.playerSpeed };
      this.playerSpeed *= 3;
      this.showFloatingText(px, py - 30, 'üí® Îã¨Î¶¨Í∏∞!', '#44CCFF');
    } else if (type === 'shotgun') {
      this.showFloatingText(px, py - 30, 'üî´ ÏÉ∑Í±¥!', '#FFDD00');
      // Flash effect
      this.cameras.main.flash(200, 255, 255, 200);
      // 8-directional projectiles
      for (let i = 0; i < 8; i++) {
        const ang = (i / 8) * Math.PI * 2;
        const bullet = this.add.circle(px, py, 5, 0xFFFF44).setDepth(15);
        const speed = 400;
        const bx = Math.cos(ang), by = Math.sin(ang);
        this.tweens.add({
          targets: bullet, x: px + bx * 600, y: py + by * 600,
          duration: 1500, ease: 'Linear',
          onUpdate: () => {
            // Check hits on animals
            const _shotgunKills = [];
            this.animals.getChildren().forEach(a => {
              if (!a.active || a._shotgunHit) return;
              const d = Phaser.Math.Distance.Between(bullet.x, bullet.y, a.x, a.y);
              if (d < 25) {
                a.hp -= 150;
                a.setTint(0xFFFF00);
                this.time.delayedCall(150, () => { if (a.active) a.clearTint(); });
                this.showFloatingText(a.x, a.y - 20, '-150', '#FFDD00');
                if (a.hp <= 0) _shotgunKills.push(a);
              }
            });
            _shotgunKills.forEach(a => { if (a.active) this.killAnimal(a); });
          },
          onComplete: () => bullet.destroy()
        });
      }
    } else if (type === 'wool') {
      this.activeBuffs.wool = { remaining: 15 };
      this.showFloatingText(px, py - 30, 'üêë ÏñëÌÑ∏ÏäàÌä∏!', '#FFFFFF');
    }
  }

  _updateBuffs(dt) {
    // Q/E key check
    if (Phaser.Input.Keyboard.JustDown(this.buffKeys.q)) this._useBuffSlot(0);
    if (Phaser.Input.Keyboard.JustDown(this.buffKeys.e)) this._useBuffSlot(1);

    // Update buff drop expiry
    for (let i = this.buffDropItems.length - 1; i >= 0; i--) {
      const bd = this.buffDropItems[i];
      if (!bd.active) { this.buffDropItems.splice(i, 1); continue; }
      bd.lifetime -= dt;
      // Blink when < 10s
      if (bd.lifetime < 10) {
        bd.setAlpha(Math.sin(bd.lifetime * 8) * 0.3 + 0.5);
        if (bd._label) bd._label.setAlpha(bd.alpha);
      }
      if (bd.lifetime <= 0) {
        if (bd._label) bd._label.destroy();
        bd.destroy();
        this.buffDropItems.splice(i, 1);
      }
    }

    // Fire Breath
    if (this.activeBuffs.fire) {
      this.activeBuffs.fire.remaining -= dt;
      this._fireBreathTimer -= dt;
      // Visual: orange/red particles in front arc
      const dir = this.facingRight ? 0 : Math.PI;
      for (let i = 0; i < 3; i++) {
        const ang = dir + (Math.random() - 0.5) * (Math.PI * 2 / 3); // 120¬∞ arc
        const dist = 30 + Math.random() * 120;
        const px = this.player.x + Math.cos(ang) * dist;
        const py = this.player.y + Math.sin(ang) * dist;
        const colors = [0xFF4400, 0xFF6600, 0xFF8800, 0xFF2200];
        const p = this.add.circle(px, py, 2 + Math.random() * 4, Phaser.Utils.Array.GetRandom(colors))
          .setDepth(12).setAlpha(0.8);
        this.tweens.add({ targets: p, alpha: 0, scale: 0, duration: 300 + Math.random() * 300, onComplete: () => p.destroy() });
      }
      // Damage every 0.3s
      if (this._fireBreathTimer <= 0) {
        this._fireBreathTimer = 0.3;
        const dir2 = this.facingRight ? 0 : Math.PI;
        const _fireKills = [];
        this.animals.getChildren().forEach(a => {
          if (!a.active) return;
          const d = Phaser.Math.Distance.Between(this.player.x, this.player.y, a.x, a.y);
          if (d > 150) return;
          const angToA = Phaser.Math.Angle.Between(this.player.x, this.player.y, a.x, a.y);
          let diff = angToA - dir2;
          while (diff > Math.PI) diff -= Math.PI * 2;
          while (diff < -Math.PI) diff += Math.PI * 2;
          if (Math.abs(diff) < Math.PI / 3) { // 120¬∞ = 60¬∞ each side
            a.hp -= 10;
            a.setTint(0xFF4400);
            this.time.delayedCall(100, () => { if (a.active) a.clearTint(); });
            if (a.hp <= 0) _fireKills.push(a);
          }
        });
        _fireKills.forEach(a => { if (a.active) this.killAnimal(a); });
      }
      if (this.activeBuffs.fire.remaining <= 0) delete this.activeBuffs.fire;
    }

    // Sprint
    if (this.activeBuffs.sprint) {
      this.activeBuffs.sprint.remaining -= dt;
      // Speed lines visual
      if (Math.random() < 0.3) {
        const ang = Math.random() * Math.PI * 2;
        const p = this.add.rectangle(
          this.player.x + Math.cos(ang) * 15, this.player.y + Math.sin(ang) * 15,
          2, 10 + Math.random() * 15, 0xFFFFFF, 0.6
        ).setDepth(9).setRotation(ang);
        this.tweens.add({ targets: p, alpha: 0, scaleX: 0, duration: 200, onComplete: () => p.destroy() });
      }
      if (this.activeBuffs.sprint.remaining <= 0) {
        this.playerSpeed = this.playerBaseSpeed;
        delete this.activeBuffs.sprint;
      }
    }

    // Wool Suit visual
    if (this.activeBuffs.wool) {
      this.activeBuffs.wool.remaining -= dt;
      // White glow
      if (!this._woolGlow) {
        this._woolGlow = this.add.circle(this.player.x, this.player.y, 30, 0xFFFFFF, 0.15).setDepth(9);
      }
      this._woolGlow.setPosition(this.player.x, this.player.y);
      if (this.activeBuffs.wool.remaining <= 0) {
        delete this.activeBuffs.wool;
        if (this._woolGlow) { this._woolGlow.destroy(); this._woolGlow = null; }
      }
    } else if (this._woolGlow) {
      this._woolGlow.destroy(); this._woolGlow = null;
    }

    this._updateBuffHUD();
  }

  // ‚ïê‚ïê‚ïê EQUIPMENT DROP & PICKUP ‚ïê‚ïê‚ïê
  _tryDropEquipment(x, y) {
    if (this._handicap === 'no_equipment') return;
    const luck = (this._equipBonuses ? this._equipBonuses.luckFlat : 0);
    const feverMul = (this.activeRandomEvents && this.activeRandomEvents.drop_fever) ? 3 : (this.activeRandomEvents && this.activeRandomEvents.equip_bonus_5x) ? 5 : 1;
    const synergyDrop = this._synergyExtraDropRate || 0;
    const elapsedMin = (this.gameElapsed || 0) / 60;
    const timeBonus = Math.min(0.04, elapsedMin * 0.002); // +0.2% per min, max +4%
    if (this._dailyModifier && this._dailyModifier.noEquipDrop) return;
    const diffDropMul = this._diffMode ? this._diffMode.dropMul : 1;
    // Ï¥àÎ∞ò 10Î∂ÑÍ∞Ñ Ïû•ÎπÑ ÎìúÎ°≠Î•† ÎåÄÌè≠ ÏñµÏ†ú (10Î∂Ñ Ïù¥ÌõÑ Î≥∏Í≤© ÎìúÎ°≠)
    const earlyNerf = elapsedMin < 10 ? (0.2 + 0.08 * elapsedMin) : 1.0; // 0~10Î∂Ñ: 20%‚Üí100% ÏÑ†Ìòï Ï¶ùÍ∞Ä
    const dropRate = (0.03 + timeBonus + luck / 1000 + synergyDrop) * feverMul * diffDropMul * earlyNerf;
    if (Math.random() > dropRate) return;
    if (this.equipmentDrops.length >= 5) return;

    const drop = EquipmentManager.rollDrop(luck);
    if (!drop || !drop.grade || !drop.itemId) return;
    const color = EQUIP_GRADE_COLORS[drop.grade] || '#9E9E9E';
    const label = this.add.text(x, y - 10, (drop.icon || '?') + ' ' + (drop.name || '?'), {
      fontSize: '12px', fontFamily: 'monospace', color: color,
      stroke: '#000', strokeThickness: 3, fontStyle: 'bold'
    }).setDepth(15).setOrigin(0.5);

    const parsedColor = Phaser.Display.Color.HexStringToColor(color);
    const glow = this.add.circle(x, y, 14, parsedColor ? parsedColor.color : 0x9E9E9E, 0.4).setDepth(8);
    this.tweens.add({ targets: glow, scale: { from: 0.5, to: 1.5 }, alpha: { from: 0.6, to: 0.2 }, yoyo: true, repeat: -1, duration: 800 });
    this.tweens.add({ targets: label, y: label.y - 8, yoyo: true, repeat: -1, duration: 1000, ease: 'Sine.InOut' });

    const eqDrop = { x, y, ...drop, label, glow, lifetime: 30 };
    this.equipmentDrops.push(eqDrop);
  }

  _updateEquipmentDrops(dt) {
    const px = this.player.x, py = this.player.y;
    for (let i = this.equipmentDrops.length - 1; i >= 0; i--) {
      const ed = this.equipmentDrops[i];
      ed.lifetime -= dt;
      if (ed.lifetime < 5) {
        const a = Math.sin(ed.lifetime * 6) * 0.3 + 0.5;
        if (ed.label) ed.label.setAlpha(a);
        if (ed.glow) ed.glow.setAlpha(a * 0.4);
      }
      if (ed.lifetime <= 0) {
        if (ed.label) ed.label.destroy();
        if (ed.glow) ed.glow.destroy();
        this.equipmentDrops.splice(i, 1);
        continue;
      }
      const dist = Phaser.Math.Distance.Between(px, py, ed.x, ed.y);
      if (dist < 100) {
        this._pickupEquipment(ed, i);
      }
    }
  }

  _pickupEquipment(ed, idx) {
    this._ftueOnEquipPickup();
    // Track grade for achievements
    if (ed.grade === 'rare') this.gotRareEquip = true;
    if (ed.grade === 'epic' || ed.grade === 'legendary' || ed.grade === 'unique') this.gotEpicEquip = true;
    if (this._questProgress) this._questProgress.equipment_collected++;
    const equipped = this.equipmentManager.tryEquip(ed.slot, ed.itemId, ed.grade);
    // Grade-based SFX & visual feedback
    this._playEquipPickupFX(ed.grade);
    if (equipped) {
      const color = EQUIP_GRADE_COLORS[ed.grade];
      this.showFloatingText(this.player.x, this.player.y - 40,
        ed.icon + ' ' + ed.name + ' Ïû•Ï∞©!', color);
      this._equipBonuses = this.equipmentManager.getTotalBonuses();
      this._updateEquipHUD();
    } else {
      // Store in inventory for crafting
      this.equipmentManager.addToInventory(ed.slot, ed.itemId, ed.grade);
      this.showFloatingText(this.player.x, this.player.y - 40,
        ed.icon + ' Î≥¥Í¥Ä (+1)', '#AAAAAA');
    }
    if (ed.label) ed.label.destroy();
    if (ed.glow) ed.glow.destroy();
    this.equipmentDrops.splice(idx, 1);
  }

  _playEquipPickupFX(grade) {
    switch (grade) {
      case 'common':
        playCoin();
        break;
      case 'rare':
        playUpgradeSelect();
        break;
      case 'epic':
        playEpicCard();
        this.cameras.main.flash(200, 160, 40, 200, true);
        break;
      case 'legendary':
        playEpicCard();
        this.cameras.main.flash(300, 255, 215, 0, true);
        // Golden burst particles
        for (let i = 0; i < 16; i++) {
          const ang = (i / 16) * Math.PI * 2;
          const p = this.add.circle(this.player.x, this.player.y, 5, 0xFFD700).setDepth(200).setAlpha(0.9);
          this.tweens.add({ targets: p, x: this.player.x + Math.cos(ang) * 60, y: this.player.y + Math.sin(ang) * 60,
            alpha: 0, scale: { from: 2, to: 0 }, duration: 700, onComplete: () => p.destroy() });
        }
        // Big popup
        const legText = this.add.text(this.cameras.main.centerX, this.cameras.main.centerY - 50, '‚≠ê LEGENDARY! ‚≠ê', {
          fontSize: '28px', fontFamily: 'monospace', color: '#FFD700', stroke: '#000', strokeThickness: 5, fontStyle: 'bold'
        }).setScrollFactor(0).setDepth(300).setOrigin(0.5).setAlpha(0);
        this.tweens.add({ targets: legText, alpha: 1, scale: { from: 0.3, to: 1.3 }, duration: 400, ease: 'Back.Out',
          onComplete: () => this.tweens.add({ targets: legText, alpha: 0, y: legText.y - 40, duration: 800, delay: 600, onComplete: () => legText.destroy() })
        });
        break;
      case 'unique':
        playEpicCard();
        this.cameras.main.flash(400, 255, 64, 129, true);
        for (let i = 0; i < 20; i++) {
          const ang = (i / 20) * Math.PI * 2;
          const colors = [0xFF4081, 0xFFD700, 0xFF69B4];
          const p = this.add.circle(this.player.x, this.player.y, 6, Phaser.Utils.Array.GetRandom(colors)).setDepth(200);
          this.tweens.add({ targets: p, x: this.player.x + Math.cos(ang) * 80, y: this.player.y + Math.sin(ang) * 80,
            alpha: 0, scale: { from: 2.5, to: 0 }, duration: 900, onComplete: () => p.destroy() });
        }
        const uniText = this.add.text(this.cameras.main.centerX, this.cameras.main.centerY - 50, 'üíé UNIQUE!! üíé', {
          fontSize: '32px', fontFamily: 'monospace', color: '#FF4081', stroke: '#000', strokeThickness: 5, fontStyle: 'bold'
        }).setScrollFactor(0).setDepth(300).setOrigin(0.5).setAlpha(0);
        this.tweens.add({ targets: uniText, alpha: 1, scale: { from: 0.3, to: 1.5 }, duration: 500, ease: 'Back.Out',
          onComplete: () => this.tweens.add({ targets: uniText, alpha: 0, y: uniText.y - 50, duration: 1000, delay: 800, onComplete: () => uniText.destroy() })
        });
        break;
    }
  }

  // ‚ïê‚ïê‚ïê EQUIPMENT HUD ‚ïê‚ïê‚ïê
  _createEquipHUD() {
    const W = this.scale.width;
    const H = this.scale.height;
    const mob = isMobileLayout();
    const slotSize = mob ? 32 : 40;
    const slotGap = mob ? 36 : 45;
    this._equipSlotSize = slotSize;
    this._equipSlotGap = slotGap;
    this._equipHudGfx = this.add.graphics().setScrollFactor(0).setDepth(105);
    this._equipHudTexts = [];
    this._equipHudTooltip = null;
    const slotKeys = ['weapon','armor','boots','helmet','ring'];
    const startX = W - (5 * slotGap + 10);
    const startY = H - (mob ? 40 : 50);
    this._equipStartX = startX;
    this._equipStartY = startY;
    for (let i = 0; i < 5; i++) {
      const sx = startX + i * slotGap;
      const txt = this.add.text(sx, startY, '', {
        fontSize: mob ? '14px' : '18px', fontFamily: 'monospace'
      }).setScrollFactor(0).setDepth(106).setOrigin(0.5);
      this._equipHudTexts.push(txt);
      // Click handler for tooltip
      const hit = this.add.rectangle(sx, startY, Math.max(44, slotSize), Math.max(44, slotSize), 0, 0)
        .setScrollFactor(0).setDepth(107).setInteractive();
      const slotKey = slotKeys[i];
      hit.on('pointerdown', () => this._showEquipTooltip(slotKey, sx, startY - 50));
    }
    this._updateEquipHUD();
  }

  _updateEquipHUD() {
    if (!this._equipHudGfx) return;
    this._equipHudGfx.clear();
    const slotKeys = ['weapon','armor','boots','helmet','ring'];
    const startX = this._equipStartX || (this.scale.width - 230);
    const startY = this._equipStartY || (this.scale.height - 50);
    const slotGap = this._equipSlotGap || 45;
    const ss = this._equipSlotSize || 40;
    const half = ss / 2;
    for (let i = 0; i < 5; i++) {
      const sx = startX + i * slotGap;
      const slot = slotKeys[i];
      const eq = this.equipmentManager.slots[slot];
      if (eq) {
        const color = Phaser.Display.Color.HexStringToColor(EQUIP_GRADE_COLORS[eq.grade]).color;
        this._equipHudGfx.fillStyle(0x222244, 0.9);
        this._equipHudGfx.fillRoundedRect(sx - half, startY - half, ss, ss, 6);
        this._equipHudGfx.lineStyle(2, color, 1);
        this._equipHudGfx.strokeRoundedRect(sx - half, startY - half, ss, ss, 6);
        const def = this.equipmentManager.getItemDef(slot);
        this._equipHudTexts[i].setText(def ? def.icon : EQUIP_SLOT_ICONS[slot]);
      } else {
        this._equipHudGfx.fillStyle(0x333344, 0.5);
        this._equipHudGfx.fillRoundedRect(sx - half, startY - half, ss, ss, 6);
        this._equipHudGfx.lineStyle(1, 0x555566, 0.5);
        this._equipHudGfx.strokeRoundedRect(sx - half, startY - half, ss, ss, 6);
        this._equipHudTexts[i].setText(EQUIP_SLOT_ICONS[slot]).setAlpha(0.3);
      }
    }
  }

  _showEquipTooltip(slot, x, y) {
    // Clean up previous tooltip
    if (this._equipHudTooltip) { this._equipHudTooltip.forEach(o => o.destroy()); this._equipHudTooltip = null; }
    if (this._craftBtn) { this._craftBtn.forEach(o => o.destroy()); this._craftBtn = null; }

    const eq = this.equipmentManager.slots[slot];
    const inv = this.equipmentManager.inventory[slot] || [];
    const effectNames = { atkMul:'Í≥µÍ≤©Î†•', aspdMul:'Í≥µÏÜç', hpFlat:'HP', defMul:'Î∞©Ïñ¥', spdMul:'Ïù¥ÏÜç', dodgeMul:'ÌöåÌîº', coldRes:'ÌïúÌååÏ†ÄÌï≠', regenPS:'HPÌöåÎ≥µ', xpMul:'XP', luckFlat:'ÌñâÏö¥' };

    let lines = [];
    if (eq) {
      const def = this.equipmentManager.getItemDef(slot);
      if (def) {
        const gradeLabel = EQUIP_GRADE_LABELS[eq.grade];
        const effectStr = Object.entries(def.effects).map(([k,v]) => (effectNames[k]||k) + (k.includes('Flat') ? '+'+v : '+'+Math.round(v*100)+'%')).join(', ');
        lines.push(`[${gradeLabel}] ${def.icon} ${def.name}`);
        lines.push(effectStr);
      }
    } else {
      lines.push('Îπà Ïä¨Î°Ø');
    }

    // Show inventory counts by grade
    if (inv.length > 0) {
      const counts = {};
      inv.forEach(i => { counts[i.grade] = (counts[i.grade]||0) + 1; });
      const invStr = Object.entries(counts).map(([g,c]) => `${EQUIP_GRADE_LABELS[g]}√ó${c}`).join(' ');
      lines.push(`üì¶ Î≥¥Í¥Ä: ${invStr}`);
    }

    // Check craftable
    const craftable = this.equipmentManager.getCraftableGrades(slot);
    if (craftable.length > 0) {
      const cg = craftable[0]; // craft lowest grade first
      const nextG = EQUIP_GRADES[EQUIP_GRADES.indexOf(cg) + 1];
      lines.push(`‚öóÔ∏è ${EQUIP_GRADE_LABELS[cg]}√ó3 ‚Üí ${EQUIP_GRADE_LABELS[nextG]} Ìï©ÏÑ± Í∞ÄÎä•!`);
    }

    const color = eq ? EQUIP_GRADE_COLORS[eq.grade] : '#888888';
    const tooltipText = this.add.text(x, y, lines.join('\n'), {
      fontSize: '11px', fontFamily: 'monospace', color: color,
      stroke: '#000', strokeThickness: 3, backgroundColor: '#111122',
      padding: { x: 6, y: 4 }, align: 'center', wordWrap: { width: 250 }
    }).setScrollFactor(0).setDepth(200).setOrigin(0.5, 1);

    const elements = [tooltipText];

    // Add craft button if craftable
    if (craftable.length > 0) {
      const cg = craftable[0];
      const btnY = tooltipText.y + 4;
      const btnBg = this.add.graphics().setScrollFactor(0).setDepth(200);
      btnBg.fillStyle(0x6633AA, 0.9);
      btnBg.fillRoundedRect(x - 50, btnY, 100, 26, 6);
      btnBg.lineStyle(1, 0xAA66FF, 1);
      btnBg.strokeRoundedRect(x - 50, btnY, 100, 26, 6);
      const btnText = this.add.text(x, btnY + 13, '‚öóÔ∏è Ìï©ÏÑ±', {
        fontSize: '13px', fontFamily: 'monospace', color: '#FFFFFF',
        stroke: '#000', strokeThickness: 2, fontStyle: 'bold'
      }).setScrollFactor(0).setDepth(201).setOrigin(0.5);
      const btnHit = this.add.rectangle(x, btnY + 13, 100, 26).setScrollFactor(0).setDepth(202).setOrigin(0.5).setInteractive().setAlpha(0.001);
      btnHit.on('pointerdown', () => {
        const result = this.equipmentManager.craft(slot, cg);
        if (result) {
          playCraft();
          this._playEquipPickupFX(result.grade);
          const rc = EQUIP_GRADE_COLORS[result.grade];
          this.showFloatingText(this.player.x, this.player.y - 50,
            `‚öóÔ∏è ${result.icon} ${result.name} [${EQUIP_GRADE_LABELS[result.grade]}] Ìï©ÏÑ±!`, rc);
          this._equipBonuses = this.equipmentManager.getTotalBonuses();
          this._updateEquipHUD();
          // Re-show tooltip
          this._showEquipTooltip(slot, x, y);
        }
      });
      elements.push(btnBg, btnText, btnHit);
      this._craftBtn = [btnBg, btnText, btnHit];
    }

    this._equipHudTooltip = elements;
    this.time.delayedCall(5000, () => {
      if (this._equipHudTooltip) { this._equipHudTooltip.forEach(o => o.destroy()); this._equipHudTooltip = null; }
      if (this._craftBtn) { this._craftBtn.forEach(o => o.destroy()); this._craftBtn = null; }
    });
  }

  _fireIceBolt(fromX, fromY, toX, toY) {
    const ang = Phaser.Math.Angle.Between(fromX, fromY, toX, toY);
    const bolt = this.add.circle(fromX, fromY, 4, 0x44AAFF).setDepth(10);
    bolt._vx = Math.cos(ang) * 200;
    bolt._vy = Math.sin(ang) * 200;
    bolt._life = 3;
    this._iceBolts.push(bolt);
    // PERF: limit ice bolts array
    while (this._iceBolts.length > 50) {
      const old = this._iceBolts.shift();
      old.destroy();
    }
  }

  _updateIceBolts(dt) {
    if (!this.player || !this.player.active) { this._iceBolts.forEach(b => b.destroy()); this._iceBolts = []; return; }
    for (let i = this._iceBolts.length - 1; i >= 0; i--) {
      const b = this._iceBolts[i];
      b.x += b._vx * dt;
      b.y += b._vy * dt;
      b._life -= dt;
      if (b._life <= 0 || b.x < 0 || b.x > WORLD_W || b.y < 0 || b.y > WORLD_H) {
        b.destroy(); this._iceBolts.splice(i, 1); continue;
      }
      // Check player collision
      const dist = Phaser.Math.Distance.Between(b.x, b.y, this.player.x, this.player.y);
      if (dist < 18) {
        // Hit player
        const dmg = 3 * (this._diffMode ? this._diffMode.enemyDmg : 1) * (this._endlessMultiplier || 1);
        this.playerHP -= dmg;
        this.showFloatingText(this.player.x, this.player.y - 20, 'üßä-' + Math.round(dmg), '#44AAFF');
        playHurt();
        // Slow effect
        if (!this._playerSlowed) {
          this._playerSlowed = true;
          const origSpeed = this.playerSpeed;
          const slowMul = 0.5 + (this.upgradeManager._coldResistSlowReduce || 0) * 0.5; // COLD_RESISTANCE: reduce slow
          this.playerSpeed *= slowMul;
          this.player.setTint(0x88CCFF);
          this.time.delayedCall(500, () => {
            this.playerSpeed = Math.max(this.playerSpeed, origSpeed);
            this._playerSlowed = false;
            if (this.player.active) this.player.clearTint();
          });
        }
        b.destroy(); this._iceBolts.splice(i, 1);
        if (this.playerHP <= 0) this.endGame();
      }
    }
  }

  updateAnimalAI(dt) {
    if (!this.player || !this.player.active) return;
    const px = this.player.x, py = this.player.y;
    const cam = this.cameras.main;
    const camL = cam.scrollX - 100, camR = cam.scrollX + cam.width + 100;
    const camT = cam.scrollY - 100, camB = cam.scrollY + cam.height + 100;
    const animalChildren = this.animals.getChildren();
    const animalCount = animalChildren.length;
    const useAlternating = animalCount > 50;
    this._frameCount = (this._frameCount || 0) + 1;
    animalChildren.forEach((a, idx) => {
      if (!a.active) return;
      // Boss cinematic freeze
      if (a._cinematicFreeze) { if (a.body) a.body.setVelocity(0, 0); return; }
      a.atkCD = Math.max(0, a.atkCD - dt);
      if (a.hitFlash > 0) { a.hitFlash -= dt; if (a.hitFlash <= 0) { a.clearTint();
        // Low HP enemy: red pulse
        if (a.hp > 0 && a.maxHP && a.hp / a.maxHP <= 0.2) { a.setTint(0xFF2222); a.setAlpha(0.7 + Math.sin(Date.now() * 0.01) * 0.3); }
      } }
      const dist = Phaser.Math.Distance.Between(a.x, a.y, px, py);
      // PERF: off-screen non-boss enemies skip detailed AI (still update atkCD/hitFlash above)
      const onScreen = a.x >= camL && a.x <= camR && a.y >= camT && a.y <= camB;
      if (!onScreen && !a.isBoss && dist > 500) return;
      // PERF: alternating frame AI for large enemy counts
      if (useAlternating && !a.isBoss && idx % 2 !== this._frameCount % 2 && dist > 200) return;

      // Campfire/wall repel
      let repelled = false;
      this.placedBuildings.forEach(b => {
        if (b.type === 'campfire') {
          const bd = Phaser.Math.Distance.Between(a.x, a.y, b.x, b.y);
          if (bd < b.def.effects.animalRepelRadius) {
            const ang = Phaser.Math.Angle.Between(b.x, b.y, a.x, a.y);
            a.body.setVelocity(Math.cos(ang) * (b.def.effects.animalRepelRadius - bd) * 2,
                               Math.sin(ang) * (b.def.effects.animalRepelRadius - bd) * 2);
            repelled = true;
          }
        } else if (b.type === 'wall') {
          const bd = Phaser.Math.Distance.Between(a.x, a.y, b.x, b.y);
          if (bd < 30) {
            const ang = Phaser.Math.Angle.Between(b.x, b.y, a.x, a.y);
            a.body.setVelocity(Math.cos(ang) * 80, Math.sin(ang) * 80);
            repelled = true;
          }
        }
      });

      // ‚ïê‚ïê‚ïê Wool Suit: hostile animals flee from player ‚ïê‚ïê‚ïê
      if (!repelled && this.activeBuffs.wool && a.def.behavior === 'chase' && dist < 200) {
        const ang = Phaser.Math.Angle.Between(px, py, a.x, a.y);
        a.body.setVelocity(Math.cos(ang) * a.def.speed * 1.2, Math.sin(ang) * a.def.speed * 1.2);
        repelled = true;
      }

      if (!repelled) {
        // ‚ïê‚ïê‚ïê Ice Hunter: ranged behavior - keep distance, shoot bolts ‚ïê‚ïê‚ïê
        if (a.def.behavior === 'ranged') {
          if (dist < a.def.aggroRange) {
            if (dist < 200) {
              // Too close - back away
              const ang = Phaser.Math.Angle.Between(px, py, a.x, a.y);
              a.body.setVelocity(Math.cos(ang) * a.def.speed, Math.sin(ang) * a.def.speed);
            } else if (dist > 250) {
              // Too far - approach
              const ang = Phaser.Math.Angle.Between(a.x, a.y, px, py);
              a.body.setVelocity(Math.cos(ang) * a.def.speed, Math.sin(ang) * a.def.speed);
            } else {
              // In sweet spot - strafe
              const ang = Phaser.Math.Angle.Between(a.x, a.y, px, py) + Math.PI / 2;
              a.body.setVelocity(Math.cos(ang) * a.def.speed * 0.5, Math.sin(ang) * a.def.speed * 0.5);
            }
            // Shoot ice bolt every 3 seconds
            a._shootCD = (a._shootCD || 0) - dt;
            if (a._shootCD <= 0) {
              a._shootCD = 3;
              this._fireIceBolt(a.x, a.y, px, py);
            }
          } else this.wander(a, dt, 0.3);
        }
        // ‚ïê‚ïê‚ïê Blizzard Shaman: flee + buff nearby enemies ‚ïê‚ïê‚ïê
        else if (a.def.behavior === 'shaman') {
          // PERF: Buff nearby enemies only every 10 frames
          if (this._frameCount % 10 === 0) {
            this.animals.getChildren().forEach(b => {
              if (b === a || !b.active || b.animalType === 'blizzard_shaman') return;
              const bd = Phaser.Math.Distance.Between(a.x, a.y, b.x, b.y);
              if (bd < 300) {
                if (!b._shamanBuffed) {
                  b._shamanBuffed = true;
                  b._shamanBuffSource = a;
                  b._origSpeed = b.def.speed;
                }
              }
            });
          }
          // Flee from player
          if (dist < a.def.fleeRange) {
            const ang = Phaser.Math.Angle.Between(px, py, a.x, a.y);
            a.body.setVelocity(Math.cos(ang) * a.def.speed * 1.5, Math.sin(ang) * a.def.speed * 1.5);
            a.fleeTimer = 2;
          } else if (a.fleeTimer > 0) {
            a.fleeTimer -= dt;
          } else if (dist < a.def.aggroRange) {
            // Slowly wander away from player
            const ang = Phaser.Math.Angle.Between(px, py, a.x, a.y);
            a.body.setVelocity(Math.cos(ang) * a.def.speed * 0.4, Math.sin(ang) * a.def.speed * 0.4);
          } else this.wander(a, dt, 0.3);
          // Visual: purple aura pulse
          if (!a._auraPulse || a._auraPulse <= 0) {
            a._auraPulse = 2;
            const aura = this.add.circle(a.x, a.y, 10, 0xAA55FF, 0.3).setDepth(4);
            this.tweens.add({ targets: aura, scale: 6, alpha: 0, duration: 1500, onComplete: () => aura.destroy() });
          }
          a._auraPulse -= dt;
        }
        else if (a.def.behavior === 'flee') {
          if (dist < a.def.fleeRange) {
            const ang = Phaser.Math.Angle.Between(px, py, a.x, a.y);
            a.body.setVelocity(Math.cos(ang)*a.def.speed, Math.sin(ang)*a.def.speed);
            a.fleeTimer = 2;
          } else if (a.fleeTimer > 0) {
            a.fleeTimer -= dt;
            a.body.velocity.normalize().scale(a.def.speed * (a.fleeTimer / 2));
          } else this.wander(a, dt, 0.3);
        } else if (a.def.behavior === 'chase') {
          // Snow leopard dash ability
          if (a.animalType === 'snow_leopard' && dist < 120 && dist > 30) {
            a._dashCD = (a._dashCD || 0) - dt;
            if (a._dashCD <= 0) {
              a._dashCD = 3;
              const dashAng = Phaser.Math.Angle.Between(a.x, a.y, px, py);
              const dashDist = 150;
              const nx = Phaser.Math.Clamp(a.x + Math.cos(dashAng) * dashDist, 40, WORLD_W - 40);
              const ny = Phaser.Math.Clamp(a.y + Math.sin(dashAng) * dashDist, 40, WORLD_H - 40);
              // Dash trail effect
              for (let di = 0; di < 4; di++) {
                const tp = this.add.circle(a.x + (nx-a.x)*di/4, a.y + (ny-a.y)*di/4, 4, 0xFFFFFF, 0.5).setDepth(14);
                this.tweens.add({ targets: tp, alpha: 0, scale: 0, duration: 300, onComplete: () => tp.destroy() });
              }
              a.setPosition(nx, ny);
            }
          }
          if (dist < a.def.aggroRange) {
            const ang = Phaser.Math.Angle.Between(a.x, a.y, px, py);
            const spdMul = a._shamanBuffed ? 1.2 : 1;
            a.body.setVelocity(Math.cos(ang)*a.def.speed*spdMul, Math.sin(ang)*a.def.speed*spdMul);
            if (dist < 28 && a.atkCD <= 0) {
              // Sprint invincibility
              if (this.activeBuffs.sprint || this._classSprintActive) { a.atkCD = 0.5; return; }
              // Survivor class: 15% dodge while moving
              const survivorDodge = (this._playerClass === 'survivor' && (this.moveDir.x !== 0 || this.moveDir.y !== 0)) ? 0.15 : 0;
              // Dodge check
              if ((this.upgradeManager.dodgeChance + survivorDodge) > 0 && Math.random() < (this.upgradeManager.dodgeChance + survivorDodge)) {
                a.atkCD = 0.8;
                this.showFloatingText(px, py - 25, 'üåÄ ÌöåÌîº!', '#88DDFF');
                return;
              }
              // Ironwall synergy: block chance
              if (this._synergyBlockChance > 0 && Math.random() < this._synergyBlockChance) {
                a.atkCD = 1.0;
                this.showFloatingText(px, py - 25, 'üõ°Ô∏è Î¨¥Ìö®!', '#FFD700');
                return;
              }
              if (this._invincibleTimer > 0) { a.atkCD = 1.0; this.showFloatingText(px, py - 25, 'üí´ Î¨¥Ï†Å!', '#FFD700'); return; }
              const natureBlessDef = this._natureBlessing ? 0.85 : 1;
              const dmgReduceMul = (this.activeRandomEvents && this.activeRandomEvents.damage_reduce) ? 0.5 : 1;
              // GLACIAL_WALL: +15% defense per level near ice walls (100px)
              let glacialDefMul = 1;
              if (this.upgradeManager._glacialWallLevel > 0 && this._worldObjects && this._worldObjects.iceWalls) {
                for (const wall of this._worldObjects.iceWalls) {
                  if (Phaser.Math.Distance.Between(px, py, wall.x, wall.y) < 100) { glacialDefMul = 1 - 0.15 * this.upgradeManager._glacialWallLevel; break; }
                }
              }
              const actualDmg = a.def.damage * (a._diffDmgMul || 1) * (1 - this.upgradeManager.armorReduction) * natureBlessDef * dmgReduceMul * glacialDefMul;
              this.playerHP -= actualDmg; a.atkCD = 1.2; playHurt();
              if (this._triggerHitVignette) this._triggerHitVignette();
              this._hitStop(50); // player hit hitstop
              // Thorns
              if (this.upgradeManager.thornsDamage > 0 && a.active) {
                a.hp -= this.upgradeManager.thornsDamage;
                this.showFloatingText(a.x, a.y - 20, 'üåµ' + this.upgradeManager.thornsDamage, '#44FF44');
                if (a.hp <= 0) this.killAnimal(a);
              }
              this.cameras.main.shake(120, 0.012);
              this.player.setTint(0xFF4444);
              this.time.delayedCall(150, ()=>{if(this.player.active)this.player.clearTint();});
              const dt2 = this.add.text(px, py-20, '-'+a.def.damage, {
                fontSize:'20px',fontFamily:'monospace',color:'#FF0000',stroke:'#000',strokeThickness:3,fontStyle:'bold'
              }).setDepth(15).setOrigin(0.5);
              this.tweens.add({targets:dt2, y:dt2.y-35, alpha:0, scale:{from:1.3,to:0.7}, duration:600, onComplete:()=>dt2.destroy()});
              if (this.playerHP <= 0) this.endGame();
            }
          } else this.wander(a, dt, 0.25);
        } else this.wander(a, dt, 0.3);
      }

      // ‚ïê‚ïê‚ïê BOSS PATTERN AI ‚ïê‚ïê‚ïê
      if (a.isBoss && !a.isMiniboss) {
        a.bossPatternTimer = (a.bossPatternTimer || 0) + dt;
        const hpRatio = a.hp / a.maxHP;

        // Final boss (55min) patterns
        if (a.isFinalBoss) {
          // Pattern 1: Snowstorm (every 30s)
          if (a.bossPatternTimer >= 30) {
            a.bossPatternTimer = 0;
            // Snowstorm visual + slow
            const stormG = this.add.graphics().setDepth(14);
            stormG.fillStyle(0x88CCFF, 0.25);
            stormG.fillCircle(a.x, a.y, 200);
            stormG.lineStyle(3, 0xAADDFF, 0.6);
            stormG.strokeCircle(a.x, a.y, 200);
            // Snow particles
            for (let i = 0; i < 20; i++) {
              const ang = Math.random() * Math.PI * 2;
              const r = Math.random() * 200;
              const sx = a.x + Math.cos(ang) * r, sy = a.y + Math.sin(ang) * r;
              const sp = this.add.circle(sx, sy, 3, 0xFFFFFF, 0.8).setDepth(15);
              this.tweens.add({ targets: sp, y: sp.y + 30, alpha: 0, duration: 1500, onComplete: () => sp.destroy() });
            }
            this.tweens.add({ targets: stormG, alpha: 0, duration: 2000, onComplete: () => stormG.destroy() });
            // Slow player if in range
            if (dist < 200) {
              const origSpeed = this.playerSpeed;
              this.playerSpeed *= 0.5;
              this.showFloatingText(this.player.x, this.player.y - 30, 'üå®Ô∏è ÎëîÌôî!', '#88CCFF');
              this.time.delayedCall(2000, () => { this.playerSpeed = origSpeed; });
            }
          }

          // Pattern 2: Enrage at 50% HP
          if (!a.bossEnraged && hpRatio <= 0.5) {
            a.bossEnraged = true;
            a.def.speed = Math.round(a.def.speed * 1.5);
            a.setTint(0xFF2222);
            this.showCenterAlert('üí¢ Î≥¥Ïä§ Î∂ÑÎÖ∏!', '#FF2222');
            this.cameras.main.shake(300, 0.015);
          }

          // Pattern 3: Minion summon at 33% HP
          if (!a.bossMinionSpawned && hpRatio <= 0.33) {
            a.bossMinionSpawned = true;
            this.showCenterAlert('üê∫ Ï¶ùÏõê!', '#FF6644');
            for (let i = 0; i < 3; i++) {
              const ea = Math.random() * Math.PI * 2;
              const ed = 50 + Math.random() * 50;
              const ex = Phaser.Math.Clamp(a.x + Math.cos(ea) * ed, 80, WORLD_W - 80);
              const ey = Phaser.Math.Clamp(a.y + Math.sin(ea) * ed, 80, WORLD_H - 80);
              const esc = this.physics.add.sprite(ex, ey, 'wolf').setCollideWorldBounds(true).setDepth(4);
              const escDef = { hp: 30, speed: 120, damage: 6, drops: { meat: 1, leather: 1 }, size: 18, behavior: 'chase', name: 'üê∫ ÎäëÎåÄ', aggroRange: 250, fleeRange: 0, fleeDistance: 0, color: 0x666688 };
              esc.animalType = 'wolf'; esc.def = escDef; esc.hp = escDef.hp; esc.maxHP = escDef.hp;
              esc.wanderTimer = 0; esc.wanderDir = { x: 0, y: 0 }; esc.hitFlash = 0; esc.atkCD = 0; esc.fleeTimer = 0;
              esc.hpBar = this.add.graphics().setDepth(6);
              esc.nameLabel = this.add.text(ex, ey - 28, 'üê∫ ÎäëÎåÄ', { fontSize: '11px', fontFamily: 'monospace', color: '#FFFFFF', stroke: '#000', strokeThickness: 3 }).setDepth(6).setOrigin(0.5);
              this.animals.add(esc);
            }
          }
        }

        // First boss (25min) pattern: enrage at 40% HP
        if (a.isFirstBoss && !a.bossEnraged && hpRatio <= 0.4) {
          a.bossEnraged = true;
          a.def.speed = Math.round(a.def.speed * 1.3);
          a.setTint(0xFF4444);
          this.showCenterAlert('üí¢ Î≥¥Ïä§ Î∂ÑÎÖ∏!', '#FF4444');
        }
      }

      // FROST_WALKER: slow nearby enemies when player is moving
      if (this.upgradeManager.frostWalkerActive && this.player.body &&
          (Math.abs(this.player.body.velocity.x) > 5 || Math.abs(this.player.body.velocity.y) > 5)) {
        if (dist < 150) {
          a.body.velocity.scale(0.9);
        }
      }
      // ICE_AURA: slow enemies within 100px
      if (this.upgradeManager.iceAuraLevel > 0 && dist < 100) {
        a.body.velocity.scale(1 - 0.3 * this.upgradeManager.iceAuraLevel);
      }

      // Î∞©Ìñ•Ïóê Îî∞Î•∏ Ïä§ÌîÑÎùºÏù¥Ìä∏ Ï†ÑÌôò (Îí∑Î™®Ïäµ Ìè¨Ìï®)
      const avx = a.body.velocity.x, avy = a.body.velocity.y;
      if (Math.abs(avx) > Math.abs(avy)) {
        // Ï¢åÏö∞ Ïù¥Îèô ‚Üí ÏïûÎ™®Ïäµ
        if (avx > 5) a.setFlipX(false);
        else if (avx < -5) a.setFlipX(true);
        if (Math.abs(avx) > 5) a.setTexture(a.animalType);
      } else if (avy < -5) {
        // ÏúÑÎ°ú Ïù¥Îèô ‚Üí Îí∑Î™®Ïäµ
        a.setTexture(a.animalType + '_back');
        a.setFlipX(false);
      } else if (avy > 5) {
        // ÏïÑÎûòÎ°ú Ïù¥Îèô ‚Üí ÏïûÎ™®Ïäµ
        a.setTexture(a.animalType);
      }
      if (a.nameLabel) a.nameLabel.setPosition(a.x, a.y - a.def.size - 14);
      if (a.hpBar) {
        a.hpBar.clear();
        const bw = 34, bx = a.x - bw/2, by = a.y - a.def.size - 8;
        a.hpBar.fillStyle(0x222222, 0.8); a.hpBar.fillRoundedRect(bx-1, by-1, bw+2, 7, 2);
        const r = a.hp / a.maxHP;
        a.hpBar.fillStyle(r > 0.6 ? 0x4CAF50 : r > 0.3 ? 0xFFEB3B : 0xF44336, 1);
        a.hpBar.fillRoundedRect(bx, by, bw * r, 5, 2);
      }
    });
  }

  wander(a, dt, speedMul) {
    a.wanderTimer -= dt;
    if (a.wanderTimer <= 0) {
      a.wanderTimer = Phaser.Math.FloatBetween(1.5, 4);
      if (Phaser.Math.Between(0, 2) === 0) a.wanderDir = { x: 0, y: 0 };
      else { const ang = Phaser.Math.FloatBetween(0, Math.PI*2); a.wanderDir = { x: Math.cos(ang), y: Math.sin(ang) }; }
    }
    a.body.setVelocity(a.wanderDir.x*a.def.speed*speedMul, a.wanderDir.y*a.def.speed*speedMul);
    // Frozen World: slow all enemies by 60%
    if (this.upgradeManager._frozenWorldActive && a.body) {
      a.body.velocity.scale(0.4);
    }
  }

  updateNPCs(dt) {
    this.npcsOwned.forEach(npc => {
      if (!npc.active) return;
      npc.actionTimer = Math.max(0, npc.actionTimer - dt);
      const followDist = 100;
      switch(npc.npcType) {
        case 'hunter': case 'warrior': {
          const dmg = npc.npcType === 'warrior' ? 3 : 1;
          const spd = npc.npcType === 'warrior' ? 130 : 100;
          let best = null, bestD = Infinity;
          this.animals.getChildren().forEach(a => {
            if (!a.active) return;
            const d = Phaser.Math.Distance.Between(npc.x, npc.y, a.x, a.y);
            if (d < 300 && d < bestD) { best = a; bestD = d; }
          });
          if (best) {
            const ang = Phaser.Math.Angle.Between(npc.x, npc.y, best.x, best.y);
            npc.body.setVelocity(Math.cos(ang)*spd, Math.sin(ang)*spd);
            if (bestD < 40 && npc.actionTimer <= 0) {
              this.damageAnimal(best, dmg);
              npc.actionTimer = npc.npcType === 'warrior' ? 0.5 : 0.8;
              // ÏÇ¨ÎÉ•Íæº/Ï†ÑÏÇ¨ ÌÉÄÍ≤© ÏÇ¨Ïö¥Îìú - Í±∞Î¶¨ Í∏∞Î∞ò Í∞êÏá† Ï†ÅÏö©
              const distToPlayer = Phaser.Math.Distance.Between(npc.x, npc.y, this.player.x, this.player.y);
              _playSFX('hit', 0.35, distToPlayer, 400);
            }
          } else this.followPlayer(npc, followDist);
          break;
        }
        case 'gatherer': {
          let best = null, bestD = Infinity;
          this.resourceNodes.forEach(n => {
            if (n.depleted) return;
            const d = Phaser.Math.Distance.Between(npc.x, npc.y, n.x, n.y);
            if (d < 250 && d < bestD) { best = n; bestD = d; }
          });
          if (best) {
            const ang = Phaser.Math.Angle.Between(npc.x, npc.y, best.x, best.y);
            npc.body.setVelocity(Math.cos(ang)*80, Math.sin(ang)*80);
            if (bestD < 30 && npc.actionTimer <= 0) { this.harvestNode(best); npc.actionTimer = 1.5; }
          } else this.followPlayer(npc, followDist);
          break;
        }
        case 'merchant': {
          this.followPlayer(npc, 60);
          if (npc.actionTimer <= 0 && this.res.meat >= 5) {
            this.res.meat -= 5; this.res.gold += Math.floor(3 * (1 + this.upgradeManager.sellBonus)); npc.actionTimer = 3.0;
            const t = this.add.text(npc.x, npc.y-15, 'üí∞+3', {fontSize:'15px',fontFamily:'monospace',color:'#FFD700',stroke:'#000',strokeThickness:3}).setDepth(15).setOrigin(0.5);
            this.tweens.add({targets:t, y:t.y-25, alpha:0, duration:600, onComplete:()=>t.destroy()});
          }
          break;
        }
      }
      // NPC Î∞©Ìñ•Ïóê Îî∞Î•∏ Ïä§ÌîÑÎùºÏù¥Ìä∏ Ï†ÑÌôò (Îí∑Î™®Ïäµ Ìè¨Ìï®)
      const nvx = npc.body.velocity.x, nvy = npc.body.velocity.y;
      if (Math.abs(nvx) > Math.abs(nvy)) {
        if (nvx > 5) npc.setFlipX(false);
        else if (nvx < -5) npc.setFlipX(true);
        if (Math.abs(nvx) > 5) npc.setTexture('npc_' + npc.npcType);
      } else if (nvy < -5) {
        npc.setTexture('npc_' + npc.npcType + '_back');
        npc.setFlipX(false);
      } else if (nvy > 5) {
        npc.setTexture('npc_' + npc.npcType);
      }
      this.drops.getChildren().forEach(d => {
        if (!d.active) return;
        if (Phaser.Math.Distance.Between(npc.x, npc.y, d.x, d.y) < 25) this.collectDrop(d);
      });
    });
  }

  followPlayer(npc, dist) {
    const d = Phaser.Math.Distance.Between(npc.x, npc.y, this.player.x, this.player.y);
    if (d > dist) {
      const a = Phaser.Math.Angle.Between(npc.x, npc.y, this.player.x, this.player.y);
      npc.body.setVelocity(Math.cos(a)*90, Math.sin(a)*90);
    } else npc.body.setVelocity(0, 0);
  }

  hireNPC(index) {
    if (this.gameOver || index >= NPC_DEFS.length) return;
    const def = NPC_DEFS[index];
    for (const [r, amt] of Object.entries(def.cost)) { if ((this.res[r]||0) < amt) return; }
    for (const [r, amt] of Object.entries(def.cost)) this.res[r] -= amt;
    const npc = this.physics.add.sprite(
      this.player.x + Phaser.Math.Between(-30,30), this.player.y + Phaser.Math.Between(-30,30),
      'npc_'+def.type).setCollideWorldBounds(true).setDepth(9);
    npc.npcType = def.type; npc.npcDef = def; npc.actionTimer = 0;
    this.npcSprites.add(npc); this.npcsOwned.push(npc); this.stats.npcsHired++; playHire();
    const ht = this.add.text(npc.x, npc.y-20, '‚ú® '+def.name+' Í≥†Ïö©!', {
      fontSize:'16px',fontFamily:'monospace',color:'#FFD700',stroke:'#000',strokeThickness:3
    }).setDepth(20).setOrigin(0.5);
    this.tweens.add({targets:ht, y:ht.y-40, alpha:0, duration:1200, onComplete:()=>ht.destroy()});
    for(let i=0;i<8;i++){
      const p = this.add.image(npc.x, npc.y, 'gold_particle').setDepth(15);
      this.tweens.add({targets:p, x:npc.x+Phaser.Math.Between(-35,35), y:npc.y+Phaser.Math.Between(-35,35),
        alpha:0, scale:{from:1.5,to:0}, duration:500, onComplete:()=>p.destroy()});
    }
  }

  placeBuilding(pointer) {
    if (!this.buildMode) return;
    const def = BUILDINGS[this.buildMode];
    for (const [r, amt] of Object.entries(def.cost)) {
      if ((this.res[r]||0) < amt) { this.showFloatingText(this.player.x, this.player.y-20, '‚ùå ÏûêÏõê Î∂ÄÏ°±!', '#FF6666'); this.buildMode = null; return; }
    }
    for (const [r, amt] of Object.entries(def.cost)) this.res[r] -= amt;
    const wx = pointer.worldX, wy = pointer.worldY;
    const g = this.add.graphics().setDepth(2);
    
    if (this.buildMode === 'campfire') {
      g.fillStyle(0x884422, 1); g.fillRect(wx-12, wy+6, 24, 6);
      g.fillStyle(0x664411, 1); g.fillRect(wx-10, wy+3, 20, 5);
      g.fillStyle(0x777777, 1);
      for (let i = 0; i < 8; i++) {
        const a2 = (i / 8) * Math.PI * 2;
        g.fillCircle(wx + Math.cos(a2)*14, wy + Math.sin(a2)*14, 3);
      }
      g.fillStyle(0xFF4400, 0.9); g.fillCircle(wx, wy, 10);
      g.fillStyle(0xFF8800, 0.8); g.fillCircle(wx, wy-2, 7);
      g.fillStyle(0xFFCC00, 0.6); g.fillCircle(wx, wy-4, 4);
      g.fillStyle(0xFFFF88, 0.4); g.fillCircle(wx, wy-5, 2);
    } else if (this.buildMode === 'tent') {
      g.fillStyle(0x8B6914, 0.9); g.fillTriangle(wx, wy-26, wx-24, wy+12, wx+24, wy+12);
      g.fillStyle(0xA07B28, 0.7); g.fillTriangle(wx, wy-22, wx-20, wy+10, wx+20, wy+10);
      g.fillStyle(0x5D4037, 1); g.fillRect(wx-5, wy+2, 10, 10);
    } else if (this.buildMode === 'storage') {
      g.fillStyle(0x795548, 1); g.fillRect(wx-18, wy-16, 36, 32);
      g.fillStyle(0x8D6E63, 1); g.fillTriangle(wx, wy-24, wx-20, wy-14, wx+20, wy-14);
      g.fillStyle(0x5D4037, 1); g.fillRect(wx-5, wy+4, 10, 12);
      g.lineStyle(1, 0x4E342E); g.strokeRect(wx-18, wy-16, 36, 32);
    } else if (this.buildMode === 'workshop') {
      g.fillStyle(0x795548, 1); g.fillRect(wx-16, wy-14, 32, 28);
      g.fillStyle(0x8D6E63, 1); g.fillTriangle(wx, wy-22, wx-18, wy-12, wx+18, wy-12);
      g.fillStyle(0x5D4037, 1); g.fillRect(wx-5, wy+4, 10, 10);
      g.fillStyle(0x555555, 1); g.fillRect(wx+8, wy+4, 8, 5);
    } else if (this.buildMode === 'wall') {
      g.fillStyle(0x9E9E9E, 1); g.fillRect(wx-20, wy-10, 40, 20);
      g.fillStyle(0xBBBBBB, 0.5);
      g.fillRect(wx-18, wy-8, 10, 8); g.fillRect(wx-5, wy-8, 10, 8); g.fillRect(wx+8, wy-8, 10, 8);
      g.lineStyle(1, 0x757575); g.strokeRect(wx-20, wy-10, 40, 20);
    }

    const label = this.add.text(wx, wy-32, def.icon, {fontSize:'22px'}).setDepth(3).setOrigin(0.5);
    const bld = { type: this.buildMode, x: wx, y: wy, graphic: g, label, def };
    this.placedBuildings.push(bld);
    if (!this.stats.built[this.buildMode]) this.stats.built[this.buildMode] = 0;
    this.stats.built[this.buildMode]++;
    if (def.storageBonus) this.storageCapacity += def.storageBonus;
    playBuild(); this.showFloatingText(wx, wy - 40, '‚úÖ '+def.name+' Í±¥ÏÑ§!', '#4CAF50');
    SaveManager.save(this); this._showSaveIndicator();
    for (let i = 0; i < 8; i++) {
      const p = this.add.image(wx, wy, 'snowflake').setDepth(15).setTint(0xFFDD88).setScale(1.2);
      this.tweens.add({ targets: p, x: wx + Phaser.Math.Between(-35, 35), y: wy + Phaser.Math.Between(-35, 35),
        alpha: 0, duration: 500, onComplete: () => p.destroy() });
    }
    this.buildMode = null;
  }

  updateCampfireSystem(dt) {
    this.campfireGlow.clear();
    this._nearCampfire = false;
    this._campfireAttackBonus = 1;

    this.placedBuildings.forEach(b => {
      if (b.type !== 'campfire') return;
      const effects = b.def.effects;
      const warmthR = b.def.warmthRadius;
      const time = this.time.now / 1000;

      // 3-tier warmth zone
      this.campfireGlow.fillStyle(0xFF8844, 0.04 + Math.sin(time * 1.5) * 0.01);
      this.campfireGlow.fillCircle(b.x, b.y, warmthR);
      this.campfireGlow.lineStyle(1, 0xFF8844, 0.1);
      this.campfireGlow.strokeCircle(b.x, b.y, warmthR);

      this.campfireGlow.fillStyle(0xFF6622, 0.07 + Math.sin(time * 2) * 0.02);
      this.campfireGlow.fillCircle(b.x, b.y, 100);
      this.campfireGlow.lineStyle(1, 0xFF6622, 0.15);
      this.campfireGlow.strokeCircle(b.x, b.y, 100);

      this.campfireGlow.fillStyle(0xFF4400, 0.12 + Math.sin(time * 3) * 0.03);
      this.campfireGlow.fillCircle(b.x, b.y, 60);
      this.campfireGlow.lineStyle(1.5, 0xFF4400, 0.25);
      this.campfireGlow.strokeCircle(b.x, b.y, 60);

      const pd = Phaser.Math.Distance.Between(this.player.x, this.player.y, b.x, b.y);
      if (pd < warmthR) {
        this._nearCampfire = true;
        this._warmthNearFireTime = (this._warmthNearFireTime || 0) + dt; // ÌÄòÏä§Ìä∏ Ï∂îÏ†Å
        const intensity = 1 - (pd / warmthR);
        const cfBoost = this.upgradeManager.campfireBoost;
        this.temperature = Math.min(this.maxTemp, this.temperature + effects.healthRegen * intensity * dt * cfBoost);
        this.playerHP = Math.min(this.playerMaxHP, this.playerHP + effects.healthRegen * intensity * dt * cfBoost);
        this.res.gold = (this.res.gold || 0) + effects.goldGeneration * intensity * dt * cfBoost;
        if (pd < 100) {
          this._campfireAttackBonus = Math.max(this._campfireAttackBonus, effects.attackSpeedBonus);
          this.playerSpeed = this.playerBaseSpeed * effects.moveSpeedBonus;
        }
        // Campfire HP regen indicator text
        if (!b._regenLabel) {
          b._regenLabel = this.add.text(b.x, b.y - 30, 'üî• HP+1/s', {
            fontSize: '11px', fontFamily: 'monospace', color: '#FF8844',
            stroke: '#000', strokeThickness: 2
          }).setDepth(12).setOrigin(0.5).setAlpha(0.6);
          this.tweens.add({ targets: b._regenLabel, y: b.y - 35, yoyo: true, repeat: -1, duration: 1500, ease: 'Sine.InOut' });
        }
        if (pd < 100 && b._regenLabel) b._regenLabel.setAlpha(0.8);
        else if (b._regenLabel) b._regenLabel.setAlpha(0.4);
      } else {
        if (b._regenLabel) b._regenLabel.setAlpha(0.2);
      }
    });

    if (!this._nearCampfire) {
      let blizzardSlow = 1;
      if (this.blizzardActive && !this.upgradeManager.blizzardCloakActive && !this._survivorBlizzardCloak) {
        blizzardSlow = this.upgradeManager._arcticAdaptActive ? 1.05 : 0.8; // ARCTIC_ADAPT: +5% instead of -20%
      }
      this.playerSpeed = this.playerBaseSpeed * blizzardSlow;
    }

    // Shield Bash cooldown
    if (this.upgradeManager.shieldBashActive) {
      this.upgradeManager.shieldBashCD -= dt;
      if (this.upgradeManager.shieldBashCD <= 0) { this.upgradeManager.shieldBashReady = true; this.upgradeManager.shieldBashCD = 5; }
    }
    // Time Warp
    if (this.upgradeManager.timeWarpLevel > 0) {
      this.upgradeManager.timeWarpCD -= dt;
      if (this.upgradeManager.timeWarpCD <= 0) {
        this.upgradeManager.timeWarpCD = 15;
        this.animals.getChildren().forEach(a => {
          if (!a.active) return;
          const d = Phaser.Math.Distance.Between(this.player.x, this.player.y, a.x, a.y);
          if (d < 100 * this.upgradeManager.timeWarpLevel) {
            const sv = { x: a.body.velocity.x, y: a.body.velocity.y };
            a.body.setVelocity(0, 0); a.body.moves = false;
            this.showFloatingText(a.x, a.y - 20, '‚è∞', '#AADDFF');
            this.time.delayedCall(1000, () => { if (a.active) { a.body.moves = true; a.body.setVelocity(sv.x, sv.y); } });
          }
        });
      }
    }
    // Adrenaline
    if (this.upgradeManager.adrenalineLevel > 0) {
      this._adrenalineActive = (this.playerHP / this.playerMaxHP) <= 0.3;
    }

    // üîä Fire ambient
    if(this._nearCampfire&&!fireAmbSrc)startFire();else if(!this._nearCampfire&&fireAmbSrc)stopFire();

    // Fire particles
    this.campfireParticleTimer += dt;
    if (this.campfireParticleTimer > 0.1) {
      this.campfireParticleTimer = 0;
      this.placedBuildings.forEach(cb => {
        if (cb.type !== 'campfire') return;
        const fp = this.add.image(cb.x + Phaser.Math.Between(-8, 8), cb.y + Phaser.Math.Between(-5, 5), 'fire_particle')
          .setDepth(15).setScale(Phaser.Math.FloatBetween(0.8, 2.0));
        this.tweens.add({ targets: fp, y: fp.y - Phaser.Math.Between(20, 50), x: fp.x + Phaser.Math.Between(-15, 15),
          alpha: 0, scale: 0, duration: Phaser.Math.Between(400, 800), onComplete: () => fp.destroy() });
      });
    }

    // Tent effects
    this.placedBuildings.forEach(b => {
      if (b.type !== 'tent' || !b.def.effects) return;
      const pd = Phaser.Math.Distance.Between(this.player.x, this.player.y, b.x, b.y);
      if (pd < 80) this.playerHP = Math.min(this.playerMaxHP, this.playerHP + b.def.effects.healthRegen * dt);
    });
  }

  craftItem(key) {
    const recipe = RECIPES[key];
    for (const [r, amt] of Object.entries(recipe.cost)) {
      if ((this.res[r]||0) < amt) { this.showFloatingText(this.player.x, this.player.y-20, '‚ùå Ïû¨Î£å Î∂ÄÏ°±!', '#FF6666'); return; }
    }
    for (const [r, amt] of Object.entries(recipe.cost)) this.res[r] -= amt;
    switch(recipe.effect) {
      case 'woodBonus': this.woodBonus += recipe.value; break;
      case 'stoneBonus': this.stoneBonus += recipe.value; break;
      case 'damage': this.playerDamage = Math.min(30, this.playerDamage + recipe.value); break;
      case 'warmthResist': this.warmthResist = Math.min(1.0, this.warmthResist + recipe.value); break;
      case 'speed': this.playerSpeed = Math.min(300, this.playerSpeed + recipe.value); this.playerBaseSpeed = Math.min(300, this.playerBaseSpeed + recipe.value); break;
    }
    this.stats.crafted++; playCraft(); SaveManager.save(this);
    this.showFloatingText(this.player.x, this.player.y - 30, '‚ú® '+recipe.icon+' '+recipe.name+' Ï†úÏûë!', '#64B5F6');
  }

  updateSurvival(dt) {
    // Base temp decay + zone penalty, multiplied by blizzard
    const zone = this.getPlayerZone();
    const zoneDecay = ZONE_TEMP_DECAY[zone] || 0;
    const baseDecay = 0.5 * (1 - this.warmthResist); // warmthResist now directly reduces decay
    const frostRes = this.upgradeManager ? this.upgradeManager.frostResistance : 0;
    const woolMul = this.activeBuffs.wool ? 0.5 : 1; // ÏñëÌÑ∏ÏäàÌä∏: Ï≤¥Ïò® ÏÜåÎ™® 50% Í∞êÏÜå
    const sprintFreeze = this.activeBuffs.sprint ? 0 : 1; // Îã¨Î¶¨Í∏∞: Ï≤¥Ïò® ÏÜåÎ™® ÏóÜÏùå
    const diffColdMul = this._diffMode ? this._diffMode.coldDmg : 1;
    const dailyBlizzard = (this._dailyModifier && this._dailyModifier.alwaysBlizzard) ? 2.0 : 1;
    const effectiveBlizzard = Math.max(this.blizzardMultiplier, dailyBlizzard);
    const ngPlusColdMul = this._ngPlusColdMul || 1;
    if (!this._bossRushMode) // Boss Rush: no cold waves
    this.temperature = Math.max(0, this.temperature - (baseDecay + Math.abs(zoneDecay)) * effectiveBlizzard * diffColdMul * ngPlusColdMul * (1 - frostRes) * woolMul * sprintFreeze * dt);
    this.placedBuildings.forEach(b => {
      if (b.type === 'campfire') return;
      if (!b.def.warmth) return;
      const d = Phaser.Math.Distance.Between(this.player.x, this.player.y, b.x, b.y);
      if (d < 80) this.temperature = Math.min(this.maxTemp, this.temperature + b.def.warmth * dt);
    });
    let hungerRate = 0.8;
    this.placedBuildings.forEach(b => {
      if (b.type === 'tent' && b.def.effects) {
        const d = Phaser.Math.Distance.Between(this.player.x, this.player.y, b.x, b.y);
        if (d < 80) hungerRate *= b.def.effects.hungerSlowdown;
      }
    });
    this.hunger = Math.max(0, this.hunger - hungerRate * dt);
    if (this.temperature <= 0) {
      // Cold master synergy: pulse immunity
      if (this._coldImmunePulse) { this._coldImmunePulse = false; }
      else {
        let coldDmg = 8 * (this._diffMode ? this._diffMode.coldDmg : 1);
        // COLD_RESISTANCE: reduce blizzard damage by 20% per level
        if (this.upgradeManager._coldResistBlizzardReduce > 0) coldDmg *= (1 - this.upgradeManager._coldResistBlizzardReduce);
        this.playerHP -= coldDmg * dt; if (this.playerHP <= 0) this.endGame();
      }
    }
    if (this.hunger <= 0) { this.playerHP -= 5 * dt; if (this.playerHP <= 0) this.endGame(); }
    if (this.hunger < 30 && this.res.meat > 0) {
      this.res.meat--; this.hunger = Math.min(this.maxHunger, this.hunger + 25);
      playEat(); this.showFloatingText(this.player.x, this.player.y - 20, 'ü•© ÏûêÎèô ÏÑ≠Ï∑®', '#FF9800');
    }
  }

  checkQuests() {
    if (this.questIndex >= QUESTS.length) return;
    const q = QUESTS[this.questIndex];
    if (q.check(this.stats, this)) {
      Object.entries(q.reward).forEach(([r, amt]) => this.res[r] = (this.res[r]||0) + amt);
      // Special reward effects
      if (q.rewardEffect) {
        if (q.rewardEffect.tempBonus) this.temperature = Math.min(this.maxTemp, this.temperature + q.rewardEffect.tempBonus);
        if (q.rewardEffect.maxHPBonus) { this.playerMaxHP += q.rewardEffect.maxHPBonus; this.playerHP += q.rewardEffect.maxHPBonus; }
      }
      this.questCompleted.push(q.id); this.questIndex++; playQuest();
      // ÌÄòÏä§Ìä∏ ÏôÑÎ£å ÎàÑÍ≥Ñ Í∏∞Î°ù
      try { const _r = RecordManager.load(); _r.totalQuestsCompleted = (_r.totalQuestsCompleted||0) + 1; RecordManager.save(_r); } catch(e) {}
      const cam = this.cameras.main;
      const qText = this.add.text(cam.width/2, cam.height * 0.3, 'üéâ ÌÄòÏä§Ìä∏ ÏôÑÎ£å!\n'+q.name, {
        fontSize:'22px',fontFamily:'monospace',color:'#FFD700',stroke:'#000',strokeThickness:4,align:'center',lineSpacing:4
      }).setScrollFactor(0).setDepth(200).setOrigin(0.5);
      this.tweens.add({targets:qText, y:qText.y-30, alpha:0, duration:2000, delay:500, onComplete:()=>qText.destroy()});
    }
  }

  interactNearest() {
    if (this.res.meat > 0 && this.hunger < 80) {
      this.res.meat--; this.hunger = Math.min(this.maxHunger, this.hunger + 25);
      this.playerHP = Math.min(this.playerMaxHP, this.playerHP + 2);
      playEat(); this.showFloatingText(this.player.x, this.player.y - 20, 'ü•© ÌöåÎ≥µ!', '#4CAF50');
    }
  }

  // ‚ïê‚ïê‚ïê PERF: Object Pool Methods ‚ïê‚ïê‚ïê
  getParticle(x, y, texture) {
    let p = this._particlePool.find(pp => !pp.visible);
    if (p) {
      p.setPosition(x, y).setTexture(texture).setVisible(true).setActive(true).setAlpha(1).setScale(1).clearTint();
      return p;
    }
    p = this.add.image(x, y, texture).setDepth(15);
    if (this._particlePool.length < this._particlePoolMax) this._particlePool.push(p);
    return p;
  }
  returnParticle(p) {
    if (p) { p.setVisible(false).setActive(false); }
  }
  getPooledText(x, y, text, style) {
    let t = this._textPool.find(tt => !tt.visible);
    if (t) {
      t.setPosition(x, y).setText(text).setStyle(style).setVisible(true).setActive(true).setAlpha(1).setScale(1).setOrigin(0.5);
      return t;
    }
    t = this.add.text(x, y, text, style).setDepth(20).setOrigin(0.5);
    if (this._textPool.length < this._textPoolMax) this._textPool.push(t);
    return t;
  }
  returnPooledText(t) {
    if (t) { t.setVisible(false).setActive(false); }
  }

  showFloatingText(x, y, text, color, sizeOverride) {
    // Consistent text hierarchy: detect type by content
    let fontSize = sizeOverride || 14;
    let fontStyle = '';
    if (text.includes('CRITICAL') || text.includes('üí•')) { fontSize = 20; fontStyle = 'bold'; }
    else if (text.includes('Î†àÎ≤®') || text.includes('üéä')) { fontSize = 24; fontStyle = 'bold'; }
    const style = {fontSize:fontSize+'px',fontFamily:'monospace',color:color,stroke:'#000',strokeThickness:3,fontStyle:fontStyle};
    const t = this.getPooledText(x, y, text, style);
    this.tweens.add({ targets: t, y: t.y - 30, alpha: 0, duration: 800, onComplete: () => this.returnPooledText(t) });
  }

  createVirtualJoystick() {
    this.joystickActive = false;
    this._vjoy = null; // virtual joystick state
    this._smoothMove = { x: 0, y: 0 }; // for lerp smoothing
    const self = this;

    // Clean up existing joystick if any (prevent duplicates on restart)
    const existingBase = document.getElementById('vjoystick-base');
    if (existingBase) existingBase.remove();

    // Create joystick container (hidden by default ‚Äî dynamic joystick)
    const base = document.createElement('div');
    base.id = 'vjoystick-base';
    base.style.cssText = `
      position:fixed; width:160px; height:160px;
      left:0; top:0;
      border-radius:50%; border:2.5px solid rgba(255,255,255,0.25);
      background:radial-gradient(circle, rgba(255,255,255,0.10) 0%, rgba(255,255,255,0.03) 100%);
      pointer-events:none; z-index:2000;
      opacity:0; visibility:hidden;
      transform:translate(-50%,-50%);
      transition: opacity 0.12s ease, visibility 0.12s ease;
    `;
    const knob = document.createElement('div');
    knob.id = 'vjoystick-knob';
    knob.style.cssText = `
      position:absolute; width:70px; height:70px; border-radius:50%;
      background:radial-gradient(circle, rgba(255,255,255,0.45) 0%, rgba(255,255,255,0.2) 100%);
      border:2px solid rgba(255,255,255,0.55);
      top:50%; left:50%; transform:translate(-50%,-50%);
      pointer-events:none;
    `;
    base.appendChild(knob);
    document.body.appendChild(base);

    const showJoystick = (cx, cy) => {
      base.style.left = cx + 'px';
      base.style.top = cy + 'px';
      base.style.opacity = '0.55';
      base.style.visibility = 'visible';
      knob.style.transform = 'translate(-50%, -50%)';
      self._vjoy = { cx, cy };
      self.joystickActive = true;
    };

    const hideJoystick = () => {
      base.style.opacity = '0';
      base.style.visibility = 'hidden';
      knob.style.transform = 'translate(-50%, -50%)';
      self.joystickActive = false;
      self._smoothMove.x = 0;
      self._smoothMove.y = 0;
    };

    const updateKnob = (clientX, clientY) => {
      const dx = clientX - self._vjoy.cx;
      const dy = clientY - self._vjoy.cy;
      const dist = Math.sqrt(dx * dx + dy * dy);
      const maxR = 60;
      const clamp = Math.min(dist, maxR);
      const ang = Math.atan2(dy, dx);
      const kx = Math.cos(ang) * clamp;
      const ky = Math.sin(ang) * clamp;
      knob.style.transform = `translate(calc(-50% + ${kx}px), calc(-50% + ${ky}px))`;

      if (dist > 8) {
        const strength = Math.min(1, dist / maxR);
        self._smoothMove.x = Math.cos(ang) * strength;
        self._smoothMove.y = Math.sin(ang) * strength;
      } else {
        self._smoothMove.x = 0;
        self._smoothMove.y = 0;
      }
    };

    const isUITouch = (cx, cy) => {
      const h = window.innerHeight;
      const safeB = self.safeBottom || 0;
      if (cy > h - 60 - safeB) return true;
      if (cy < 120 && cx < 260) return true;
      if (self.activePanel && cx > window.innerWidth - 240 && cy > 60) return true;
      return false;
    };

    // Track which touch ID is the joystick
    let activeTouchId = null;

    const onStart = (e) => {
      resumeAudio(); // Mobile Safari: unlock AudioContext on first touch
      if (self.gameOver) return;
      for (let i = 0; i < e.changedTouches.length; i++) {
        const t = e.changedTouches[i];
        if (activeTouchId !== null) break;
        if (isUITouch(t.clientX, t.clientY)) continue;
        const el = document.elementFromPoint(t.clientX, t.clientY);
        if (el && (el.tagName === 'BUTTON' || el.closest('#bottom-buttons') || el.closest('#dom-hud'))) continue;

        e.preventDefault();
        activeTouchId = t.identifier;
        showJoystick(t.clientX, t.clientY);
        break;
      }
    };

    const onMove = (e) => {
      if (activeTouchId === null) return;
      for (let i = 0; i < e.changedTouches.length; i++) {
        const t = e.changedTouches[i];
        if (t.identifier !== activeTouchId) continue;
        e.preventDefault();
        updateKnob(t.clientX, t.clientY);
        break;
      }
    };

    const onEnd = (e) => {
      for (let i = 0; i < e.changedTouches.length; i++) {
        if (e.changedTouches[i].identifier === activeTouchId) {
          activeTouchId = null;
          hideJoystick();
          break;
        }
      }
    };

    document.addEventListener('touchstart', onStart, { passive: false });
    document.addEventListener('touchmove', onMove, { passive: false });
    document.addEventListener('touchend', onEnd, { passive: false });
    document.addEventListener('touchcancel', onEnd, { passive: false });

    // ‚îÄ‚îÄ‚îÄ Desktop mouse support (dynamic joystick via mouse drag) ‚îÄ‚îÄ‚îÄ
    const MOUSE_ID = -1;
    const onMouseDown = (e) => {
      if (self.gameOver) return;
      if (isUITouch(e.clientX, e.clientY)) return;
      const el = document.elementFromPoint(e.clientX, e.clientY);
      if (el && (el.tagName === 'BUTTON' || el.closest('#bottom-buttons') || el.closest('#dom-hud'))) return;
      if (activeTouchId !== null) return;
      activeTouchId = MOUSE_ID;
      showJoystick(e.clientX, e.clientY);
    };
    const onMouseMove = (e) => {
      if (activeTouchId !== MOUSE_ID) return;
      updateKnob(e.clientX, e.clientY);
    };
    const onMouseUp = () => {
      if (activeTouchId !== MOUSE_ID) return;
      activeTouchId = null;
      hideJoystick();
    };
    document.addEventListener('mousedown', onMouseDown);
    document.addEventListener('mousemove', onMouseMove);
    document.addEventListener('mouseup', onMouseUp);

    // Cleanup on scene shutdown
    this.events.once('shutdown', () => {
      document.removeEventListener('touchstart', onStart);
      document.removeEventListener('touchmove', onMove);
      document.removeEventListener('touchend', onEnd);
      document.removeEventListener('touchcancel', onEnd);
      document.removeEventListener('mousedown', onMouseDown);
      document.removeEventListener('mousemove', onMouseMove);
      document.removeEventListener('mouseup', onMouseUp);
      const baseEl = document.getElementById('vjoystick-base');
      if (baseEl) baseEl.remove();
      // Hide DOM HUD on scene exit
      const domHud = document.getElementById('dom-hud');
      const bottomBtns = document.getElementById('bottom-buttons');
      if (domHud) domHud.style.visibility = 'hidden';
      if (bottomBtns) bottomBtns.style.display = 'none';
      // Cleanup fog of war graphics
      if (this._fogGraphics) { this._fogGraphics.destroy(); this._fogGraphics = null; }
      if (this._fogMaskShape) { this._fogMaskShape.destroy(); this._fogMaskShape = null; }
      this._fogMask = null;
      // Cleanup speedrun HUD
      if (this._speedrunTimerText) { this._speedrunTimerText.destroy(); this._speedrunTimerText = null; }
      // PERF: cleanup world objects
      if (this._worldObjects) {
        ['campfires','crates','iceWalls','flares'].forEach(k => {
          if (this._worldObjects[k]) this._worldObjects[k].forEach(o => { if(o.gfx) o.gfx.destroy(); if(o.particles) o.particles.forEach(p=>p.destroy()); });
          this._worldObjects[k] = [];
        });
      }
      if (this._campfireHudText) { this._campfireHudText.destroy(); this._campfireHudText = null; }
      if (this._flareHudText) { this._flareHudText.destroy(); this._flareHudText = null; }
      if (this._flareAura) { this._flareAura.destroy(); this._flareAura = null; }
      // PERF: cleanup ice bolts
      if (this._iceBolts) { this._iceBolts.forEach(b => b.destroy()); this._iceBolts = []; }
      // PERF: cleanup pooled objects
      if (this._particlePool) { this._particlePool.forEach(p => p.destroy()); this._particlePool = []; }
      if (this._textPool) { this._textPool.forEach(t => t.destroy()); this._textPool = []; }
      // PERF: clear tracked timers
      if (this._timerIds) { this._timerIds.forEach(id => { clearTimeout(id); clearInterval(id); }); this._timerIds = []; }
      // PERF: cleanup debug FPS
      if (this._fpsText) { this._fpsText.destroy(); this._fpsText = null; }
      // Stop audio on scene exit
      stopBGM(); stopWindAmbience();
    });
  }

  createUI() {
    // Restore DOM HUD visibility on game start
    const domHud = document.getElementById('dom-hud');
    const bottomBtns = document.getElementById('bottom-buttons');
    if (domHud) domHud.style.visibility = 'visible';
    if (bottomBtns) bottomBtns.style.display = '';
    // HUD is now fully DOM-based (see index.html #dom-hud)
    // Create inventory capacity element dynamically
    const resEl = document.getElementById('res-text');
    let invCapEl = document.getElementById('inv-cap');
    if (!invCapEl && resEl && resEl.parentNode) {
      invCapEl = document.createElement('div');
      invCapEl.id = 'inv-cap';
      invCapEl.style.cssText = 'font-size:11px;color:#AABBCC;margin-top:2px;';
      resEl.parentNode.insertBefore(invCapEl, resEl.nextSibling);
    }
    this._dom = {
      res: resEl,
      invCap: invCapEl,
      hpFill: document.getElementById('hp-fill'),
      hpText: document.getElementById('hp-text'),
      tempFill: document.getElementById('temp-fill'),
      tempText: document.getElementById('temp-text'),
      hungerFill: document.getElementById('hunger-fill'),
      hungerText: document.getElementById('hunger-text'),
      quest: document.getElementById('quest-text'),
      buff: document.getElementById('buff-text'),
      xpFill: document.getElementById('xp-fill'),
      xpText: document.getElementById('xp-text'),
      actText: document.getElementById('act-text'),
      nextEventText: document.getElementById('next-event-text'),
      classHud: document.getElementById('class-hud'),
      classNameText: document.getElementById('class-name-text'),
      classSkillCd: document.getElementById('class-skill-cd'),
      timelineBar: document.getElementById('timeline-bar'),
      timelineFill: document.getElementById('timeline-fill'),
    };

    // ‚ïê‚ïê‚ïê DOM Buttons (100% reliable touch) ‚ïê‚ïê‚ïê
    const scene = this;
    const bind = (id, fn) => {
      const el = document.getElementById(id);
      if (!el) return;
      el.addEventListener('pointerdown', (e) => { e.stopPropagation(); e.preventDefault(); resumeAudio(); fn(); });
    };
    bind('btn-build', () => scene.toggleBuildMenu());
    bind('btn-craft', () => scene.toggleCraftMenu());
    bind('btn-hire', () => scene.toggleHireMenu());
    bind('btn-inv', () => scene.toggleInventoryMenu());
    bind('btn-eat', () => scene.interactNearest());
    // Button bounce animation
    document.querySelectorAll('#bottom-buttons button').forEach(btn => {
      btn.addEventListener('pointerdown', () => {
        btn.classList.remove('btn-bouncing');
        void btn.offsetWidth;
        btn.classList.add('btn-bouncing');
      });
    });
    bind('btn-sound', () => {
      soundEnabled = !soundEnabled;
      if (!soundEnabled) { stopFire(); stopBGM(); stopWindAmbience(); _bgmStarted=false; }
      else { _bgmStarted=false; resumeAudio(); }
      const el = document.getElementById('btn-sound');
      if (el) el.textContent = soundEnabled ? 'üîä' : 'üîá';
    });

    this.panelBg = this.add.graphics().setScrollFactor(0).setDepth(110).setVisible(false);
    this.panelTexts = []; this.panelZones = []; this.activePanel = null;
    this.npcLabels = [];
  }

  isUIArea(p) {
    const h = this.cameras.main.height, w = this.cameras.main.width;
    // Bottom DOM buttons area (55px + safe area)
    if (p.y > h - 55 - this.safeBottom) return true;
    // Top HUD area
    if (p.y < 120 && p.x < 260) return true;
    // Panel area
    if (this.activePanel && p.x > w - 240 && p.y > 60 && p.y < h - 60) return true;
    return false;
  }

  toggleBuildMenu() { this.showPanel('build'); }
  toggleCraftMenu() { this.showPanel('craft'); }
  toggleHireMenu() { this.showPanel('hire'); }
  toggleInventoryMenu() { this.showPanel('inventory'); }

  showPanel(type) {
    this.clearPanel();
    if (this.activePanel === type) { this.activePanel = null; return; }
    this.activePanel = type;
    const w = this.cameras.main.width, h = this.cameras.main.height;
    const pw = 220, px = w - pw - 8, py = 70;
    let items = [];
    if (type === 'build') {
      items = Object.entries(BUILDINGS).map(([k, v]) => ({
        key:k, label:v.icon+' '+v.name, sub:Object.entries(v.cost).map(([r,a])=>r+':'+a).join(' '),
        desc:v.desc, action:()=>{this.buildMode=k;this.clearPanel();this.activePanel=null;
          this.showFloatingText(this.player.x,this.player.y-20,'üëÜ ÌÑ∞ÏπòÎ°ú ÏÑ§Ïπò','#AAFFAA');}
      }));
    } else if (type === 'craft') {
      items = Object.entries(RECIPES).map(([k, v]) => ({
        key:k, label:v.icon+' '+v.name, sub:Object.entries(v.cost).map(([r,a])=>r+':'+a).join(' '),
        desc:v.desc, action:()=>{this.craftItem(k);this.clearPanel();this.activePanel=null;}
      }));
    } else if (type === 'hire') {
      items = NPC_DEFS.map((d,i) => ({
        key:d.type, label:d.name, sub:Object.entries(d.cost).map(([r,a])=>r+':'+a).join(' '),
        desc:d.desc, action:()=>{this.hireNPC(i);}
      }));
    } else if (type === 'inventory') {
      // Show current resources with drop option
      const icons = {meat:'ü•©',wood:'ü™µ',stone:'ü™®',leather:'üß∂',gold:'üí∞'};
      const dropAmounts = {meat:5, wood:10, stone:10, leather:5, gold:10};
      items = Object.entries(this.res)
        .filter(([k,v]) => k !== 'gold' && v > 0)
        .map(([k,v]) => ({
          key:k, label:icons[k]+' '+k+': '+Math.floor(v),
          sub:'Î≤ÑÎ¶¨Í∏∞ -'+dropAmounts[k]+'Í∞ú | Î≥¥Ïú†: '+Math.floor(v),
          desc:'ÌÑ∞ÏπòÌïòÎ©¥ '+dropAmounts[k]+'Í∞ú Î≤ÑÎ¶º (Ï¥ùÎüâ ÌôïÎ≥¥)',
          action:() => {
            const amt = Math.min(dropAmounts[k]||5, this.res[k]||0);
            if (amt <= 0) return;
            this.res[k] = Math.max(0, (this.res[k]||0) - amt);
            this.showFloatingText(this.player.x, this.player.y-20, 'üóëÔ∏è '+icons[k]+'√ó'+amt+' Î≤ÑÎ¶º', '#FF9988');
            this.clearPanel(); this.showPanel('inventory');
          }
        }));
      // Shop tab: buy with gold
      const shopItems = [
        {key:'buy_meat', label:'üí∞‚Üíü•© Í≥†Í∏∞ Íµ¨Îß§', sub:'Í∏àÌôî 5Í∞ú ‚Üí Í≥†Í∏∞ 10Í∞ú', desc:'ÏÉÅÏù∏ÏóêÍ≤å Íµ¨Îß§', action:()=>{ if((this.res.gold||0)<5){this.showFloatingText(this.player.x,this.player.y-20,'‚ùå Í∏àÌôî Î∂ÄÏ°±',  '#FF6666');return;} this.res.gold-=5;this.res.meat=(this.res.meat||0)+10;playCoin();this.showFloatingText(this.player.x,this.player.y-20,'ü•©+10 Íµ¨Îß§ÏôÑÎ£å','#FFDD44');}},
        {key:'buy_wood', label:'üí∞‚Üíü™µ ÎÇòÎ¨¥ Íµ¨Îß§', sub:'Í∏àÌôî 5Í∞ú ‚Üí ÎÇòÎ¨¥ 10Í∞ú', desc:'ÏÉÅÏù∏ÏóêÍ≤å Íµ¨Îß§', action:()=>{ if((this.res.gold||0)<5){this.showFloatingText(this.player.x,this.player.y-20,'‚ùå Í∏àÌôî Î∂ÄÏ°±',  '#FF6666');return;} this.res.gold-=5;this.res.wood=(this.res.wood||0)+10;playCoin();this.showFloatingText(this.player.x,this.player.y-20,'ü™µ+10 Íµ¨Îß§ÏôÑÎ£å','#FFDD44');}},
        {key:'buy_stone', label:'üí∞‚Üíü™® Îèå Íµ¨Îß§',  sub:'Í∏àÌôî 5Í∞ú ‚Üí Îèå 10Í∞ú',  desc:'ÏÉÅÏù∏ÏóêÍ≤å Íµ¨Îß§', action:()=>{ if((this.res.gold||0)<5){this.showFloatingText(this.player.x,this.player.y-20,'‚ùå Í∏àÌôî Î∂ÄÏ°±',  '#FF6666');return;} this.res.gold-=5;this.res.stone=(this.res.stone||0)+10;playCoin();this.showFloatingText(this.player.x,this.player.y-20,'ü™®+10 Íµ¨Îß§ÏôÑÎ£å','#FFDD44');}},
        {key:'buy_hp',   label:'üí∞‚Üí‚ù§Ô∏è Ï≤¥Î†• ÌöåÎ≥µ', sub:'Í∏àÌôî 10Í∞ú ‚Üí HP+50',   desc:'Ìè¨ÏÖò Íµ¨Îß§',   action:()=>{ if((this.res.gold||0)<10){this.showFloatingText(this.player.x,this.player.y-20,'‚ùå Í∏àÌôî Î∂ÄÏ°±', '#FF6666');return;} this.res.gold-=10;this.playerHP=Math.min(this.playerHP+50,this.playerMaxHP);playCoin();this.showFloatingText(this.player.x,this.player.y-20,'‚ù§Ô∏è+50 ÌöåÎ≥µ!','#FF6688');}},
      ];
      items = [...items, ...shopItems];
    }
    const panelH = Math.min(items.length * 60 + 20, h - 140);
    this.panelBg.setVisible(true).clear();
    this.panelBg.fillStyle(0x0a0a1e, 0.93); this.panelBg.fillRoundedRect(px, py, pw, panelH, 10);
    this.panelBg.lineStyle(2, 0x4466aa, 0.6); this.panelBg.strokeRoundedRect(px, py, pw, panelH, 10);
    const titles = { build:'üî• Í±¥ÏÑ§', craft:'üî® Ï†úÏûë', hire:'üë• Í≥†Ïö©', inventory:'üéí Ïù∏Î≤§/ÏÉÅÏ†ê' };
    const titleText = this.add.text(px + pw/2, py + 4, titles[type], {
      fontSize:'15px',fontFamily:'monospace',color:'#AACCFF',stroke:'#000',strokeThickness:2
    }).setScrollFactor(0).setDepth(111).setOrigin(0.5, 0);
    this.panelTexts.push(titleText);
    items.forEach((item, i) => {
      const iy = py + 26 + i * 60;
      if (iy + 56 > py + panelH) return;
      const itemBg = this.add.graphics().setScrollFactor(0).setDepth(110.5);
      itemBg.fillStyle(0x223366, 0.3); itemBg.fillRoundedRect(px + 4, iy, pw - 8, 54, 6);
      this.panelTexts.push(itemBg);
      const t1 = this.add.text(px+12,iy+4,item.label,{fontSize:'14px',fontFamily:'monospace',color:'#fff',stroke:'#000',strokeThickness:2}).setScrollFactor(0).setDepth(111);
      const t2 = this.add.text(px+12,iy+22,item.sub,{fontSize:'10px',fontFamily:'monospace',color:'#AABBCC'}).setScrollFactor(0).setDepth(111);
      const t3 = this.add.text(px+12,iy+36,item.desc,{fontSize:'10px',fontFamily:'monospace',color:'#88FF88'}).setScrollFactor(0).setDepth(111);
      this.panelTexts.push(t1, t2, t3);
      const zone = this.add.zone(px+pw/2, iy+27, pw, 54).setScrollFactor(0).setDepth(112).setInteractive();
      zone.on('pointerdown', item.action);
      zone.on('pointerover', ()=>itemBg.clear().fillStyle(0x334488,0.5).fillRoundedRect(px+4,iy,pw-8,54,6));
      zone.on('pointerout', ()=>itemBg.clear().fillStyle(0x223366,0.3).fillRoundedRect(px+4,iy,pw-8,54,6));
      this.panelZones.push(zone);
    });
  }

  clearPanel() {
    this.panelBg.setVisible(false);
    this.panelTexts.forEach(t=>t.destroy()); this.panelTexts = [];
    this.panelZones.forEach(z=>z.destroy()); this.panelZones = [];
  }

  // drawBar removed - now using DOM bars

  updateUI() {
    const d = this._dom;
    if (!d) return;
    const icons = {meat:'ü•©',wood:'ü™µ',stone:'ü™®',leather:'üß∂',gold:'üí∞'};
    const total = Object.entries(this.res).filter(([k])=>k!=='gold').reduce((a,[_,v])=>a+(v||0),0);
    const isFull = total >= this.storageCapacity;
    d.res.textContent = Object.entries(this.res).filter(([_,v])=>v>0).map(([k,v])=>icons[k]+Math.floor(v)).join(' ');
    // Show inventory capacity
    d.res.style.color = isFull ? '#FF6666' : '#FFFFFF';
    if (d.invCap) d.invCap.textContent = `üì¶ ${Math.floor(total)}/${this.storageCapacity}`;
    
    const hpR = Math.max(0, Math.min(1, this.playerHP/this.playerMaxHP));
    d.hpFill.style.width = (hpR*100)+'%';
    // Smooth gradient HP bar: green‚Üíyellow‚Üíred
    const _hpG = hpR > 0.5 ? 255 : Math.round(255 * (hpR / 0.5));
    const _hpR2 = hpR < 0.5 ? 255 : Math.round(255 * ((1 - hpR) / 0.5));
    d.hpFill.style.background = `rgb(${_hpR2},${_hpG},0)`;
    d.hpFill.className = hpR > 0.6 ? 'bar-f hp-safe' : hpR > 0.3 ? 'bar-f hp-warn' : 'bar-f hp-danger';
    d.hpText.textContent = Math.ceil(Math.max(0,this.playerHP))+'/'+this.playerMaxHP;
    // HP flash effect on big change
    if (this._prevHP !== undefined) {
      const hpDelta = this.playerHP - this._prevHP;
      if (hpDelta <= -20 && d.hpFill.parentElement) {
        d.hpFill.parentElement.style.boxShadow = '0 0 12px 4px rgba(255,50,50,0.8)';
        setTimeout(() => { if (d.hpFill.parentElement) d.hpFill.parentElement.style.boxShadow = ''; }, 400);
      } else if (hpDelta >= 10 && d.hpFill.parentElement) {
        d.hpFill.parentElement.style.boxShadow = '0 0 12px 4px rgba(50,255,100,0.7)';
        setTimeout(() => { if (d.hpFill.parentElement) d.hpFill.parentElement.style.boxShadow = ''; }, 400);
      }
    }
    this._prevHP = this.playerHP;
    
    const tempR = Math.max(0, Math.min(1, this.temperature/this.maxTemp));
    d.tempFill.style.width = (tempR*100)+'%';
    d.tempFill.className = tempR > 0.4 ? 'bar-f' : tempR > 0.15 ? 'bar-f temp-warn' : 'bar-f temp-danger';
    const tempLabel = this.blizzardActive ? `${Math.ceil(this.temperature)}% ‚ùÑÔ∏èÏúÑÌóò!` : `${Math.ceil(this.temperature)}%`;
    d.tempText.textContent = tempLabel;
    
    const hungerR = Math.max(0, Math.min(1, this.hunger/this.maxHunger));
    d.hungerFill.style.width = (hungerR*100)+'%';
    d.hungerText.textContent = Math.ceil(this.hunger)+'%';
    
    if (this.questIndex < QUESTS.length) {
      const q = QUESTS[this.questIndex];
      d.quest.textContent = 'üìã '+q.name+': '+q.desc;
    } else d.quest.textContent = 'üìã Î™®Îì† ÌÄòÏä§Ìä∏ ÏôÑÎ£å! üéâ';
    
    d.buff.style.display = this._nearCampfire ? 'block' : 'none';
    
    if (d.xpFill) {
      const req = this._getXPRequired(this.playerLevel);
      const xpR = Math.min(1, this.playerXP / req);
      d.xpFill.style.width = (xpR * 100) + '%';
      d.xpFill.className = xpR > 0.8 ? 'xp-near-levelup' : '';
      d.xpText.textContent = `Lv${this.playerLevel} ¬∑ ${Math.floor(this.playerXP)}/${req} XP`;
      // Level text bounce on level change
      if (this._prevLevel !== undefined && this._prevLevel !== this.playerLevel && d.xpText) {
        d.xpText.style.transition = 'transform 0.15s ease-out';
        d.xpText.style.transform = 'scale(1.3)';
        d.xpText.style.color = '#FFD700';
        setTimeout(() => { d.xpText.style.transform = 'scale(1)'; d.xpText.style.color = '#6688AA'; }, 300);
      }
      this._prevLevel = this.playerLevel;
    }

    // Act & Timer display
    if (d.actText) {
      const totalSec = Math.floor(this.gameElapsed);
      const mm = Math.floor(totalSec / 60).toString().padStart(2, '0');
      const ss = (totalSec % 60).toString().padStart(2, '0');
      d.actText.textContent = `Act ${this.currentAct} ¬∑ ${mm}:${ss}`;
      if (this.blizzardActive) {
        d.actText.textContent += ` ‚ùÑÔ∏èÌïúÌåå!`;
        d.actText.style.color = '#6699FF';
      } else {
        d.actText.style.color = '#FFDD88';
      }
    }

    // ‚ïê‚ïê‚ïê Next Event Countdown HUD ‚ïê‚ïê‚ïê
    if (d.nextEventText) {
      const t = this.gameElapsed;
      // Boss Rush HUD override
      if (this._bossRushMode) {
        const BOSS_RUSH_TIMES = [60, 240, 420, 720];
        if (this._bossRushCleared) {
          d.nextEventText.textContent = 'üèÜ Î≥¥Ïä§ Îü¨Ïãú ÌÅ¥Î¶¨Ïñ¥!';
          d.nextEventText.style.color = '#FFD700';
          d.nextEventText.style.animation = 'none';
          d.nextEventText.style.display = '';
        } else if (this._bossRushBossAlive) {
          const timeLeft = Math.max(0, 180 - (t - this._bossRushBossSpawnTime));
          const rs = Math.floor(timeLeft);
          d.nextEventText.textContent = `üî¥ Wave ${this._bossRushWave}/4 ‚Äî Ï†úÌïúÏãúÍ∞Ñ ${rs}s`;
          d.nextEventText.style.color = timeLeft <= 30 ? '#FF4444' : '#FF6666';
          d.nextEventText.style.animation = timeLeft <= 30 ? 'event-pulse-fast 0.4s ease-in-out infinite' : 'none';
          d.nextEventText.style.display = '';
        } else {
          // Find next wave
          let nextWave = -1;
          for (let i = 0; i < BOSS_RUSH_TIMES.length; i++) {
            if (!this._bossRushWaveSpawned[i]) { nextWave = i; break; }
          }
          if (nextWave >= 0) {
            const rem = Math.max(0, BOSS_RUSH_TIMES[nextWave] - t);
            const rm = Math.floor(rem / 60);
            const rs = Math.floor(rem % 60);
            const timeStr = rm > 0 ? `${rm}m ${String(rs).padStart(2,'0')}s` : `${rs}s`;
            d.nextEventText.textContent = `üî¥ Wave ${nextWave+1}/4ÍπåÏßÄ ${timeStr}`;
            d.nextEventText.style.color = rem <= 30 ? '#FF4444' : '#FFFFFF';
            d.nextEventText.style.animation = rem <= 10 ? 'event-pulse-fast 0.4s ease-in-out infinite' : 'none';
            d.nextEventText.style.display = '';
          } else {
            d.nextEventText.style.display = 'none';
          }
        }
      } else {
      const events = [];
      // Boss: 25min, 55min
      if (!this.boss1Spawned) events.push({ time: 25*60, label: 'üíÄ Î≥¥Ïä§ÍπåÏßÄ' });
      if (!this.boss2Spawned && this.boss1Spawned) events.push({ time: 55*60, label: 'üíÄ Î≥¥Ïä§ÍπåÏßÄ' });
      // Elite wave: 15, 30, 45 min
      [15,30,45].forEach(m => { if (!this._eliteWaveTriggered[m]) events.push({ time: m*60, label: '‚ö†Ô∏è ÏóòÎ¶¨Ìä∏ Ïõ®Ïù¥Î∏åÍπåÏßÄ' }); });
      // Siege wave: 25, 50 min
      [25,50].forEach(m => { if (!this._siegeWaveTriggered || !this._siegeWaveTriggered[m]) events.push({ time: m*60, label: 'üî¥ Ìè¨ÏúÑ Í≥µÍ≤©ÍπåÏßÄ' }); });
      // Random event: every 3min
      const nextRandom = (Math.floor(t / 180) + 1) * 180;
      events.push({ time: nextRandom, label: 'üé≤ Ïù¥Î≤§Ìä∏ÍπåÏßÄ' });
      // Survival challenge: every 10min (starting at 10)
      const nextChallenge = Math.max(10*60, (Math.floor(t / 600) + 1) * 600);
      if (!this._challengeActive) events.push({ time: nextChallenge, label: 'üèÜ Ï±åÎ¶∞ÏßÄÍπåÏßÄ' });

      const future = events.filter(e => e.time > t).sort((a,b) => a.time - b.time);
      if (future.length > 0) {
        const next = future[0];
        const rem = Math.max(0, next.time - t);
        const rm = Math.floor(rem / 60);
        const rs = Math.floor(rem % 60);
        const timeStr = rm > 0 ? `${rm}m ${String(rs).padStart(2,'0')}s` : `${rs}s`;
        d.nextEventText.textContent = `${next.label} ${timeStr}`;
        d.nextEventText.style.display = '';
        if (rem <= 30) {
          d.nextEventText.style.color = '#FF4444';
          d.nextEventText.style.animation = 'event-pulse-fast 0.4s ease-in-out infinite';
        } else if (rem <= 60) {
          d.nextEventText.style.color = '#FF6666';
          d.nextEventText.style.animation = 'event-pulse 0.8s ease-in-out infinite';
        } else {
          d.nextEventText.style.color = '#FFFFFF';
          d.nextEventText.style.animation = 'none';
        }
      } else {
        d.nextEventText.style.display = 'none';
      }
      } // end boss rush else
    }

    // ‚ïê‚ïê‚ïê Class HUD ‚ïê‚ïê‚ïê
    if (d.classHud && this._playerClass && PLAYER_CLASSES[this._playerClass]) {
      const cls = PLAYER_CLASSES[this._playerClass];
      d.classHud.style.display = '';
      d.classNameText.textContent = `${cls.icon} ${cls.name}`;
      d.classNameText.style.color = cls.color;
      // Skill cooldown display
      let cd = 0, maxCd = 1, skillIcon = '';
      if (this._playerClass === 'warrior') { cd = this._classRoarCD; maxCd = 15; skillIcon = 'ü™ì'; }
      else if (this._playerClass === 'mage') { cd = this._classBlizzardCD; maxCd = 30; skillIcon = 'üßä'; }
      else if (this._playerClass === 'survivor') { cd = this._classSprintCD; maxCd = 20; skillIcon = 'üèÉ'; }
      else if (this._playerClass === 'shaman') { cd = this._classSpiritCD; maxCd = 30; skillIcon = 'üîÆ'; }
      else if (this._playerClass === 'hunter') { cd = this._classHunterVolleyCD; maxCd = 25; skillIcon = 'üèπ'; }
      if (cd > 0) {
        d.classSkillCd.textContent = Math.ceil(cd);
        d.classSkillCd.style.background = 'rgba(0,0,0,0.7)';
        d.classSkillCd.style.borderColor = '#666';
        d.classSkillCd.style.color = '#AAA';
        d.classSkillCd.style.animation = 'none';
      } else {
        d.classSkillCd.textContent = skillIcon;
        d.classSkillCd.style.background = 'rgba(60,60,0,0.6)';
        d.classSkillCd.style.borderColor = '#FFD700';
        d.classSkillCd.style.color = '#FFD700';
        d.classSkillCd.style.animation = 'skill-ready-pulse 1s ease-in-out infinite';
      }
    }

    // ‚ïê‚ïê‚ïê Shaman Nature's Blessing indicator ‚ïê‚ïê‚ïê
    if (this._playerClass === 'shaman') {
      if (!this._natureBlessingText) {
        this._natureBlessingText = this.add.text(10, 90, '', { fontSize: '12px', fontFamily: 'monospace', color: '#FFD700', stroke: '#000', strokeThickness: 2 }).setDepth(100).setScrollFactor(0);
      }
      this._natureBlessingText.setText(this._natureBlessing ? 'üî• ÏûêÏó∞Ïùò Í∞ÄÌò∏ +15%' : '');
    }

    // ‚ïê‚ïê‚ïê Timeline Progress Bar ‚ïê‚ïê‚ïê
    if (d.timelineBar) {
      d.timelineBar.style.display = '';
      const progress = this._endlessMode ? Math.min(1, (this.gameElapsed % 3600) / 3600) : Math.min(1, this.gameElapsed / 3600);
      d.timelineFill.style.width = (progress * 100) + '%';
      const minE = this.gameElapsed / 60;
      if (minE >= 55) d.timelineFill.style.background = '#EE2222';
      else if (minE >= 45) d.timelineFill.style.background = '#EE8822';
      else if (minE >= 30) d.timelineFill.style.background = '#DDBB22';
      else d.timelineFill.style.background = '#44BB44';
    }

    // Zone indicator
    const zoneEl = document.getElementById('zone-indicator');
    if (zoneEl) {
      const zone = this.getPlayerZone();
      const zoneNames = { safe: 'üèïÔ∏è ÏÉùÏ°¥ Ï∫†ÌîÑ', normal: 'üå≤ Ïπ®ÏóΩÏàòÎ¶º', danger: 'üèîÔ∏è ÎπôÌïò ÏßÄÎåÄ', extreme: 'üíÄ Ï£ΩÏùåÏùò ÏÑ§Ïõê' };
      zoneEl.textContent = zoneNames[zone];
    }
    
    this.npcLabels.forEach(l=>l.destroy()); this.npcLabels = [];
    this.npcsOwned.forEach(npc => {
      if (!npc.active) return;
      const l = this.add.text(npc.x, npc.y-22, npc.npcDef.name, {
        fontSize:'11px',fontFamily:'monospace',color:'#FFDD88',stroke:'#000',strokeThickness:2
      }).setDepth(12).setOrigin(0.5);
      this.npcLabels.push(l);
    });
  }

  // ‚ïê‚ïê‚ïê SUPPLY CRATE SYSTEM ‚ïê‚ïê‚ïê
  spawnSupplyCrate() {
    const angle = Math.random() * Math.PI * 2;
    const dist = 100 + Math.random() * 100;
    const cx = this.player.x + Math.cos(angle) * dist;
    const cy = this.player.y + Math.sin(angle) * dist;
    const tx = Phaser.Math.Clamp(cx, 50, WORLD_W - 50);
    const ty = Phaser.Math.Clamp(cy, 50, WORLD_H - 50);

    const crate = this.physics.add.sprite(tx, ty - 200, 'supply_crate').setDepth(8).setScale(0).setAlpha(0);
    crate.body.setAllowGravity(false);
    crate.body.setSize(28, 24);
    crate.isCrate = true;
    crate._sparkleTimer = 0;

    // Drop animation
    playBoxAppear();
    this.tweens.add({
      targets: crate, y: ty, scale: 1.2, alpha: 1,
      duration: 600, ease: 'Bounce.Out',
      onComplete: () => {
        this.tweens.add({ targets: crate, scale: { from: 1.2, to: 1 }, duration: 200 });
        // Glow pulse
        this.tweens.add({
          targets: crate, scale: 1.15, duration: 800, yoyo: true, repeat: -1, ease: 'Sine.InOut'
        });
      }
    });

    // Impact particles
    this.time.delayedCall(500, () => {
      for (let i = 0; i < 6; i++) {
        const p = this.add.image(tx, ty, 'sparkle').setDepth(15).setScale(1.5);
        this.tweens.add({
          targets: p, x: tx + Phaser.Math.Between(-30, 30), y: ty + Phaser.Math.Between(-30, 10),
          alpha: 0, scale: 0, duration: 400, onComplete: () => p.destroy()
        });
      }
    });

    // Label
    const label = this.add.text(tx, ty - 24, 'üì¶ Î≥¥Í∏âÏÉÅÏûê', {
      fontSize: '11px', fontFamily: 'monospace', color: '#FFD700',
      stroke: '#000', strokeThickness: 3
    }).setDepth(9).setOrigin(0.5);
    crate._label = label;

    this.supplyCrates.push(crate);
    this.physics.add.overlap(this.player, crate, () => this.openCrate(crate));

    this.showFloatingText(this.player.x, this.player.y - 30, 'üì¶ Î≥¥Í∏âÏÉÅÏûê Ï∂úÌòÑ!', '#FFD700');
  }

  openCrate(crate) {
    if (!crate.active || this.upgradeUIActive) return;
    const isEndgame = this._endlessMode && this.gameElapsed >= 3600;
    const cards = this.upgradeManager.pickThreeCards(this.extraCardChoices || 0, this._playerClass, isEndgame);
    if (cards.length === 0) {
      this.showFloatingText(crate.x, crate.y - 20, '‚úÖ Î™®Îì† ÏóÖÍ∑∏Î†àÏù¥Îìú ÏµúÎåÄ!', '#88FF88');
      if (crate._label) crate._label.destroy();
      crate.destroy();
      return;
    }

    // Remove crate with burst effect
    for (let i = 0; i < 10; i++) {
      const p = this.add.image(crate.x, crate.y, 'sparkle').setDepth(15).setScale(2);
      this.tweens.add({
        targets: p, x: crate.x + Phaser.Math.Between(-50, 50), y: crate.y + Phaser.Math.Between(-50, 50),
        alpha: 0, scale: 0, duration: 500, onComplete: () => p.destroy()
      });
    }
    if (crate._label) crate._label.destroy();
    this.supplyCrates = this.supplyCrates.filter(c => c !== crate);
    crate.destroy();

    this.showUpgradeUI(cards);
  }

  // ‚ïê‚ïê‚ïê TRIPLE CHOICE UPGRADE UI ‚ïê‚ïê‚ïê
  showUpgradeUI(cards) {
    this._ftueOnLevelUp();
    this.upgradeUIActive = true;
    this.physics.pause();
    const cam = this.cameras.main;
    const W = cam.width, H = cam.height;

    // Hide DOM HUD during upgrade selection
    const domHud = document.getElementById('dom-hud');
    const bottomBtns = document.getElementById('bottom-buttons');
    if (domHud) domHud.style.visibility = 'hidden';
    if (bottomBtns) bottomBtns.style.display = 'none';

    // Clean up any previous upgrade UI elements to prevent text overlap
    if (this._upgradeUIElements) {
      this._upgradeUIElements.forEach(el => {
        if (el && el.destroy) { try { el.destroy(); } catch(e) {} }
      });
      this._upgradeUIElements = null;
    }

    // Container for all UI elements
    const uiElements = [];

    // Dark overlay (Îã§ÌÅ¨ÎÑ§Ïù¥ÎπÑ Î∞òÌà¨Î™Ö)
    const overlay = this.add.graphics().setScrollFactor(0).setDepth(300);
    overlay.fillStyle(0x0A0E1A, 0).fillRect(0, 0, W, H);
    uiElements.push(overlay);
    this.tweens.add({ targets: { v: 0 }, v: 0.88, duration: 300,
      onUpdate: (_, t) => { overlay.clear(); overlay.fillStyle(0x0A0E1A, t.v); overlay.fillRect(0, 0, W, H); }
    });

    // Title
    const title = this.add.text(W / 2, H * 0.12, '‚¨ÜÔ∏è ÏóÖÍ∑∏Î†àÏù¥Îìú ÏÑ†ÌÉù', {
      fontSize: Math.min(28, W * 0.05) + 'px', fontFamily: 'monospace', color: '#FFD700',
      stroke: '#000', strokeThickness: 4
    }).setScrollFactor(0).setDepth(301).setOrigin(0.5).setAlpha(0);
    uiElements.push(title);
    this.tweens.add({ targets: title, alpha: 1, y: title.y + 10, duration: 400, ease: 'Back.Out' });

    const subtitle = this.add.text(W / 2, H * 0.18, 'Ïπ¥ÎìúÎ•º ÏÑ†ÌÉùÌïòÏÑ∏Ïöî', {
      fontSize: '14px', fontFamily: 'monospace', color: '#AABBCC'
    }).setScrollFactor(0).setDepth(301).setOrigin(0.5).setAlpha(0);
    uiElements.push(subtitle);
    this.tweens.add({ targets: subtitle, alpha: 1, duration: 500, delay: 200 });

    // Card dimensions (supports variable card count)
    const numCards = cards.length || 3;
    const cardW = Math.min(160, (W - 60) / numCards);
    const cardH = Math.min(240, H * 0.55);
    const gap = Math.min(16, W * 0.02);
    const totalW = cardW * numCards + gap * (numCards - 1);
    const startX = (W - totalW) / 2;
    const cardY = H * 0.25;

    cards.forEach((key, i) => {
      const upgrade = UPGRADES[key];
      const cat = UPGRADE_CATEGORIES[upgrade.category];
      const rarityInfo = RARITY_LABELS[upgrade.rarity];
      const currentLv = this.upgradeManager.getLevel(key);
      const nextLv = currentLv + 1;
      const cx = startX + i * (cardW + gap) + cardW / 2;
      const cy = cardY + cardH / 2;

      // Card back (for flip animation)
      const cardBack = this.add.graphics().setScrollFactor(0).setDepth(302);
      cardBack.fillStyle(0x222244, 0.95);
      cardBack.fillRoundedRect(cx - cardW / 2, cy - cardH / 2, cardW, cardH, 12);
      cardBack.lineStyle(3, 0x4466AA, 0.8);
      cardBack.strokeRoundedRect(cx - cardW / 2, cy - cardH / 2, cardW, cardH, 12);
      // Pattern on back
      cardBack.fillStyle(0x334466, 0.5);
      cardBack.fillCircle(cx, cy, 20);
      const qmark = this.add.text(cx, cy, '?', {
        fontSize: '36px', fontFamily: 'monospace', color: '#6688AA'
      }).setScrollFactor(0).setDepth(303).setOrigin(0.5);
      uiElements.push(cardBack, qmark);

      // Grade-specific border color
      const gradeColorMap = { common: 0x9E9E9E, rare: 0x2196F3, epic: 0x9C27B0 };
      const gradeColor = gradeColorMap[upgrade.rarity] || 0x9E9E9E;
      const gradeGlowAlpha = upgrade.rarity === 'epic' ? 0.6 : upgrade.rarity === 'rare' ? 0.4 : 0.2;

      // Card front (hidden initially)
      const cardGfx = this.add.graphics().setScrollFactor(0).setDepth(304).setAlpha(0);
      // Outer glow (grade color)
      if (upgrade.rarity !== 'common') {
        cardGfx.lineStyle(4, gradeColor, gradeGlowAlpha);
        cardGfx.strokeRoundedRect(cx - cardW / 2 - 4, cy - cardH / 2 - 4, cardW + 8, cardH + 8, 16);
      }
      // Background (Îã§ÌÅ¨ÎÑ§Ïù¥ÎπÑ)
      cardGfx.fillStyle(0x0D1B2A, 0.95);
      cardGfx.fillRoundedRect(cx - cardW / 2, cy - cardH / 2, cardW, cardH, 14);
      // Grade color border
      cardGfx.lineStyle(3, gradeColor, 1);
      cardGfx.strokeRoundedRect(cx - cardW / 2, cy - cardH / 2, cardW, cardH, 14);
      // Top color band
      cardGfx.fillStyle(cat.bgColor, 0.3);
      cardGfx.fillRoundedRect(cx - cardW / 2, cy - cardH / 2, cardW, 50, { tl: 14, tr: 14, bl: 0, br: 0 });
      // Icon circle background (Îì±Í∏âÏÉâ ÌÖåÎëêÎ¶¨)
      cardGfx.fillStyle(0x152238, 1);
      cardGfx.fillCircle(cx, cy - cardH / 2 + 30, 22);
      cardGfx.lineStyle(2, gradeColor, 0.8);
      cardGfx.strokeCircle(cx, cy - cardH / 2 + 30, 22);
      uiElements.push(cardGfx);

      // Card content texts (hidden initially)
      const iconText = this.add.text(cx, cy - cardH / 2 + 30, upgrade.icon, {
        fontSize: '32px'
      }).setScrollFactor(0).setDepth(305).setOrigin(0.5).setAlpha(0);

      const nameText = this.add.text(cx, cy - cardH / 2 + 62, upgrade.name, {
        fontSize: '15px', fontFamily: 'monospace', color: cat.color,
        stroke: '#000', strokeThickness: 2, fontStyle: 'bold'
      }).setScrollFactor(0).setDepth(305).setOrigin(0.5).setAlpha(0);

      const descText = this.add.text(cx, cy - cardH / 2 + 84, upgrade.desc, {
        fontSize: '12px', fontFamily: 'monospace', color: '#CCDDEE',
        wordWrap: { width: cardW - 20 }, align: 'center'
      }).setScrollFactor(0).setDepth(305).setOrigin(0.5).setAlpha(0);

      const rarityText = this.add.text(cx, cy + cardH / 2 - 55, rarityInfo.name, {
        fontSize: '11px', fontFamily: 'monospace', color: rarityInfo.color,
        stroke: '#000', strokeThickness: 2
      }).setScrollFactor(0).setDepth(305).setOrigin(0.5).setAlpha(0);

      // Level indicator
      let lvStr = '';
      for (let l = 0; l < upgrade.maxLevel; l++) {
        lvStr += l < nextLv ? '‚òÖ' : '‚òÜ';
      }
      const lvText = this.add.text(cx, cy + cardH / 2 - 35, 'Lv.' + nextLv + ' ' + lvStr, {
        fontSize: '12px', fontFamily: 'monospace', color: '#FFD700',
        stroke: '#000', strokeThickness: 2
      }).setScrollFactor(0).setDepth(305).setOrigin(0.5).setAlpha(0);

      const catText = this.add.text(cx, cy + cardH / 2 - 18, cat.icon + ' ' + cat.name, {
        fontSize: '11px', fontFamily: 'monospace', color: cat.color
      }).setScrollFactor(0).setDepth(305).setOrigin(0.5).setAlpha(0);

      // Synergy hint
      const synergyHint = UPGRADE_SYNERGY[key] || '';
      let synergyText = null;
      if (synergyHint) {
        synergyText = this.add.text(cx, cy + cardH / 2 - 2, synergyHint, {
          fontSize: '9px', fontFamily: 'monospace', color: '#88CCAA',
          stroke: '#000', strokeThickness: 1
        }).setScrollFactor(0).setDepth(305).setOrigin(0.5).setAlpha(0);
        uiElements.push(synergyText);
      }

      const frontElements = [cardGfx, iconText, nameText, descText, rarityText, lvText, catText];
      if (synergyText) frontElements.push(synergyText);
      uiElements.push(iconText, nameText, descText, rarityText, lvText, catText);

      // Flip animation: delay per card
      const flipDelay = 300 + i * 250;
      this.time.delayedCall(flipDelay, () => {
        // Hide back
        this.tweens.add({ targets: [cardBack, qmark], scaleX: 0, duration: 150, ease: 'Quad.In',
          onComplete: () => { cardBack.setAlpha(0); qmark.setAlpha(0); }
        });
        // Show front
        this.time.delayedCall(150, () => {
          frontElements.forEach(el => {
            el.setAlpha(1);
            if (el.setScale) el.setScale(1, 1);
          });
          // Scale-in effect
          this.tweens.add({
            targets: frontElements, scaleX: { from: 0, to: 1 }, duration: 200, ease: 'Back.Out'
          });
          // Rarity sparkle
          if (upgrade.rarity === 'epic' || upgrade.rarity === 'rare') {
            for (let s = 0; s < (upgrade.rarity === 'epic' ? 8 : 4); s++) {
              this.time.delayedCall(s * 50, () => {
                const sp = this.add.image(cx + Phaser.Math.Between(-cardW/2, cardW/2), cy + Phaser.Math.Between(-cardH/2, cardH/2), 'sparkle')
                  .setScrollFactor(0).setDepth(306).setScale(1.5).setTint(upgrade.rarity === 'epic' ? 0xAA44FF : 0x4488FF);
                uiElements.push(sp);
                this.tweens.add({ targets: sp, alpha: 0, scale: 0, y: sp.y - 20, duration: 600, onComplete: () => sp.destroy() });
              });
            }
          }
        });
      });

      // Interactive zone (enabled after flip)
      const zone = this.add.zone(cx, cy, cardW, cardH).setScrollFactor(0).setDepth(310).setInteractive();
      uiElements.push(zone);

      // Hover effect (ÏÇ¥Ïßù ÏúÑÎ°ú Ïù¥Îèô + Î∞ùÏïÑÏßê)
      zone.on('pointerover', () => {
        if (cardGfx.alpha > 0) {
          // Move card up slightly
          frontElements.forEach(el => { if (el.y !== undefined) el.y -= 5; });
          cardGfx.clear();
          if (upgrade.rarity !== 'common') {
            cardGfx.lineStyle(5, gradeColor, gradeGlowAlpha + 0.2);
            cardGfx.strokeRoundedRect(cx - cardW / 2 - 4, cy - cardH / 2 - 9, cardW + 8, cardH + 8, 16);
          }
          cardGfx.fillStyle(0x1B2838, 0.98);
          cardGfx.fillRoundedRect(cx - cardW / 2, cy - cardH / 2 - 5, cardW, cardH, 14);
          cardGfx.lineStyle(4, gradeColor, 1);
          cardGfx.strokeRoundedRect(cx - cardW / 2, cy - cardH / 2 - 5, cardW, cardH, 14);
          cardGfx.fillStyle(cat.bgColor, 0.5);
          cardGfx.fillRoundedRect(cx - cardW / 2, cy - cardH / 2 - 5, cardW, 50, { tl: 14, tr: 14, bl: 0, br: 0 });
          cardGfx.fillStyle(0x152238, 1); cardGfx.fillCircle(cx, cy - cardH / 2 + 25, 22);
          cardGfx.lineStyle(2, gradeColor, 1); cardGfx.strokeCircle(cx, cy - cardH / 2 + 25, 22);
        }
      });
      zone.on('pointerout', () => {
        if (cardGfx.alpha > 0) {
          // Move card back
          frontElements.forEach(el => { if (el.y !== undefined) el.y += 5; });
          cardGfx.clear();
          if (upgrade.rarity !== 'common') {
            cardGfx.lineStyle(4, gradeColor, gradeGlowAlpha);
            cardGfx.strokeRoundedRect(cx - cardW / 2 - 4, cy - cardH / 2 - 4, cardW + 8, cardH + 8, 16);
          }
          cardGfx.fillStyle(0x0D1B2A, 0.95);
          cardGfx.fillRoundedRect(cx - cardW / 2, cy - cardH / 2, cardW, cardH, 14);
          cardGfx.lineStyle(3, gradeColor, 1);
          cardGfx.strokeRoundedRect(cx - cardW / 2, cy - cardH / 2, cardW, cardH, 14);
          cardGfx.fillStyle(cat.bgColor, 0.3);
          cardGfx.fillRoundedRect(cx - cardW / 2, cy - cardH / 2, cardW, 50, { tl: 14, tr: 14, bl: 0, br: 0 });
          cardGfx.fillStyle(0x152238, 1); cardGfx.fillCircle(cx, cy - cardH / 2 + 30, 22);
          cardGfx.lineStyle(2, gradeColor, 0.8); cardGfx.strokeCircle(cx, cy - cardH / 2 + 30, 22);
        }
      });

      zone.on('pointerdown', () => {
        if (cardGfx.alpha < 0.5) return; // not yet revealed
        this.selectUpgrade(key, uiElements, cx, cy);
      });
    });

    this._upgradeUIElements = uiElements;
  }

  selectUpgrade(key, uiElements, cx, cy) {
    const upgrade = UPGRADES[key];
    const cat = UPGRADE_CATEGORIES[upgrade.category];

    // Track upgrade for run history
    if (this._currentRunUpgrades) this._currentRunUpgrades.push(key);

    // Sound on selection
    if (upgrade.rarity === 'epic') playEpicCard();
    else playUpgradeSelect();

    // Apply upgrade
    this.upgradeManager.applyUpgrade(key, this);

    // Check skill synergies
    this.synergyManager.checkSynergies(this.upgradeManager, this);
    this.synergyManager.renderHUD(this);

    // ‚ïê‚ïê‚ïê Selection confirmation flash ‚ïê‚ïê‚ïê
    this.cameras.main.flash(200, 255, 255, 255, true);
    const selFlash = this.add.rectangle(cx, cy, 200, 300, 0xFFFFFF, 0.9)
      .setScrollFactor(0).setDepth(315);
    this.tweens.add({ targets: selFlash, alpha: 0, scale: 1.5, duration: 300, onComplete: () => selFlash.destroy() });

    // Selection burst effect
    for (let i = 0; i < 12; i++) {
      const ang = (i / 12) * Math.PI * 2;
      const p = this.add.image(cx, cy, 'sparkle')
        .setScrollFactor(0).setDepth(320).setScale(2).setTint(cat.bgColor);
      this.tweens.add({
        targets: p, x: cx + Math.cos(ang) * 80, y: cy + Math.sin(ang) * 80,
        alpha: 0, scale: 0, duration: 500, onComplete: () => p.destroy()
      });
    }

    // Acquisition text
    const acqText = this.add.text(this.cameras.main.width / 2, this.cameras.main.height * 0.85,
      '‚ú® ' + upgrade.icon + ' ' + upgrade.name + ' ÌöçÎìù!', {
      fontSize: '22px', fontFamily: 'monospace', color: cat.color,
      stroke: '#000', strokeThickness: 4, fontStyle: 'bold'
    }).setScrollFactor(0).setDepth(320).setOrigin(0.5).setAlpha(0);
    this.tweens.add({
      targets: acqText, alpha: 1, scale: { from: 0.5, to: 1.2 }, duration: 400, ease: 'Back.Out',
      onComplete: () => {
        this.tweens.add({ targets: acqText, alpha: 0, y: acqText.y - 30, duration: 800, delay: 400,
          onComplete: () => acqText.destroy()
        });
      }
    });

    // Close UI after brief delay
    this.time.delayedCall(300, () => {
      uiElements.forEach(el => {
        if (el && el.active !== false && el.destroy) {
          this.tweens.add({ targets: el, alpha: 0, duration: 200, onComplete: () => { try { el.destroy(); } catch(e) {} } });
        }
      });
      this._upgradeUIElements = null;
      this.time.delayedCall(250, () => {
        this.upgradeUIActive = false;
        this.physics.resume();
        // Restore DOM HUD
        const _domHud = document.getElementById('dom-hud');
        const _bottomBtns = document.getElementById('bottom-buttons');
        if (_domHud) _domHud.style.visibility = 'visible';
        if (_bottomBtns) _bottomBtns.style.display = '';
        // Auto-save after upgrade
        SaveManager.save(this);
        // Process queued level-ups (pendingLevelUps)
        this.time.delayedCall(500, () => this.processLevelUpQueue());
      });
    });
  }

  // ‚ïê‚ïê‚ïê EXPLOSION ON KILL (upgrade effect) ‚ïê‚ïê‚ïê
  triggerExplosion(x, y) {
    const radius = 60 + this.upgradeManager.explosionLevel * 30;
    const dmg = this.upgradeManager.explosionLevel;

    // Visual explosion
    const g = this.add.graphics().setDepth(15);
    let ring = { r: 10, a: 0.8 };
    this.tweens.add({
      targets: ring, r: radius, a: 0, duration: 300,
      onUpdate: () => { g.clear(); g.fillStyle(0xFF6600, ring.a * 0.3); g.fillCircle(x, y, ring.r); g.lineStyle(3, 0xFF4400, ring.a); g.strokeCircle(x, y, ring.r); },
      onComplete: () => g.destroy()
    });

    // Damage nearby enemies
    this.animals.getChildren().forEach(a => {
      if (!a.active) return;
      if (Phaser.Math.Distance.Between(x, y, a.x, a.y) < radius) {
        this.damageAnimal(a, dmg);
      }
    });

    // Particles
    for (let i = 0; i < 8; i++) {
      const p = this.add.image(x, y, 'fire_particle').setDepth(15).setScale(2);
      this.tweens.add({
        targets: p, x: x + Phaser.Math.Between(-50, 50), y: y + Phaser.Math.Between(-50, 50),
        alpha: 0, scale: 0, duration: 400, onComplete: () => p.destroy()
      });
    }
  }

  // ‚ïê‚ïê‚ïê 5-ACT ENEMY SYSTEM ‚ïê‚ïê‚ïê
  getCurrentAct() {
    const min = this.gameElapsed / 60;
    if (min < 12) return 1;
    if (min < 25) return 2;
    if (min < 40) return 3;
    if (min < 55) return 4;
    return 5;
  }

  getWaveSize() {
    const min = this.gameElapsed / 60;
    if (min < 5) return 10;
    if (min < 12) return 20;
    if (min < 25) return 40;
    if (min < 40) return 60;
    if (min < 55) return 80;
    return 100;
  }

  getSpawnConfig() {
    const min = this.gameElapsed / 60;
    let weights, maxCount, spawnInterval;
    if (min < 5) {
      // 0-5Î∂Ñ: ÌÜ†ÎÅº/Ìé≠Í∑ÑÎßå (ÏïàÏ†Ñ Íµ¨Í∞Ñ)
      weights = { rabbit: 6, penguin: 4 }; maxCount = 12; spawnInterval = 9000;
    } else if (min < 10) {
      // 5-10Î∂Ñ: ÏÇ¨Ïä¥/Î¨ºÍ∞ú Ï∂îÍ∞Ä
      weights = { rabbit: 4, penguin: 3, deer: 3, seal: 2 }; maxCount = 16; spawnInterval = 8000;
    } else if (min < 15) {
      // 10-15Î∂Ñ: ÎäëÎåÄ Îì±Ïû•
      weights = { rabbit: 3, penguin: 2, deer: 2, seal: 2, wolf: 3 }; maxCount = 22; spawnInterval = 7000;
    } else if (min < 20) {
      // 15-20Î∂Ñ: Í≥∞ + ÏñºÏùåÏÇ¨ÎÉ•Íæº Îì±Ïû•
      weights = { rabbit: 2, deer: 2, wolf: 3, bear: 3, seal: 2, ice_hunter: 1 }; maxCount = 28; spawnInterval = 7000;
    } else if (min < 30) {
      // 20-30Î∂Ñ: Î∂ÑÏó¥Ïä¨ÎùºÏûÑ Îì±Ïû•
      weights = { rabbit: 1, deer: 1, wolf: 3, bear: 4, seal: 2, ice_hunter: 2, splitting_slime: 2 }; maxCount = 34; spawnInterval = 6000;
    } else if (min < 45) {
      // ÌõÑÎ∞ò: Í∞ïÏ†Å + ÎààÎ≥¥ÎùºÏÉ§Î®º
      weights = { wolf: 3, bear: 4, seal: 3, ice_golem: 1, snow_leopard: 2, ice_hunter: 2, splitting_slime: 2, blizzard_shaman: 1 }; maxCount = 40; spawnInterval = 5000;
    } else {
      // ÏµúÌõÑÎ∞ò: Í∑πÌïú
      weights = { wolf: 2, bear: 5, seal: 4, ice_golem: 2, snow_leopard: 3, ice_hunter: 2, splitting_slime: 2, blizzard_shaman: 2 }; maxCount = 48; spawnInterval = 4000;
    }
    return { weights, maxCount, spawnInterval };
  }

  pickAnimalType(weights) {
    const total = Object.values(weights).reduce((a, b) => a + b, 0);
    let r = Math.random() * total;
    for (const [type, w] of Object.entries(weights)) {
      r -= w;
      if (r <= 0) return type;
    }
    return Object.keys(weights)[0];
  }

  getSpawnWeights() {
    return this.getSpawnConfig().weights;
  }

  getMaxAnimals() {
    return this.getSpawnConfig().maxCount;
  }

  // ‚ïê‚ïê‚ïê BLIZZARD (ÌïúÌåå) SYSTEM ‚ïê‚ïê‚ïê
  checkBlizzardSchedule() {
    if (this.blizzardIndex >= BLIZZARD_SCHEDULE.length) return;
    if (!this.gameStartTime) return;
    const elapsed = this.time.now - this.gameStartTime;
    const next = BLIZZARD_SCHEDULE[this.blizzardIndex];

    // 60Ï¥à Ï†Ñ Í≤ΩÍ≥†
    const warnTime = next.startMs - 60 * 1000;
    if (!this.blizzardWarned && elapsed >= warnTime && elapsed < next.startMs) {
      this.blizzardWarned = true;
      playColdWarning();
      this.startBlizzardWarning(next.startMs - elapsed);
    }

    // ÌïúÌåå ÏãúÏûë
    if (!this.blizzardActive && elapsed >= next.startMs) {
      this.startBlizzard(next);
    }
  }

  startBlizzardWarning(msUntil) {
    this.blizzardWarningEndTime = this.time.now + msUntil;
    const warnEl = document.getElementById('blizzard-warning');
    if (warnEl) warnEl.style.display = 'block';
    this.updateBlizzardWarning(Math.ceil(msUntil / 1000));
    if (this.blizzardCountdownTimer) this.blizzardCountdownTimer.remove();
    this.blizzardCountdownTimer = this.time.addEvent({
      delay: 1000, repeat: Math.ceil(msUntil / 1000) - 1,
      callback: () => {
        const remaining = this.blizzardWarningEndTime - this.time.now;
        if (remaining > 0) this.updateBlizzardWarning(Math.ceil(remaining / 1000));
      }
    });
  }

  updateBlizzardWarning(sec) {
    const el = document.getElementById('blizzard-countdown');
    if (el) el.textContent = Math.max(0, sec);
  }

  startBlizzard(config) {
    playBlizzardStart();
    this._ftueOnBlizzard();
    this.blizzardActive = true;
    this.blizzardMultiplier = config.tempMult;
    this.blizzardIndex++;
    this.blizzardWarned = false;
    if (this.blizzardCountdownTimer) { this.blizzardCountdownTimer.remove(); this.blizzardCountdownTimer = null; }

    // Hide warning, show active
    const warnEl = document.getElementById('blizzard-warning');
    const activeEl = document.getElementById('blizzard-active');
    if (warnEl) warnEl.style.display = 'none';
    if (activeEl) activeEl.style.display = 'block';

    // Slow player
    this.playerSpeed = this.playerBaseSpeed * 0.8;

    this.showCenterAlert(`‚ùÑÔ∏è ÌïúÌåå ${this.blizzardIndex}/${BLIZZARD_SCHEDULE.length} ÏãúÏûë!`, '#4488FF');
    this.cameras.main.shake(300, 0.008);
    // ‚ïê‚ïê‚ïê Blue pulse border for cold wave ‚ïê‚ïê‚ïê
    const _cwBorder = this.add.graphics().setScrollFactor(0).setDepth(298);
    let _cwP = { a: 0 };
    this.tweens.add({ targets: _cwP, a: 0.5, duration: 400, yoyo: true, repeat: 3,
      onUpdate: () => { _cwBorder.clear(); _cwBorder.lineStyle(6, 0x4488FF, _cwP.a); _cwBorder.strokeRect(0, 0, this.cameras.main.width, this.cameras.main.height); },
      onComplete: () => _cwBorder.destroy() });

    // End timer
    this.time.delayedCall(config.duration, () => {
      this.endBlizzard(config.reward);
    });
  }

  endBlizzard(reward) {
    if (this._dailyModifier && this._dailyModifier.alwaysBlizzard) {
      // Don't end blizzard in alwaysBlizzard mode
      return;
    }
    this.blizzardActive = false;
    this.blizzardMultiplier = 1;
    this.playerSpeed = this.playerBaseSpeed;
    playBlizzardEnd();

    const activeEl = document.getElementById('blizzard-active');
    if (activeEl) activeEl.style.display = 'none';

    this.coldWaveOverlay.clear();
    this.coldWaveOverlay.setAlpha(0);

    this.showFloatingText(this.player.x, this.player.y - 60, '‚ùÑÔ∏è ÌïúÌåå ÏÉùÏ°¥!', '#88CCFF', 2000);
    this.showCenterAlert('‚òÄÔ∏è ÌïúÌåå Ï¢ÖÎ£å! Î≥¥ÏÉÅ ÏßÄÍ∏â!', '#FFDD44');
    // ARCTIC_ADAPT: post-blizzard +25% attack speed for 10s
    if (this.upgradeManager._arcticAdaptActive) {
      this.baseAttackSpeed *= 0.75;
      this.showFloatingText(this.player.x, this.player.y - 80, '‚ö° Í∑πÌïúÏ†ÅÏùë Í≥µÏÜç+25% 10Ï¥à', '#FFAA00');
      this.time.delayedCall(10000, () => { this.baseAttackSpeed /= 0.75; });
    }

    // Reward
    this.res.gold = (this.res.gold || 0) + reward.gold;
    for (let i = 0; i < reward.boxes; i++) {
      this.time.delayedCall(i * 500, () => this.spawnSupplyCrate());
    }
  }

  updateBlizzardVisuals(dt) {
    const cam = this.cameras.main;
    const W = cam.width, H = cam.height;

    // ‚ïê‚ïê‚ïê Î∏îÎ¶¨ÏûêÎìú ÌôîÎ©¥ Ìö®Í≥º (ÌïúÌåå Í∞ïÎèÑ Ïó∞Îèô) ‚ïê‚ïê‚ïê
    const coldLevel = this.blizzardActive ? this.blizzardIndex : 0;
    this.coldWaveOverlay.clear();
    if (coldLevel > 0) {
      // Î∏îÎ£® ÎπÑÎÑ§ÌåÖ (ÌïúÌåå 3+)
      if (coldLevel >= 3) {
        const vigAlpha = coldLevel >= 5 ? 0.3 : 0.15;
        // Vignette: fill edges with blue gradient approximation
        this.coldWaveOverlay.fillStyle(0x1133AA, vigAlpha);
        this.coldWaveOverlay.fillRect(0, 0, W * 0.15, H); // left
        this.coldWaveOverlay.fillRect(W * 0.85, 0, W * 0.15, H); // right
        this.coldWaveOverlay.fillRect(0, 0, W, H * 0.12); // top
        this.coldWaveOverlay.fillRect(0, H * 0.88, W, H * 0.12); // bottom
      }
      // Overall blue overlay
      const pulse = (coldLevel >= 5 ? 0.2 : coldLevel >= 3 ? 0.12 : 0.06) + Math.sin(this.time.now / 500) * 0.03;
      this.coldWaveOverlay.fillStyle(0x2244CC, pulse);
      this.coldWaveOverlay.fillRect(0, 0, W, H);
      this.coldWaveOverlay.setAlpha(1);

      // ÌôîÎ©¥ ÌùîÎì§Î¶º (ÌïúÌåå 5+)
      if (coldLevel >= 5 && !this._blizzardShaking) {
        this._blizzardShaking = true;
        cam.shake(99999, 0.002); // continuous subtle shake
      }
    } else {
      this.coldWaveOverlay.setAlpha(0);
      if (this._blizzardShaking) {
        this._blizzardShaking = false;
        cam.shake(0); // stop shake
      }
    }

    // ‚ïê‚ïê‚ïê Îàà ÏûÖÏûê ÏãúÏä§ÌÖú (ÌïúÌåå Í∞ïÎèÑ + ÏßÄÏó≠ Ïó∞Îèô) ‚ïê‚ïê‚ïê
    if (!this._snowParticles) this._snowParticles = [];
    const pZone = this.getPlayerZone();
    const zoneParticleBonus = { safe: 0, normal: 5, danger: 15, extreme: 30 }[pZone] || 0;
    const zoneDriftMul = pZone === 'extreme' ? 3 : pZone === 'danger' ? 1.5 : 1;
    const zoneSizeMul = pZone === 'danger' ? 1.5 : pZone === 'extreme' ? 0.8 : 1;
    const targetCount = Math.min(200, (coldLevel >= 5 ? 100 : coldLevel >= 3 ? 50 : coldLevel >= 1 ? 20 : 0) + zoneParticleBonus);
    const snowAlpha = coldLevel >= 5 ? 0.3 : coldLevel >= 3 ? 0.2 : 0.1;
    // Spawn missing particles
    while (this._snowParticles.length < targetCount) {
      this._snowParticles.push({
        x: Math.random() * W, y: Math.random() * H,
        speed: 80 + Math.random() * 150,
        drift: (-30 - Math.random() * 40) * zoneDriftMul,
        size: (0.5 + Math.random() * 3.5) * zoneSizeMul,
        wobble: Math.random() * Math.PI * 2,
        wobbleAmp: 0.3 + Math.random() * 0.6
      });
    }
    // Remove excess
    while (this._snowParticles.length > targetCount) this._snowParticles.pop();
    // Update & draw
    if (this._snowParticles.length > 0) {
      this._snowParticles.forEach(p => {
        p.y += p.speed * dt;
        p.x += p.drift * dt;
        p.wobble = (p.wobble || 0) + dt * 2;
        p.x += Math.sin(p.wobble) * (p.wobbleAmp || 0.3);
        if (p.y > H + 10) { p.y = -10; p.x = Math.random() * W; }
        if (p.x < -10) p.x = W + 10;
        const _spa = snowAlpha * (0.6 + Math.sin(p.wobble * 0.5) * 0.4);
        this.coldWaveOverlay.fillStyle(0xFFFFFF, Math.max(0.02, _spa));
        this.coldWaveOverlay.fillCircle(p.x, p.y, p.size);
      });
    }
  }

  // ‚ïê‚ïê‚ïê ÎààÎç©Ïù¥/ÎààÏÇ¨ÌÉú ÏãúÏä§ÌÖú ‚ïê‚ïê‚ïê
  updateSnowballs(dt) {
    if (!this._snowballs) this._snowballs = [];
    if (!this._snowballTimer) this._snowballTimer = 0;
    this._snowballTimer += dt;

    const zone = this.getPlayerZone();
    const isActive = zone === 'danger' || zone === 'extreme';
    if (!isActive) return;

    // Spawn interval: 10~20s
    const spawnInterval = zone === 'extreme' ? 10 : 15 + Math.random() * 5;
    if (this._snowballTimer >= spawnInterval) {
      this._snowballTimer = 0;
      const count = zone === 'extreme' ? Phaser.Math.Between(5, 8) : Phaser.Math.Between(1, 3);
      const cam = this.cameras.main;
      for (let i = 0; i < count; i++) {
        const size = Phaser.Math.Between(20, 60);
        const sx = cam.scrollX + Phaser.Math.Between(0, cam.width);
        const sy = cam.scrollY - 40;
        const speed = Phaser.Math.Between(150, 250);
        const driftX = Phaser.Math.Between(-40, 40);
        const g = this.add.graphics().setDepth(45);
        const snowball = { x: sx, y: sy, size, speed, driftX, graphic: g, damage: Math.floor(15 + size * 0.25) };
        // Trail particles array
        snowball.trails = [];
        this._snowballs.push(snowball);
      }
      if (zone === 'extreme') {
        this.showCenterAlert('‚õ∞Ô∏è ÎààÏÇ¨ÌÉú!', '#FFFFFF');
        this.cameras.main.shake(300, 0.01);
      }
    }

    // Update existing snowballs
    for (let i = this._snowballs.length - 1; i >= 0; i--) {
      const sb = this._snowballs[i];
      sb.y += sb.speed * dt;
      sb.x += sb.driftX * dt;
      // Draw
      sb.graphic.clear();
      sb.graphic.fillStyle(0xFFFFFF, 0.85);
      sb.graphic.fillCircle(sb.x, sb.y, sb.size / 2);
      sb.graphic.fillStyle(0xDDEEFF, 0.4);
      sb.graphic.fillCircle(sb.x - sb.size * 0.15, sb.y - sb.size * 0.15, sb.size * 0.2);

      // Player collision
      const dist = Phaser.Math.Distance.Between(sb.x, sb.y, this.player.x, this.player.y);
      if (dist < sb.size / 2 + 12) {
        this.playerHP -= sb.damage;
        if (this._triggerHitVignette) this._triggerHitVignette();
        playHurt();
        this.cameras.main.shake(150, 0.01);
        this.showFloatingText(this.player.x, this.player.y - 20, `-${sb.damage} ‚òÉÔ∏è`, '#AADDFF');
        // 0.5s slow
        const origSpeed = this.playerSpeed;
        this.playerSpeed *= 0.5;
        this.time.delayedCall(500, () => { this.playerSpeed = Math.max(this.playerSpeed, origSpeed); });
        sb.graphic.destroy();
        this._snowballs.splice(i, 1);
        if (this.playerHP <= 0) this.endGame();
        continue;
      }

      // Remove if off screen
      const cam = this.cameras.main;
      if (sb.y > cam.scrollY + cam.height + 100 || sb.x < cam.scrollX - 100 || sb.x > cam.scrollX + cam.width + 100) {
        sb.graphic.destroy();
        this._snowballs.splice(i, 1);
      }
    }
  }

  // ‚ïê‚ïê‚ïê ZONE SYSTEM ‚ïê‚ïê‚ïê
  getPlayerZone() {
    if (!this.player) return 'safe';
    const dist = Math.hypot(this.player.x - MAP_CENTER.x, this.player.y - MAP_CENTER.y);
    if (dist <= ZONE_RADII.safe) return 'safe';
    if (dist <= ZONE_RADII.normal) return 'normal';
    if (dist <= ZONE_RADII.danger) return 'danger';
    return 'extreme';
  }

  // ‚ïê‚ïê‚ïê BOSS SYSTEM ‚ïê‚ïê‚ïê
  spawnActMiniboss(type) {
    const MINIBOSS_DEFS = {
      alpha_wolf: {
        hp: 150, speed: 130, damage: 12,
        drops: { meat: 5, leather: 3, gold: 20 },
        size: 26, behavior: 'chase', name: 'üê∫ ÏïåÌåå Ïö∏ÌîÑ',
        aggroRange: 300, color: 0x4444AA, xpReward: 30,
        isMiniboss: true, sprite: 'wolf', scale: 1.8,
        escorts: { type: 'wolf', count: 4 },
        alertMsg: '‚ö†Ô∏è ÏïåÌåå Ïö∏ÌîÑ Ï∂úÌòÑ!',
        killMsg: 'üèÜ ÏïåÌåå Ïö∏ÌîÑ Ï≤òÏπò! Îã§Ïùå ÏúÑÌòë: 25Î∂Ñ'
      },
      blizzard_bear: {
        hp: 400, speed: 60, damage: 20,
        drops: { meat: 10, leather: 6, gold: 40 },
        size: 36, behavior: 'chase', name: 'üêª‚ùÑÔ∏è Î∏îÎ¶¨ÏûêÎìú Î≤†Ïñ¥',
        aggroRange: 250, color: 0x88CCFF, xpReward: 80,
        isMiniboss: true, sprite: 'bear', scale: 2.2,
        escorts: { type: 'bear', count: 3 },
        alertMsg: '‚ö†Ô∏è Î∏îÎ¶¨ÏûêÎìú Î≤†Ïñ¥ Ï∂úÌòÑ!',
        killMsg: 'üèÜ Î∏îÎ¶¨ÏûêÎìú Î≤†Ïñ¥ Ï≤òÏπò! ÏµúÏ¢Ö Ï†ÑÌà¨ÍπåÏßÄ 15Î∂Ñ'
      }
    };
    const cfg = MINIBOSS_DEFS[type];
    if (!cfg) return;

    // 2-second warning then spawn with camera effects
    this._triggerBossEntrance(cfg.name);

    this.time.delayedCall(2000, () => {
      // Spawn miniboss
      const angle = Math.random() * Math.PI * 2;
      const dist = 200 + Math.random() * 100;
      const bx = Phaser.Math.Clamp(this.player.x + Math.cos(angle) * dist, 80, WORLD_W - 80);
      const by = Phaser.Math.Clamp(this.player.y + Math.sin(angle) * dist, 80, WORLD_H - 80);

      const mb = this.physics.add.sprite(bx, by, cfg.sprite).setCollideWorldBounds(true).setDepth(5);
      mb.setScale(cfg.scale);
      mb.setTint(cfg.color);
      mb.animalType = cfg.sprite;
      mb.def = { hp: cfg.hp, speed: cfg.speed, damage: cfg.damage, drops: cfg.drops, size: cfg.size * cfg.scale, behavior: cfg.behavior, name: cfg.name, aggroRange: cfg.aggroRange, fleeRange: 0, fleeDistance: 0, color: cfg.color };
      mb.hp = cfg.hp;
      mb.maxHP = cfg.hp;
      mb.wanderTimer = 0;
      mb.wanderDir = { x: 0, y: 0 };
      mb.hitFlash = 0;
      mb.atkCD = 0;
      mb.fleeTimer = 0;
      mb.isBoss = true; // reuse boss HP bar rendering & death effects
      mb.isMiniboss = true;
      mb.minibossType = type;
      mb.hpBar = this.add.graphics().setDepth(6);
      mb.nameLabel = this.add.text(bx, by - cfg.size * cfg.scale - 10, cfg.name, {
        fontSize: '14px', fontFamily: 'monospace', color: '#FF6644', stroke: '#000', strokeThickness: 4, fontStyle: 'bold'
      }).setDepth(6).setOrigin(0.5);
      this.animals.add(mb);

      // Override kill to show custom message + XP
      const scene = this;
      const origKill = this.killAnimal.bind(this);
      const minibossKillMsg = cfg.killMsg;
      const minibossXP = cfg.xpReward;
      mb._minibossKillMsg = minibossKillMsg;
      mb._minibossXP = minibossXP;

      // Spawn escort mobs
      for (let i = 0; i < cfg.escorts.count; i++) {
        const ea = Math.random() * Math.PI * 2;
        const ed = 40 + Math.random() * 60;
        const ex = Phaser.Math.Clamp(bx + Math.cos(ea) * ed, 80, WORLD_W - 80);
        const ey = Phaser.Math.Clamp(by + Math.sin(ea) * ed, 80, WORLD_H - 80);
        const esc = this.physics.add.sprite(ex, ey, cfg.escorts.type).setCollideWorldBounds(true).setDepth(4);
        const escDef = cfg.escorts.type === 'wolf'
          ? { hp: 25, speed: 120, damage: 6, drops: { meat: 1, leather: 1 }, size: 18, behavior: 'chase', name: 'üê∫ ÎäëÎåÄ', aggroRange: 250, fleeRange: 0, fleeDistance: 0, color: 0x666688 }
          : { hp: 60, speed: 50, damage: 12, drops: { meat: 3, leather: 2 }, size: 26, behavior: 'chase', name: 'üêª Í≥∞', aggroRange: 200, fleeRange: 0, fleeDistance: 0, color: 0x8B4513 };
        esc.animalType = cfg.escorts.type;
        esc.def = escDef;
        esc.hp = escDef.hp;
        esc.maxHP = escDef.hp;
        esc.wanderTimer = 0;
        esc.wanderDir = { x: 0, y: 0 };
        esc.hitFlash = 0;
        esc.atkCD = 0;
        esc.fleeTimer = 0;
        if (escDef.hp > 2) esc.hpBar = this.add.graphics().setDepth(6);
        esc.nameLabel = this.add.text(ex, ey - escDef.size - 10, escDef.name, {
          fontSize: '11px', fontFamily: 'monospace', color: '#FFFFFF', stroke: '#000', strokeThickness: 3
        }).setDepth(6).setOrigin(0.5);
        this.animals.add(esc);
      }

      playBossSpawn();
      this.cameras.main.shake(500, 0.015);
    });
  }

  spawnBoss(type) {
    this._ftueOnBossSpawn();
    const isFinal = type === 'final';
    const bossHP = isFinal ? 4000 : 1000;
    const bossScale = isFinal ? 2.8 : 2.0;
    const bossDmg = isFinal ? 35 : 18;
    const bossSpeed = isFinal ? 60 : 55;
    const bossName = isFinal ? '‚ùÑÔ∏è Ìè≠ÌíçÏôï' : 'üêª‚Äç‚ùÑÔ∏è ÏÑúÎ¶¨Í≥∞';

    // Spawn away from player
    const angle = Math.random() * Math.PI * 2;
    const dist = 400;
    const bx = Phaser.Math.Clamp(this.player.x + Math.cos(angle) * dist, 80, WORLD_W - 80);
    const by = Phaser.Math.Clamp(this.player.y + Math.sin(angle) * dist, 80, WORLD_H - 80);

    const boss = this.physics.add.sprite(bx, by, 'bear').setCollideWorldBounds(true).setDepth(5);
    boss.setScale(bossScale);
    boss.setTint(isFinal ? 0x6666FF : 0xAABBFF);
    boss.animalType = 'boss';
    boss.def = { hp: bossHP, speed: bossSpeed, damage: bossDmg, drops: { meat: isFinal ? 30 : 15, leather: isFinal ? 15 : 8 }, size: 26 * bossScale, behavior: 'chase', name: bossName, aggroRange: 500, fleeRange: 0, fleeDistance: 0, color: 0x6666FF };
    boss.hp = bossHP;
    boss.maxHP = bossHP;
    boss.wanderTimer = 0;
    boss.wanderDir = { x: 0, y: 0 };
    boss.hitFlash = 0;
    boss.atkCD = 0;
    boss.fleeTimer = 0;
    boss.isBoss = true;
    boss.isFinalBoss = isFinal;
    boss.isFirstBoss = !isFinal;
    boss.bossPatternTimer = 0;
    boss.bossEnraged = false;
    boss.bossMinionSpawned = false;
    boss.hpBar = this.add.graphics().setDepth(6);
    boss.nameLabel = this.add.text(bx, by - boss.def.size - 10, bossName, {
      fontSize: '16px', fontFamily: 'monospace', color: '#FF4444', stroke: '#000', strokeThickness: 4, fontStyle: 'bold'
    }).setDepth(6).setOrigin(0.5);
    this.animals.add(boss);

    // Epic entrance with camera effects
    playBossSpawn();
    this._triggerBossEntrance(bossName);
  }

  // ‚ïê‚ïê‚ïê BOSS RUSH MODE SYSTEM ‚ïê‚ïê‚ïê
  _updateBossRush(dt) {
    if (!this._bossRushMode || this._bossRushCleared || this.gameOver) return;
    const elapsed = this.gameElapsed;
    // Boss Rush wave schedule: 60s, 240s, 420s, 720s
    const BOSS_RUSH_WAVES = [
      { time: 60,  name: 'üê∫ ÏïåÌåå Ïö∏ÌîÑ',   hp: 800,  scale: 1.8, dmg: 15, speed: 55, tint: 0xAABBFF, sprite: 'wolf' },
      { time: 240, name: 'üêª‚Äç‚ùÑÔ∏è ÏÑúÎ¶¨Í≥∞',    hp: 1200, scale: 2.0, dmg: 20, speed: 55, tint: 0xAABBFF, sprite: 'bear' },
      { time: 420, name: '‚ùÑÔ∏è Î∏îÎ¶¨ÏûêÎìú Î≤†Ïñ¥', hp: 2000, scale: 2.2, dmg: 25, speed: 58, tint: 0x8888FF, sprite: 'bear' },
      { time: 720, name: '‚ùÑÔ∏è Ìè≠ÌíçÏôï',       hp: 4500, scale: 2.8, dmg: 38, speed: 60, tint: 0x6666FF, sprite: 'bear' }
    ];

    // Prep phase (15s after boss kill - spawn weak enemies for XP)
    if (this._bossRushPrepPhase) {
      this._bossRushPrepTimer -= dt;
      if (this._bossRushPrepTimer <= 0) {
        this._bossRushPrepPhase = false;
        // Kill remaining prep enemies
        this.animals.getChildren().filter(a => a.active && !a.isBoss).forEach(a => { if (a.active) this.killAnimal(a); });
      }
      return;
    }

    // Check boss kill timeout (3 min after spawn)
    if (this._bossRushBossAlive && elapsed - this._bossRushBossSpawnTime >= 180) {
      this.showCenterAlert('üíÄ ÏãúÍ∞Ñ Ï¥àÍ≥º! Î≥¥Ïä§ Îü¨Ïãú Ïã§Ìå®', '#FF2222');
      this.time.delayedCall(2000, () => this._showBossRushGameOver());
      this._bossRushBossAlive = false;
      return;
    }

    // Spawn next wave boss
    for (let i = 0; i < BOSS_RUSH_WAVES.length; i++) {
      if (!this._bossRushWaveSpawned[i] && elapsed >= BOSS_RUSH_WAVES[i].time && !this._bossRushBossAlive) {
        this._bossRushWaveSpawned[i] = true;
        this._bossRushWave = i + 1;
        this._bossRushBossAlive = true;
        this._bossRushBossSpawnTime = elapsed;
        this._spawnBossRushBoss(BOSS_RUSH_WAVES[i], i);
        break;
      }
    }

    // Warning 10s before boss spawn
    for (let i = 0; i < BOSS_RUSH_WAVES.length; i++) {
      const warnKey = '_bossRushWarn' + i;
      if (!this[warnKey] && !this._bossRushWaveSpawned[i] && elapsed >= BOSS_RUSH_WAVES[i].time - 10) {
        this[warnKey] = true;
        playBossSpawn();
        this.showCenterAlert(`‚ö†Ô∏è Wave ${i+1} Î≥¥Ïä§ 10Ï¥à ÌõÑ Îì±Ïû•!`, '#FF2222');
      }
    }
  }

  _spawnBossRushBoss(cfg, waveIdx) {
    const bossRushMul = 1.1; // 10% stronger (no cold waves tradeoff)
    const hp = Math.round(cfg.hp * bossRushMul);
    const dmg = Math.round(cfg.dmg * bossRushMul);
    const angle = Math.random() * Math.PI * 2;
    const dist = 400;
    const bx = Phaser.Math.Clamp(this.player.x + Math.cos(angle) * dist, 80, WORLD_W - 80);
    const by = Phaser.Math.Clamp(this.player.y + Math.sin(angle) * dist, 80, WORLD_H - 80);

    const boss = this.physics.add.sprite(bx, by, cfg.sprite).setCollideWorldBounds(true).setDepth(5);
    boss.setScale(cfg.scale);
    boss.setTint(cfg.tint);
    boss.animalType = 'boss';
    boss.def = { hp, speed: cfg.speed, damage: dmg, drops: { meat: 15 + waveIdx * 5, leather: 8 + waveIdx * 3 }, size: 26 * cfg.scale, behavior: 'chase', name: cfg.name, aggroRange: 500, fleeRange: 0, fleeDistance: 0, color: cfg.tint };
    boss.hp = hp;
    boss.maxHP = hp;
    boss.wanderTimer = 0;
    boss.wanderDir = { x: 0, y: 0 };
    boss.hitFlash = 0;
    boss.atkCD = 0;
    boss.fleeTimer = 0;
    boss.isBoss = true;
    boss.isFinalBoss = waveIdx === 3;
    boss.isFirstBoss = waveIdx === 0;
    boss._bossRushWaveIdx = waveIdx;
    boss.bossPatternTimer = 0;
    boss.bossEnraged = false;
    boss.bossMinionSpawned = false;
    boss.hpBar = this.add.graphics().setDepth(6);
    boss.nameLabel = this.add.text(bx, by - boss.def.size - 10, cfg.name, {
      fontSize: '16px', fontFamily: 'monospace', color: '#FF4444', stroke: '#000', strokeThickness: 4, fontStyle: 'bold'
    }).setDepth(6).setOrigin(0.5);
    this.animals.add(boss);

    playBossSpawn();
    this._triggerBossEntrance(cfg.name);
    this.showCenterAlert(`üî¥ Wave ${waveIdx + 1}/4 ‚Äî ${cfg.name}`, '#FF4444');
  }

  _onBossRushBossKilled(waveIdx) {
    this._bossRushBossAlive = false;
    // Level up instantly
    this.gainXP(this.xpToNext);
    // Show upgrade UI (3 cards as boss rush reward)
    this.time.delayedCall(500, () => {
      const cards = this.upgradeManager ? this.upgradeManager.pickThreeCards(0, this._playerClass) : [];
      if (cards.length > 0) this.showUpgradeUI(cards);
    });

    if (waveIdx === 3) {
      // Final boss killed - victory!
      this._bossRushCleared = true;
      this.time.delayedCall(2000, () => this._showBossRushVictory());
    } else {
      // Start prep phase
      this._bossRushPrepPhase = true;
      this._bossRushPrepTimer = 15;
      this.showCenterAlert(`‚úÖ Wave ${waveIdx + 1} ÌÅ¥Î¶¨Ïñ¥! 15Ï¥à Ï§ÄÎπÑ`, '#44FF44');
    }
  }

  _showBossRushVictory() {
    // Record run with boss rush meta points (20)
    const totalKills = Object.values(this.stats.kills || {}).reduce((a,b)=>a+b, 0);
    const earned = MetaManager.recordRun(this.gameElapsed, totalKills, this.stats.maxCombo || 0) + 20;
    RecordManager.recordRun(this.gameElapsed, totalKills, this.playerLevel, this.stats.maxCombo || 0, true, 0);
    if (this._playerClass) SkinManager.recordClassWin(this._playerClass);
    playWinSound();
    this._showEndScreen({
      isVictory: true,
      survivalTime: this.gameElapsed,
      totalKills,
      maxCombo: this.stats.maxCombo || 0,
      level: this.playerLevel,
      earned,
      equipBonuses: this._equipBonuses
    });
  }

  _showBossRushGameOver() {
    const totalKills = Object.values(this.stats.kills || {}).reduce((a,b)=>a+b, 0);
    const earned = MetaManager.recordRun(this.gameElapsed, totalKills, this.stats.maxCombo || 0);
    RecordManager.recordRun(this.gameElapsed, totalKills, this.playerLevel, this.stats.maxCombo || 0, false, 0);
    this._showEndScreen({
      isVictory: false,
      survivalTime: this.gameElapsed,
      totalKills,
      maxCombo: this.stats.maxCombo || 0,
      level: this.playerLevel,
      earned,
      equipBonuses: this._equipBonuses
    });
  }

  // ‚ïê‚ïê‚ïê BOSS HP BAR SYSTEM ‚ïê‚ïê‚ïê
  _initBossHPBar() {
    const cam = this.cameras.main;
    this._bossHPContainer = this.add.container(cam.width / 2, 55).setScrollFactor(0).setDepth(250).setVisible(false);
    // Boss name text
    this._bossNameText = this.add.text(0, -18, '', {
      fontSize: '14px', fontFamily: 'monospace', color: '#FF6666', stroke: '#000', strokeThickness: 3, fontStyle: 'bold'
    }).setOrigin(0.5);
    // HP bar graphics
    this._bossHPGfx = this.add.graphics();
    // HP value text
    this._bossHPText = this.add.text(0, 2, '', {
      fontSize: '11px', fontFamily: 'monospace', color: '#FFFFFF', stroke: '#000', strokeThickness: 2
    }).setOrigin(0.5);
    this._bossHPContainer.add([this._bossNameText, this._bossHPGfx, this._bossHPText]);
    this._bossHPFadeOut = false;
  }

  _updateBossHPBar() {
    // Find active boss
    let activeBoss = null;
    if (this.animals) {
      this.animals.getChildren().forEach(a => {
        if (a.active && a.isBoss && a.hp > 0) {
          if (!activeBoss || (a.isBoss && !a.isMiniboss)) activeBoss = a;
        }
      });
    }
    if (activeBoss) {
      this._bossHPContainer.setVisible(true).setAlpha(1);
      this._bossHPFadeOut = false;
      const name = activeBoss.def?.name || 'Î≥¥Ïä§';
      this._bossNameText.setText(name);
      const ratio = Math.max(0, activeBoss.hp / activeBoss.maxHP);
      const barW = 300, barH = 20;
      const g = this._bossHPGfx;
      g.clear();
      // Background
      g.lineStyle(2, 0x000000, 1);
      g.strokeRect(-barW/2, -barH/2, barW, barH);
      g.fillStyle(0x111111, 0.8);
      g.fillRect(-barW/2, -barH/2, barW, barH);
      // HP fill with gradient effect (darker red left, brighter right)
      const fillW = barW * ratio;
      if (fillW > 0) {
        g.fillStyle(0xCC0000, 1);
        g.fillRect(-barW/2, -barH/2, fillW, barH);
        // Brighter overlay on right half
        g.fillStyle(0xFF3333, 0.5);
        g.fillRect(-barW/2 + fillW * 0.5, -barH/2, fillW * 0.5, barH);
      }
      this._bossHPText.setText(`HP ${Math.ceil(activeBoss.hp)} / ${activeBoss.maxHP}`);
    } else if (this._bossHPContainer.visible && !this._bossHPFadeOut) {
      this._bossHPFadeOut = true;
      this.tweens.add({
        targets: this._bossHPContainer, alpha: 0, duration: 2000,
        onComplete: () => { this._bossHPContainer.setVisible(false); }
      });
    }
  }

  // ‚ïê‚ïê‚ïê BOSS ENTRANCE CAMERA EFFECT ‚ïê‚ïê‚ïê
  _triggerBossEntrance(bossName) {
    const cam = this.cameras.main;
    // ‚ïê‚ïê‚ïê Cinematic Pause: freeze enemies for 2s ‚ïê‚ïê‚ïê
    this._bossCinematicActive = true;
    this.animals.getChildren().forEach(a => { if (a.body) a.body.setVelocity(0, 0); a._cinematicFreeze = true; });
    // Step 1: Zoom in
    cam.zoomTo(1.3, 500);
    // Step 2: Double red flash + heavy shake
    this.time.delayedCall(200, () => cam.flash(400, 255, 0, 0));
    this.time.delayedCall(400, () => cam.shake(500, 0.035));
    this.time.delayedCall(600, () => cam.flash(200, 255, 50, 50));
    // Step 3: Red border pulse
    const borderGfx = this.add.graphics().setScrollFactor(0).setDepth(299);
    let _bp = { a: 0 };
    this.tweens.add({ targets: _bp, a: 0.6, duration: 300, yoyo: true, repeat: 2,
      onUpdate: () => { borderGfx.clear(); borderGfx.lineStyle(8, 0xFF0000, _bp.a); borderGfx.strokeRect(0, 0, cam.width, cam.height); },
      onComplete: () => borderGfx.destroy() });
    // Step 4: "Î≥¥Ïä§Í∞Ä Îì±Ïû•ÌñàÎã§!" subtitle
    const subtitle = this.add.text(cam.width / 2, cam.height * 0.65, 'Î≥¥Ïä§Í∞Ä Îì±Ïû•ÌñàÎã§!', {
      fontSize: '20px', fontFamily: 'monospace', color: '#FFCC00',
      stroke: '#000', strokeThickness: 4, fontStyle: 'bold'
    }).setScrollFactor(0).setDepth(301).setOrigin(0.5).setAlpha(0);
    this.tweens.add({ targets: subtitle, alpha: 1, duration: 300, delay: 400,
      onComplete: () => this.tweens.add({ targets: subtitle, alpha: 0, duration: 500, delay: 1200, onComplete: () => subtitle.destroy() })
    });
    // Step 5: Boss HP bar "full open" animation
    const hpBarBg = this.add.rectangle(cam.width / 2, cam.height * 0.38, 0, 12, 0x330000, 0.9)
      .setScrollFactor(0).setDepth(301).setOrigin(0.5);
    const hpBarFill = this.add.rectangle(cam.width / 2, cam.height * 0.38, 0, 10, 0xFF2222, 1)
      .setScrollFactor(0).setDepth(302).setOrigin(0.5);
    const hpBarWidth = cam.width * 0.5;
    this.tweens.add({ targets: [hpBarBg, hpBarFill], width: hpBarWidth, duration: 800, delay: 500, ease: 'Power2',
      onComplete: () => this.tweens.add({ targets: [hpBarBg, hpBarFill], alpha: 0, duration: 500, delay: 800,
        onComplete: () => { hpBarBg.destroy(); hpBarFill.destroy(); }
      })
    });
    // Step 6: Zoom out
    this.time.delayedCall(1200, () => cam.zoomTo(1.0, 500));
    // Step 7: Big boss name text slide-in
    const nameText = this.add.text(cam.width / 2, cam.height / 2, bossName, {
      fontSize: '36px', fontFamily: 'monospace', color: '#FF2222',
      stroke: '#000', strokeThickness: 6, fontStyle: 'bold'
    }).setScrollFactor(0).setDepth(300).setOrigin(0.5).setAlpha(0).setX(cam.width + 200);
    this.tweens.add({
      targets: nameText, x: cam.width / 2, alpha: 1, duration: 400, ease: 'Power2',
      onComplete: () => {
        this.tweens.add({ targets: nameText, alpha: 0, y: nameText.y - 40, duration: 600, delay: 600, onComplete: () => nameText.destroy() });
      }
    });
    // Unfreeze after 2s
    this.time.delayedCall(2000, () => {
      this._bossCinematicActive = false;
      this.animals.getChildren().forEach(a => { a._cinematicFreeze = false; });
    });
  }

  // ‚ïê‚ïê‚ïê MINIMAP SYSTEM ‚ïê‚ïê‚ïê
  _initMinimap() {
    const cam = this.cameras.main;
    const size = 100;
    this._minimapSize = size;
    this._minimapVisible = cam.width > 500; // hidden on small screens
    this._minimapContainer = this.add.container(cam.width - size - 10, 10).setScrollFactor(0).setDepth(240).setVisible(this._minimapVisible);
    this._minimapBg = this.add.graphics();
    this._minimapBg.fillStyle(0x000000, 0.5);
    this._minimapBg.fillRect(0, 0, size, size);
    this._minimapBg.lineStyle(1, 0x666666, 0.8);
    this._minimapBg.strokeRect(0, 0, size, size);
    this._minimapDots = this.add.graphics();
    this._minimapContainer.add([this._minimapBg, this._minimapDots]);
    // Click to toggle
    this._minimapBg.setInteractive(new Phaser.Geom.Rectangle(0, 0, size, size), Phaser.Geom.Rectangle.Contains);
    this._minimapBg.on('pointerdown', () => {
      this._minimapVisible = false;
      this._minimapContainer.setVisible(false);
    });
    // Pulse timer for boss dot
    this._minimapPulse = 0;
  }

  _updateMinimap() {
    if (!this._minimapVisible || !this._minimapDots) return;
    const g = this._minimapDots;
    g.clear();
    const size = this._minimapSize;
    const scale = size / WORLD_W;
    this._minimapPulse = (this._minimapPulse || 0) + 0.3;

    // Player (white dot)
    if (this.player && this.player.active) {
      g.fillStyle(0xFFFFFF, 1);
      g.fillCircle(this.player.x * scale, this.player.y * scale, 3);
    }

    // Enemies (red dots, max 20) + bosses
    let enemyCount = 0;
    if (this.animals) {
      this.animals.getChildren().forEach(a => {
        if (!a.active || a.hp <= 0) return;
        if (a.isBoss) {
          // Boss: large pulsing red dot
          const r = 5 + Math.sin(this._minimapPulse) * 2;
          g.fillStyle(0xFF0000, 1);
          g.fillCircle(a.x * scale, a.y * scale, r);
        } else if (enemyCount < 20) {
          g.fillStyle(0xFF4444, 0.8);
          g.fillCircle(a.x * scale, a.y * scale, 2);
          enemyCount++;
        }
      });
    }

    // Campfires/buildings (yellow dots)
    if (this.buildingSprites) {
      this.buildingSprites.forEach(b => {
        if (b && b.active !== false) {
          g.fillStyle(0xFFDD00, 0.8);
          g.fillCircle(b.x * scale, b.y * scale, 2);
        }
      });
    }

    // NPCs (yellow dots)
    if (this.npcsOwned) {
      this.npcsOwned.forEach(n => {
        if (n && n.active) {
          g.fillStyle(0xFFDD00, 0.6);
          g.fillCircle(n.x * scale, n.y * scale, 2);
        }
      });
    }
  }

  // ‚ïê‚ïê‚ïê HIT VIGNETTE SYSTEM ‚ïê‚ïê‚ïê
  _initVignette() {
    const cam = this.cameras.main;
    this._vignetteGfx = this.add.graphics().setScrollFactor(0).setDepth(190).setAlpha(0);
    this._vignetteAlpha = 0;
    this._vignettePulse = 0;
    this._vignetteHealFlash = 0;
    this._drawVignette(this._vignetteGfx, cam.width, cam.height, 0xFF0000);
    // Green heal flash overlay
    this._healGfx = this.add.graphics().setScrollFactor(0).setDepth(190).setAlpha(0);
    this._drawVignette(this._healGfx, cam.width, cam.height, 0x00FF00);
  }

  _drawVignette(gfx, w, h, color) {
    gfx.clear();
    const thickness = 60;
    for (let i = 0; i < thickness; i++) {
      const a = (1 - i / thickness) * 0.4;
      gfx.fillStyle(color, a);
      // Top
      gfx.fillRect(0, i, w, 1);
      // Bottom
      gfx.fillRect(0, h - i - 1, w, 1);
      // Left
      gfx.fillRect(i, 0, 1, h);
      // Right
      gfx.fillRect(w - i - 1, 0, 1, h);
    }
  }

  _triggerHitVignette() {
    this._vignetteAlpha = 0.7;
  }

  _triggerHealFlash() {
    this._vignetteHealFlash = 0.5;
  }

  _updateVignette(dt) {
    if (!this._vignetteGfx) return;
    const hpRatio = this.playerHP / this.playerMaxHP;

    // Hit flash decay
    if (this._vignetteAlpha > 0) {
      this._vignetteAlpha = Math.max(0, this._vignetteAlpha - dt * 2);
    }

    // Low HP persistent pulse
    let pulseAlpha = 0;
    if (hpRatio <= 0.3 && hpRatio > 0) {
      this._vignettePulse += dt * 4;
      pulseAlpha = 0.15 + Math.sin(this._vignettePulse) * 0.1;
    }

    this._vignetteGfx.setAlpha(Math.max(this._vignetteAlpha, pulseAlpha));

    // Heal flash decay
    if (this._vignetteHealFlash > 0) {
      this._vignetteHealFlash = Math.max(0, this._vignetteHealFlash - dt * 2);
      this._healGfx.setAlpha(this._vignetteHealFlash);
    } else {
      this._healGfx.setAlpha(0);
    }
  }

  // ‚ïê‚ïê‚ïê RHYTHM SYSTEM (15-20Ï¥à Ïù¥Î≤§Ìä∏) ‚ïê‚ïê‚ïê
  updateRhythm(dt) {
    this.rhythmTimer += dt;
    if (this.rhythmTimer >= this.nextRhythmInterval) {
      this.rhythmTimer = 0;
      this.nextRhythmInterval = 15 + Math.random() * 5; // 15~20s
      this.triggerRhythmEvent();
    }
  }

  triggerRhythmEvent() {
    // Pick an event type based on what's most needed
    const events = [];

    // Resource drop cluster
    events.push('resource_drop');
    events.push('resource_drop');

    // Blizzard warning (if one is coming soon)
    if (!this.blizzardActive && this.blizzardIndex < BLIZZARD_SCHEDULE.length) {
      const next = BLIZZARD_SCHEDULE[this.blizzardIndex];
      const elapsed = this.time.now - (this.gameStartTime || this.time.now);
      if (next.startMs - elapsed < 30000 && next.startMs - elapsed > 0) {
        events.push('cold_warning');
      }
    }

    // Wave alert
    if (this.waveTimer > 20) {
      events.push('wave_alert');
    }

    const event = events[Math.floor(Math.random() * events.length)];
    switch (event) {
      case 'resource_drop':
        this.spawnResourceCluster();
        break;
      case 'cold_warning':
        this.showCenterAlert('‚ö†Ô∏è ÌïúÌåå Ï†ëÍ∑º Ï§ë...', '#4488FF');
        break;
      case 'wave_alert':
        this.showCenterAlert(`üê∫ ÏÉà Ïõ®Ïù¥Î∏å Ï†ëÍ∑º Ï§ë!`, '#FF8844');
        break;
    }
  }

  spawnResourceCluster() {
    const types = ['meat', 'wood', 'stone', 'leather'];
    const angle = Math.random() * Math.PI * 2;
    const dist = 80 + Math.random() * 120;
    const cx = Phaser.Math.Clamp(this.player.x + Math.cos(angle) * dist, 50, WORLD_W - 50);
    const cy = Phaser.Math.Clamp(this.player.y + Math.sin(angle) * dist, 50, WORLD_H - 50);
    const count = 4 + Math.floor(Math.random() * 4);
    for (let i = 0; i < count; i++) {
      const type = types[Math.floor(Math.random() * types.length)];
      this.spawnDrop(type, cx + Phaser.Math.Between(-30, 30), cy + Phaser.Math.Between(-30, 30));
    }
    this.showFloatingText(cx, cy - 20, 'üéÅ ÏûêÏõê ÎìúÎ°≠!', '#FFD700');
  }

  showCenterAlert(text, color) {
    const cam = this.cameras.main;
    const t = this.add.text(cam.width / 2, cam.height * 0.15, text, {
      fontSize: '24px', fontFamily: 'monospace', color: color,
      stroke: '#000', strokeThickness: 4, fontStyle: 'bold'
    }).setScrollFactor(0).setDepth(200).setOrigin(0.5).setAlpha(0);
    this.tweens.add({
      targets: t, alpha: 1, scale: { from: 0.5, to: 1.1 }, duration: 400, ease: 'Back.Out',
      onComplete: () => {
        this.tweens.add({ targets: t, alpha: 0, y: t.y - 30, duration: 1500, delay: 1000, onComplete: () => t.destroy() });
      }
    });
  }

  // ‚ïê‚ïê‚ïê Act Story Text (ÌÉÄÏù¥Ìïë Ìö®Í≥º) ‚ïê‚ïê‚ïê
  showActStoryText(text) {
    if (!text || this._actStoryActive) return;
    this._actStoryActive = true;
    const cam = this.cameras.main;
    const W = cam.width, H = cam.height;
    // Dark box background
    const bg = this.add.rectangle(W / 2, H * 0.78, W * 0.8, 50, 0x000000, 0.7)
      .setScrollFactor(0).setDepth(300).setOrigin(0.5).setAlpha(0);
    const storyText = this.add.text(W / 2, H * 0.78, '', {
      fontSize: '18px', fontFamily: 'monospace', color: '#FFFFFF',
      stroke: '#000', strokeThickness: 3, fontStyle: 'bold', align: 'center',
      wordWrap: { width: W * 0.75 }
    }).setScrollFactor(0).setDepth(301).setOrigin(0.5).setAlpha(0);
    // Fade in bg
    this.tweens.add({ targets: [bg, storyText], alpha: 1, duration: 300 });
    // Typing effect
    let charIndex = 0;
    const typingTimer = this.time.addEvent({
      delay: 50, loop: true,
      callback: () => {
        charIndex++;
        storyText.setText(text.substring(0, charIndex));
        if (charIndex >= text.length) {
          typingTimer.destroy();
          // Wait 2s then fade out
          this.time.delayedCall(2000, () => {
            this.tweens.add({
              targets: [bg, storyText], alpha: 0, duration: 500,
              onComplete: () => { bg.destroy(); storyText.destroy(); this._actStoryActive = false; }
            });
          });
        }
      }
    });
  }

  // ‚ïê‚ïê‚ïê Region Name Banner ‚ïê‚ïê‚ïê
  showRegionBanner(zone) {
    const region = REGION_NAMES[zone];
    if (!region) return;
    const cam = this.cameras.main;
    const banner = this.add.text(cam.width / 2, cam.height * 0.12, region.name, {
      fontSize: '22px', fontFamily: 'monospace', color: region.color,
      stroke: '#000', strokeThickness: 4, fontStyle: 'bold'
    }).setScrollFactor(0).setDepth(200).setOrigin(0.5).setAlpha(0);
    this.tweens.add({
      targets: banner, alpha: 1, duration: 300, ease: 'Power2',
      onComplete: () => {
        this.tweens.add({ targets: banner, alpha: 0, duration: 500, delay: 2000, onComplete: () => banner.destroy() });
      }
    });
  }

  // ‚ïê‚ïê‚ïê NPC Speech Bubble ‚ïê‚ïê‚ïê
  showNPCBubble(npc, text) {
    if (npc._bubbleActive) return;
    npc._bubbleActive = true;
    const bubbleBg = this.add.rectangle(npc.x, npc.y - 35, 10, 24, 0xFFFFFF, 0.9)
      .setDepth(200).setOrigin(0.5, 1).setStrokeStyle(1, 0x000000);
    const bubbleText = this.add.text(npc.x, npc.y - 36, text, {
      fontSize: '11px', fontFamily: 'monospace', color: '#000000', align: 'center',
      wordWrap: { width: 180 }
    }).setDepth(201).setOrigin(0.5, 1);
    // Resize bg to fit text
    bubbleBg.setSize(bubbleText.width + 16, bubbleText.height + 10);
    bubbleBg.setPosition(npc.x, npc.y - 30);
    bubbleText.setPosition(npc.x, npc.y - 31);
    this.time.delayedCall(3000, () => {
      this.tweens.add({
        targets: [bubbleBg, bubbleText], alpha: 0, duration: 300,
        onComplete: () => { bubbleBg.destroy(); bubbleText.destroy(); npc._bubbleActive = false; }
      });
    });
  }

  _showMilestoneBanner(text, color = '#FFD700', duration = 2000) {
    const cam = this.cameras.main;
    // Golden particles
    for (let i = 0; i < 15; i++) {
      const px = cam.centerX + Phaser.Math.Between(-150, 150);
      const py = cam.centerY + Phaser.Math.Between(-80, 80);
      const p = this.add.circle(px, py, Phaser.Math.Between(2, 5), 0xFFD700).setDepth(200).setScrollFactor(0).setAlpha(0.9);
      this.tweens.add({ targets: p, y: py - 60, alpha: 0, duration: 1000 + Math.random() * 500, onComplete: () => p.destroy() });
    }
    const t = this.add.text(cam.centerX, cam.centerY - 40, text, {
      fontSize: '32px', fontFamily: 'monospace', color, stroke: '#000', strokeThickness: 5, fontStyle: 'bold'
    }).setOrigin(0.5).setDepth(200).setScrollFactor(0).setScale(0.3).setAlpha(0);
    this.tweens.add({ targets: t, scale: 1.2, alpha: 1, duration: 400, ease: 'Back.Out', onComplete: () => {
      this.tweens.add({ targets: t, scale: 1, duration: 200, onComplete: () => {
        this.tweens.add({ targets: t, alpha: 0, y: t.y - 40, duration: 1000, delay: duration - 600, onComplete: () => t.destroy() });
      }});
    }});
  }

  _spawnEndlessBoss(index) {
    const hpMul = Math.pow(1.5, index + 1);
    const bossHP = Math.round(4000 * hpMul);
    const bossDmg = Math.round(35 * Math.pow(1.2, index));
    const bossSpeed = 60 + index * 5;
    const bossName = `‚ùÑÔ∏è Ìè≠ÌíçÏôï Lv.${index + 2}`;

    playBossSpawn();
    this._triggerBossEntrance(bossName);

    this.time.delayedCall(2000, () => {
      const angle = Math.random() * Math.PI * 2;
      const dist = 400;
      const bx = Phaser.Math.Clamp(this.player.x + Math.cos(angle) * dist, 80, WORLD_W - 80);
      const by = Phaser.Math.Clamp(this.player.y + Math.sin(angle) * dist, 80, WORLD_H - 80);
      const boss = this.physics.add.sprite(bx, by, 'bear').setCollideWorldBounds(true).setDepth(5);
      boss.setScale(2.8 + index * 0.2);
      boss.setTint(0x8866FF);
      boss.animalType = 'boss';
      boss.def = { hp: bossHP, speed: bossSpeed, damage: bossDmg, drops: { meat: 30, leather: 15, gold: 50 }, size: 26 * (2.8 + index * 0.2), behavior: 'chase', name: bossName, aggroRange: 500, fleeRange: 0, fleeDistance: 0, color: 0x8866FF };
      boss.hp = bossHP; boss.maxHP = bossHP;
      boss.wanderTimer = 0; boss.wanderDir = {x:0,y:0}; boss.hitFlash = 0; boss.atkCD = 0; boss.fleeTimer = 0;
      boss.isBoss = true;
      boss.hpBar = this.add.graphics().setDepth(6);
      boss.nameLabel = this.add.text(bx, by - boss.def.size - 10, bossName, {
        fontSize: '16px', fontFamily: 'monospace', color: '#FF66FF', stroke: '#000', strokeThickness: 4, fontStyle: 'bold'
      }).setDepth(6).setOrigin(0.5);
      this.animals.add(boss);
    });
  }

  _updateSpeedrunHUD() {
    const cam = this.cameras.main;
    const remaining = Math.max(0, this._speedrunTimer);
    const min = Math.floor(remaining / 60);
    const sec = Math.floor(remaining % 60);
    const timeStr = `${String(min).padStart(2,'0')}:${String(sec).padStart(2,'0')}`;
    const isUrgent = remaining <= 300;
    if (!this._speedrunTimerText) {
      this._speedrunTimerText = this.add.text(cam.width / 2, 18, '', {
        fontSize: '22px', fontFamily: 'monospace', color: '#FFCC44',
        stroke: '#000', strokeThickness: 4, fontStyle: 'bold'
      }).setOrigin(0.5).setDepth(250).setScrollFactor(0);
    }
    this._speedrunTimerText.setText('‚ö° ' + timeStr);
    this._speedrunTimerText.setColor(isUrgent ? '#FF4444' : '#FFCC44');
  }

  _triggerSpeedrunVictory() {
    const remaining = Math.max(0, this._speedrunTimer);
    // Record speedrun
    const rec = RecordManager.load();
    rec.speedrunClears = (rec.speedrunClears || 0) + 1;
    if (remaining > (rec.bestSpeedrunTime || 0)) {
      rec.bestSpeedrunTime = remaining;
    }
    RecordManager.save(rec);
    // Check achievements
    try {
      const ach = JSON.parse(localStorage.getItem('achievements_whiteout') || '{}');
      ach['speedrun_clear'] = true;
      if (remaining >= 600) ach['speedrun_sub_20'] = true;
      localStorage.setItem('achievements_whiteout', JSON.stringify(ach));
    } catch(e) {}
    // Also check handicap achievement
    if (this._handicap && this._handicap !== 'none') {
      try {
        const ach = JSON.parse(localStorage.getItem('achievements_whiteout') || '{}');
        ach['handicap_win'] = true;
        localStorage.setItem('achievements_whiteout', JSON.stringify(ach));
      } catch(e) {}
      const hRec = RecordManager.load();
      hRec.handicapClears = (hRec.handicapClears || 0) + 1;
      RecordManager.save(hRec);
    }
    this._showMilestoneBanner('‚ö° Ïä§ÌîºÎìúÎü∞ ÌÅ¥Î¶¨Ïñ¥! ÎÇ®ÏùÄ ÏãúÍ∞Ñ: ' + Math.floor(remaining/60) + 'Î∂Ñ ' + Math.floor(remaining%60) + 'Ï¥à', '#FFCC44', 3000);
    this.time.delayedCall(2000, () => this.showVictory());
  }

  showVictory() {
    if (this.gameOver) return;
    this.gameOver = true;
    
    // Record class win for skin unlock
    if (this._playerClass) {
      SkinManager.recordClassWin(this._playerClass);
    }
    // Record NG+ clear
    if (this._ngPlus) {
      const ngRec = RecordManager.load();
      ngRec.ngPlusClears = (ngRec.ngPlusClears || 0) + 1;
      RecordManager.save(ngRec);
    }
    // Record Boss Rush clear
    if (this._bossRushMode) {
      const brRec = RecordManager.load();
      brRec.bossRushClears = (brRec.bossRushClears || 0) + 1;
      RecordManager.save(brRec);
    }
    // Record Hard+ clear
    if (this._difficulty === 'hard' || this._difficulty === 'hell') {
      const hRec = RecordManager.load();
      hRec.hardClears = (hRec.hardClears || 0) + 1;
      RecordManager.save(hRec);
    }

    const totalKills = Object.values(this.stats.kills || {}).reduce((a,b)=>a+b, 0);
    const diffBonus = this._diffMode ? this._diffMode.clearBonus : 10;
    const ngPlusBonus = this._ngPlus ? 30 : 0;
    const speedrunBonus = this._speedrunMode ? 15 : 0;
    const handicapBonusMap = { none: 0, glass_body: 15, no_equipment: 20, random_build: 10, low_vision: 25 };
    const handicapBonus = handicapBonusMap[this._handicap] || 0;
    const earned = MetaManager.recordRun(this.gameElapsed, totalKills, this.stats.maxCombo || 0) + diffBonus + ngPlusBonus + speedrunBonus + handicapBonus;
    // Record handicap clear
    if (this._handicap && this._handicap !== 'none') {
      const hRec = RecordManager.load();
      hRec.handicapClears = (hRec.handicapClears || 0) + 1;
      RecordManager.save(hRec);
      try {
        const ach = JSON.parse(localStorage.getItem('achievements_whiteout') || '{}');
        ach['handicap_win'] = true;
        localStorage.setItem('achievements_whiteout', JSON.stringify(ach));
      } catch(e) {}
    }
    playWinSound();
    // Save daily challenge clear
    if (this._dailyChallenge) {
      try { localStorage.setItem('daily_clear_' + getDailyChallengeKey(), 'true'); } catch(e) {}
    }

    this._showEndScreen({
      isVictory: true,
      survivalTime: this.gameElapsed,
      totalKills,
      maxCombo: this.stats.maxCombo || 0,
      level: this.playerLevel,
      earned,
      equipBonuses: this._equipBonuses
    });
  }

  // ‚ïê‚ïê‚ïê HABBY-STYLE END SCREEN ‚ïê‚ïê‚ïê
  _showEndScreen(opts) {
    const { isVictory, survivalTime, totalKills, maxCombo, level, earned, equipBonuses } = opts;

    // ‚ïê‚ïê‚ïê Îü∞ ÌûàÏä§ÌÜ†Î¶¨ Ï†ÄÏû• ‚ïê‚ïê‚ïê
    this._saveRunHistory(isVictory, survivalTime, totalKills, maxCombo, level, earned);

    // ‚ïê‚ïê‚ïê Ï†êÏàò Í≥ÑÏÇ∞ ‚ïê‚ïê‚ïê
    const finalScore = ScoreSystem.calculate({
      survivalTime, kills: totalKills, maxCombo, level,
      difficulty: this._difficulty || 'normal',
      handicap: this._handicap,
      equipmentManager: this.equipmentManager,
      isSpeedrun: this._speedrunMode,
      speedrunRemaining: this._speedrunTimer || 0
    });
    const gradeInfo = ScoreSystem.getGrade(finalScore);
    const percentile = ScoreSystem.getPercentile(finalScore);
    const classInfo = this._playerClass && PLAYER_CLASSES[this._playerClass] ? PLAYER_CLASSES[this._playerClass] : null;
    const diffName = this._diffMode ? this._diffMode.name.replace(/[^Í∞Ä-Ìû£a-zA-Z]/g, '') : 'ÏùºÎ∞ò';

    // Save score
    ScoreSystem.saveScore({
      score: finalScore, grade: gradeInfo.grade,
      date: new Date().toLocaleDateString('ko-KR'),
      survivalTime: Math.floor(survivalTime), kills: totalKills, level, maxCombo,
      difficulty: this._difficulty || 'normal',
      playerClass: this._playerClass || 'unknown', isWin: !!isVictory
    });

    const cam = this.cameras.main;
    const W = cam.width, H = cam.height;

    const tl = document.getElementById('timeline-bar');
    if (tl) tl.style.display = 'none';
    const ne = document.getElementById('next-event-text');
    if (ne) ne.style.display = 'none';
    const ch = document.getElementById('class-hud');
    if (ch) ch.style.display = 'none';

    let achCount = 0;
    try { achCount = Object.keys(JSON.parse(localStorage.getItem('achievements_whiteout') || '{}')).length; } catch(e) {}
    const newRecords = RecordManager.recordRun(survivalTime, totalKills, level, maxCombo, isVictory, achCount);
    const hasNewRecord = newRecords.length > 0;

    if (isVictory) { cam.flash(1000, 200, 255, 200); cam.shake(500, 0.01); }
    else { cam.flash(400, 255, 0, 0); cam.shake(500, 0.02); }

    const ov = this.add.graphics().setScrollFactor(0).setDepth(300);
    ov.fillStyle(0x0A0E1A, 0).fillRect(0, 0, W, H);
    this.tweens.add({ targets: ov, alpha: 0.85, duration: 600 });

    const panelW = Math.min(360, W - 30), panelH = 500;
    const px = W/2, py = H/2;
    const panel = this.add.graphics().setScrollFactor(0).setDepth(301);
    panel.fillStyle(0x1A1E2E, 0.95);
    panel.fillRoundedRect(px - panelW/2, py - panelH/2, panelW, panelH, 16);
    panel.lineStyle(2, isVictory ? 0xFFD700 : 0xFF4444, 0.6);
    panel.strokeRoundedRect(px - panelW/2, py - panelH/2, panelW, panelH, 16);
    panel.setAlpha(0);

    // ‚ïê‚ïê‚ïê Îì±Í∏â (ÏµúÏÉÅÎã®) ‚ïê‚ïê‚ïê
    const gradeLabel = this.add.text(px, py - panelH/2 + 38, gradeInfo.grade, {
      fontSize: '48px', fontFamily: 'monospace', color: gradeInfo.color,
      stroke: '#000', strokeThickness: 6, fontStyle: 'bold'
    }).setScrollFactor(0).setDepth(302).setOrigin(0.5).setAlpha(0);

    const gradeTitle = this.add.text(px, py - panelH/2 + 72, gradeInfo.title, {
      fontSize: '15px', fontFamily: 'monospace', color: gradeInfo.color,
      stroke: '#000', strokeThickness: 3
    }).setScrollFactor(0).setDepth(302).setOrigin(0.5).setAlpha(0);

    // ‚ïê‚ïê‚ïê Ï†êÏàò ‚ïê‚ïê‚ïê
    const scoreDisplay = this.add.text(px, py - panelH/2 + 100, ScoreSystem.formatScore(finalScore) + 'Ï†ê', {
      fontSize: '24px', fontFamily: 'monospace', color: '#FFFFFF',
      stroke: '#000', strokeThickness: 4, fontStyle: 'bold'
    }).setScrollFactor(0).setDepth(302).setOrigin(0.5).setAlpha(0);

    const percentileText = this.add.text(px, py - panelH/2 + 125, 'üåç ÏÉÅÏúÑ ' + percentile + '%', {
      fontSize: '12px', fontFamily: 'monospace', color: '#AADDFF',
      stroke: '#000', strokeThickness: 2
    }).setScrollFactor(0).setDepth(302).setOrigin(0.5).setAlpha(0);

    const icon = this.add.text(px, py - panelH/2 + 155, isVictory ? 'üèÜ' : 'üíÄ', {
      fontSize: '28px'
    }).setScrollFactor(0).setDepth(302).setOrigin(0.5).setAlpha(0);

    const titleColor = isVictory ? '#FFD700' : '#FF4444';
    const ngPlusTag = (isVictory && this._ngPlus) ? ' NG+' + (RecordManager.load().ngPlusClears || 1) : '';
    const titleText = isVictory ? 'ÏÉùÏ°¥ ÏÑ±Í≥µ!' + ngPlusTag : 'ÏÉùÏ°¥ Ïã§Ìå®';
    const title = this.add.text(px, py - panelH/2 + 185, titleText, {
      fontSize: '22px', fontFamily: 'monospace', color: titleColor,
      stroke: '#000', strokeThickness: 3, fontStyle: 'bold'
    }).setScrollFactor(0).setDepth(302).setOrigin(0.5).setAlpha(0);

    const survMin = Math.floor(survivalTime / 60);
    const survSec = Math.floor(survivalTime % 60);
    const nr = (key) => newRecords.includes(key) ? ' üÜï' : '';
    const statsLines = [
      '‚è±Ô∏è ' + survMin + 'Î∂Ñ ' + survSec + 'Ï¥à' + nr('survivalTime') + '  ‚öîÔ∏è ' + totalKills + 'ÌÇ¨' + nr('kills'),
      'üî• ÏΩ§Î≥¥ ' + maxCombo + nr('combo') + '  ‚≠ê Lv.' + level + nr('level'),
      'üíé Ìè¨Ïù∏Ìä∏: +0'
    ];
    if (this._diffMode && this._difficulty !== 'normal') statsLines.push('üéÆ ' + this._diffMode.name);
    if (this._endlessMode) statsLines.push('‚ôæÔ∏è Î¨¥Ìïú Î™®Îìú');
    if (this._speedrunMode) statsLines.push('‚ö° Ïä§ÌîºÎìúÎü∞');
    if (this._handicap && this._handicap !== 'none') {
      const hNames = { glass_body: 'Ïú†Î¶¨Î™∏', no_equipment: 'Îß®ÏÜê', random_build: 'ÎûúÎç§ ÎπåÎìú', low_vision: 'Ï†ÄÏãúÎ†•' };
      statsLines.push('üéØ Ìï∏ÎîîÏ∫°: ' + (hNames[this._handicap] || this._handicap));
    }
    if (this._dailyChallenge) statsLines.push(isVictory ? 'üìÖ Îç∞ÏùºÎ¶¨ ÌÅ¥Î¶¨Ïñ¥!' : 'üìÖ ' + this._dailyChallenge.name);
    if (equipBonuses) {
      const bs = [];
      if (equipBonuses.atkMul > 0) bs.push('Í≥µ+' + Math.round(equipBonuses.atkMul*100) + '%');
      if (equipBonuses.defMul > 0) bs.push('Î∞©+' + Math.round(equipBonuses.defMul*100) + '%');
      if (equipBonuses.spdMul > 0) bs.push('ÏÜç+' + Math.round(equipBonuses.spdMul*100) + '%');
      if (equipBonuses.hpFlat > 0) bs.push('HP+' + Math.round(equipBonuses.hpFlat));
      if (bs.length) statsLines.push('üõ°Ô∏è ' + bs.join(' '));
    }
    const stats = this.add.text(px, py + 10, statsLines.join('\n'), {
      fontSize: '13px', fontFamily: 'monospace', color: '#CCDDEE',
      stroke: '#000', strokeThickness: 2, align: 'center', lineSpacing: 5
    }).setScrollFactor(0).setDepth(302).setOrigin(0.5).setAlpha(0);

    let newRecordLabel = null;
    if (hasNewRecord) {
      newRecordLabel = this.add.text(px, py - panelH/2 + 205, 'üÜï Ïã†Í∏∞Î°ù!', {
        fontSize: '14px', fontFamily: 'monospace', color: '#FFD700',
        stroke: '#000', strokeThickness: 3, fontStyle: 'bold'
      }).setScrollFactor(0).setDepth(302).setOrigin(0.5).setAlpha(0);
    }

    let buildSummary = null;
    if (this._currentRunUpgrades && this._currentRunUpgrades.length > 0) {
      const counts = {};
      this._currentRunUpgrades.forEach(k => { counts[k] = (counts[k] || 0) + 1; });
      const sorted = Object.entries(counts).sort((a,b) => b[1] - a[1]).slice(0, 5);
      const buildStr = sorted.map(([k, c]) => {
        const u = UPGRADES[k];
        return u ? u.icon + u.name + (c > 1 ? 'x'+c : '') : k;
      }).join('  ');
      buildSummary = this.add.text(px, py + 70, 'üîß ' + buildStr, {
        fontSize: '10px', fontFamily: 'monospace', color: '#AADDFF',
        stroke: '#000', strokeThickness: 2, wordWrap: { width: panelW - 20 }, align: 'center'
      }).setScrollFactor(0).setDepth(302).setOrigin(0.5).setAlpha(0);
    }

    // ‚ïê‚ïê‚ïê Buttons: 2 rows ‚ïê‚ïê‚ïê
    const btnW = 130, btnH = 32, btnGap = 8;
    const btnRow1Y = py + panelH/2 - 80;
    const btnRow2Y = py + panelH/2 - 42;

    const retryBg = this.add.graphics().setScrollFactor(0).setDepth(302);
    retryBg.fillStyle(0xFF6B35, 1);
    retryBg.fillRoundedRect(px - btnW - btnGap/2, btnRow1Y, btnW, btnH, 8);
    retryBg.setAlpha(0);
    const retryText = this.add.text(px - btnW/2 - btnGap/2, btnRow1Y + btnH/2, 'üîÑ Ïû¨ÎèÑÏ†Ñ', {
      fontSize: '13px', fontFamily: 'monospace', color: '#FFFFFF',
      stroke: '#000', strokeThickness: 2, fontStyle: 'bold'
    }).setScrollFactor(0).setDepth(303).setOrigin(0.5).setAlpha(0);
    const retryHit = this.add.rectangle(px - btnW/2 - btnGap/2, btnRow1Y + btnH/2, btnW, btnH)
      .setScrollFactor(0).setDepth(304).setOrigin(0.5).setInteractive().setAlpha(0.001);

    const titleBg = this.add.graphics().setScrollFactor(0).setDepth(302);
    titleBg.fillStyle(0x2A2E3E, 1);
    titleBg.fillRoundedRect(px + btnGap/2, btnRow1Y, btnW, btnH, 8);
    titleBg.lineStyle(1, 0x555577, 0.6);
    titleBg.strokeRoundedRect(px + btnGap/2, btnRow1Y, btnW, btnH, 8);
    titleBg.setAlpha(0);
    const titleBtnText = this.add.text(px + btnW/2 + btnGap/2, btnRow1Y + btnH/2, 'üè† ÌÉÄÏù¥ÌãÄ', {
      fontSize: '13px', fontFamily: 'monospace', color: '#AABBCC',
      stroke: '#000', strokeThickness: 2
    }).setScrollFactor(0).setDepth(303).setOrigin(0.5).setAlpha(0);
    const titleHit = this.add.rectangle(px + btnW/2 + btnGap/2, btnRow1Y + btnH/2, btnW, btnH)
      .setScrollFactor(0).setDepth(304).setOrigin(0.5).setInteractive().setAlpha(0.001);

    // Row 2: share buttons
    const shareBg = this.add.graphics().setScrollFactor(0).setDepth(302);
    shareBg.fillStyle(0x225566, 1);
    shareBg.fillRoundedRect(px - btnW - btnGap/2, btnRow2Y, btnW, btnH, 8);
    shareBg.setAlpha(0);
    const shareText = this.add.text(px - btnW/2 - btnGap/2, btnRow2Y + btnH/2, 'üìã Í≤∞Í≥º Î≥µÏÇ¨', {
      fontSize: '13px', fontFamily: 'monospace', color: '#88CCDD',
      stroke: '#000', strokeThickness: 2
    }).setScrollFactor(0).setDepth(303).setOrigin(0.5).setAlpha(0);
    const shareHit = this.add.rectangle(px - btnW/2 - btnGap/2, btnRow2Y + btnH/2, btnW, btnH)
      .setScrollFactor(0).setDepth(304).setOrigin(0.5).setInteractive().setAlpha(0.001);

    const twitterBg = this.add.graphics().setScrollFactor(0).setDepth(302);
    twitterBg.fillStyle(0x1DA1F2, 0.8);
    twitterBg.fillRoundedRect(px + btnGap/2, btnRow2Y, btnW, btnH, 8);
    twitterBg.setAlpha(0);
    const twitterText = this.add.text(px + btnW/2 + btnGap/2, btnRow2Y + btnH/2, 'üê¶ X Í≥µÏú†', {
      fontSize: '13px', fontFamily: 'monospace', color: '#FFFFFF',
      stroke: '#000', strokeThickness: 2
    }).setScrollFactor(0).setDepth(303).setOrigin(0.5).setAlpha(0);
    const twitterHit = this.add.rectangle(px + btnW/2 + btnGap/2, btnRow2Y + btnH/2, btnW, btnH)
      .setScrollFactor(0).setDepth(304).setOrigin(0.5).setInteractive().setAlpha(0.001);

    const _buildShareMsg = () => {
      const cn = classInfo ? classInfo.name : 'ÎØ∏ÏÑ†ÌÉù';
      return '‚ùÑÔ∏è ÌôîÏù¥Ìä∏ÏïÑÏõÉ ÏÑúÎ∞îÏù¥Î≤å\nÎì±Í∏â: [' + gradeInfo.grade + '] ' + gradeInfo.title + '\nÏ†êÏàò: ' + ScoreSystem.formatScore(finalScore) + 'Ï†ê\nÏÉùÏ°¥: ' + survMin + 'Î∂Ñ ' + String(survSec).padStart(2,'0') + 'Ï¥à | ÌÇ¨: ' + totalKills + ' | Î†àÎ≤®: ' + level + '\nÏµúÍ≥†ÏΩ§Î≥¥: ' + maxCombo + ' | ÌÅ¥ÎûòÏä§: ' + cn + '\nÎÇúÏù¥ÎèÑ: ' + diffName + '\nhttps://prota100.github.io/whiteout-survival/';
    };

    retryHit.on('pointerdown', () => { this.scene.start('Boot', { loadSave: false, difficulty: this._difficulty, dailyChallenge: this._dailyChallenge, endlessMode: this._endlessMode, speedrun: this._speedrunMode, handicap: this._handicap }); });
    titleHit.on('pointerdown', () => { this.scene.start('Title'); });
    shareHit.on('pointerdown', () => {
      const msg = _buildShareMsg();
      try {
        navigator.clipboard.writeText(msg).then(() => {
          shareText.setText('‚úÖ Î≥µÏÇ¨Îê®!');
          this.time.delayedCall(1500, () => { if(shareText.active) shareText.setText('üìã Í≤∞Í≥º Î≥µÏÇ¨'); });
        }).catch(() => {});
      } catch(e) {}
    });
    twitterHit.on('pointerdown', () => {
      const msg = _buildShareMsg();
      window.open('https://twitter.com/intent/tweet?text=' + encodeURIComponent(msg), '_blank');
    });

    const allElements = [panel, gradeLabel, gradeTitle, scoreDisplay, percentileText, icon, title, stats, retryBg, retryText, titleBg, titleBtnText, shareBg, shareText, twitterBg, twitterText];
    if (buildSummary) allElements.splice(8, 0, buildSummary);
    if (newRecordLabel) allElements.splice(7, 0, newRecordLabel);
    allElements.forEach((el, i) => {
      if (el.y !== undefined) el.y -= 40;
      this.tweens.add({
        targets: el, alpha: 1, y: (el.y !== undefined ? el.y + 40 : undefined),
        duration: 500, ease: 'Back.Out', delay: 200 + i * 80
      });
    });
    // Point counting animation (0 ‚Üí earned over 0.5s)
    if (earned > 0) {
      const pointIdx = statsLines.findIndex(l => l.includes('üíé'));
      if (pointIdx >= 0) {
        this.tweens.add({ targets: { v: 0 }, v: earned, duration: 500, delay: 800, ease: 'Quad.Out',
          onUpdate: (_, t) => {
            statsLines[pointIdx] = `üíé ÌöçÎìù Ìè¨Ïù∏Ìä∏: +${Math.round(t.v)}`;
            if (stats.active) stats.setText(statsLines.join('\n'));
          }
        });
      }
    }

    // ‚ïê‚ïê‚ïê Ïã†Í∏∞Î°ù Ìô©Í∏à ÌååÌã∞ÌÅ¥ Ìö®Í≥º ‚ïê‚ïê‚ïê
    if (hasNewRecord) {
      const goldGfx = this.add.graphics().setScrollFactor(0).setDepth(305);
      const particles = [];
      for (let i = 0; i < 30; i++) {
        particles.push({
          x: px + Phaser.Math.Between(-panelW/2, panelW/2),
          y: py - panelH/2 - 10,
          vx: Phaser.Math.FloatBetween(-1.5, 1.5),
          vy: Phaser.Math.FloatBetween(0.5, 3),
          size: Phaser.Math.FloatBetween(2, 5),
          life: 1,
          decay: Phaser.Math.FloatBetween(0.005, 0.015)
        });
      }
      const goldTimer = this.time.addEvent({
        delay: 30, loop: true,
        callback: () => {
          goldGfx.clear();
          let alive = false;
          particles.forEach(p => {
            if (p.life <= 0) return;
            alive = true;
            p.x += p.vx; p.y += p.vy; p.life -= p.decay;
            goldGfx.fillStyle(0xFFD700, p.life);
            goldGfx.fillCircle(p.x, p.y, p.size * p.life);
          });
          if (!alive) { goldTimer.destroy(); goldGfx.destroy(); }
        }
      });
    }
  }

  _saveRunHistory(isVictory, survivalTime, totalKills, maxCombo, level, earned) {
    const now = new Date();
    const date = `${now.getMonth()+1}/${now.getDate()} ${String(now.getHours()).padStart(2,'0')}:${String(now.getMinutes()).padStart(2,'0')}`;
    const equippedItems = {};
    if (this.equipmentManager) {
      for (const [slot, item] of Object.entries(this.equipmentManager.slots || {})) {
        if (item) equippedItems[slot] = { itemId: item.itemId, grade: item.grade };
      }
    }
    const synergiesActivated = this.synergyManager ? [...this.synergyManager.activeSynergies] : [];
    // Achievements unlocked this run (ones not in _savedAchievements at start)
    const achThisRun = Object.keys(this.achievementUnlocked || {});
    const runData = {
      timestamp: Date.now(),
      date,
      playerClass: this._playerClass || 'unknown',
      difficulty: this._difficulty || 'normal',
      survivalTime: Math.floor(survivalTime),
      kills: totalKills,
      maxCombo,
      level,
      isWin: !!isVictory,
      isEndless: !!this._endlessMode,
      endlessTime: this._endlessMode ? Math.floor(survivalTime) : 0,
      equippedItems,
      upgrades: this._currentRunUpgrades || [],
      synergiesActivated,
      achievementsUnlocked: achThisRun,
      metaPointsEarned: earned || 0,
    };
    this._runHistoryManager.save(runData);
  }

  endGame() {
    // Mark FTUE as done after first game
    FTUEManager.markDone();
    // GDD: HP 0 ‚Üí ÎßàÏùÑÎ°ú Î¶¨Ïä§Ìè∞ 3Ï¥à (ÌÜµÍ≥Ñ ÌëúÏãú)
    if (this.gameOver || this.isRespawning) return;
    // Revival scroll check
    const revMeta = MetaManager.load();
    if (!this._revivalUsed && revMeta.upgrades && revMeta.upgrades.revival_scroll >= 1) {
      this._revivalUsed = true;
      playRevival();
      this.playerHP = Math.floor(this.playerMaxHP / 2);
      this.player.setAlpha(0.5);
      this._invincibleTimer = 10;
      this._showMilestoneBanner('üí´ Î∂ÄÌôúÌñàÏäµÎãàÎã§! (10Ï¥à Î¨¥Ï†Å)', '#FFD700', 3000);
      return;
    }
    this.isRespawning = true;
    playGameOverSound();

    const totalKills = Object.values(this.stats.kills || {}).reduce((a,b)=>a+b, 0);
    const earned = MetaManager.recordRun(this.gameElapsed, totalKills, this.stats.maxCombo || 0);

    // Record endless survival time
    if (this._endlessMode) {
      const rec = RecordManager.load();
      if (this.gameElapsed > (rec.longestEndlessSurvival || 0)) {
        rec.longestEndlessSurvival = this.gameElapsed;
        RecordManager.save(rec);
      }
    }

    this._showEndScreen({
      isVictory: false,
      survivalTime: this.gameElapsed,
      totalKills,
      maxCombo: this.stats.maxCombo || 0,
      level: this.playerLevel,
      earned,
      equipBonuses: this._equipBonuses
    });

    // Auto-cleanup after choosing or timeout (respawn fallback)
    this._endScreenCleanup = this.time.delayedCall(30000, () => {
      this.scene.start('Title');
    });
  }

  update(time, deltaMs) {
    if (this.gameOver || this.upgradeUIActive || this.isRespawning || this._gamePaused) return;
    const dt = deltaMs / 1000;
    this.attackCooldown = Math.max(0, this.attackCooldown - dt);
    // Revival invincibility timer
    if (this._invincibleTimer > 0) {
      this._invincibleTimer -= dt;
      if (this.player) this.player.setAlpha(0.4 + Math.sin(Date.now() * 0.01) * 0.3);
      if (this._invincibleTimer <= 0 && this.player) this.player.setAlpha(1);
    }

    // ‚ïê‚ïê‚ïê Class Passive: Warrior Rage Mode ‚ïê‚ïê‚ïê
    if (this._playerClass === 'warrior' && this.player && this.player.active) {
      if (this.playerHP <= this.playerMaxHP * 0.5) {
        if (!this._warriorRageActive) {
          this._warriorRageActive = true;
          this.player.setTint(0xFF2222);
          this.showFloatingText(this.player.x, this.player.y - 40, 'üî• Î∂ÑÎÖ∏ Î™®Îìú!', '#FF2222');
        }
      } else {
        if (this._warriorRageActive) {
          this._warriorRageActive = false;
          this.player.clearTint();
        }
      }
    }
    // ‚ïê‚ïê‚ïê Class Cooldowns ‚ïê‚ïê‚ïê
    // Class CD zero event: instantly reset all class cooldowns
    if (this.activeRandomEvents && this.activeRandomEvents.class_cd_zero) {
      this._classRoarCD = 0; this._classBlizzardCD = 0; this._classSprintCD = 0;
      this._classSpiritCD = 0; this._classShamanStormCD = 0; this._classHunterVolleyCD = 0;
    } else {
      if (this._classRoarCD > 0) this._classRoarCD -= dt;
      if (this._classBlizzardCD > 0) this._classBlizzardCD -= dt;
      if (this._classSprintCD > 0) this._classSprintCD -= dt;
      if (this._classSpiritCD > 0) this._classSpiritCD -= dt;
      if (this._classShamanStormCD > 0) this._classShamanStormCD -= dt;
      if (this._classHunterVolleyCD > 0) this._classHunterVolleyCD -= dt;
    }
    if (this._classSprintActive && this._classSprintTimer !== undefined) {
      this._classSprintTimer -= dt;
      if (this._classSprintTimer <= 0) {
        this._classSprintActive = false;
        this.playerBaseSpeed /= 3;
        this.playerSpeed = this.playerBaseSpeed;
        if (!this._warriorRageActive && this.player && this.player.active) this.player.clearTint();
      }
    }
    // ‚ïê‚ïê‚ïê Class Ability: Warrior Roar (auto on cooldown) ‚ïê‚ïê‚ïê
    if (this.upgradeManager._classWarriorRoar && this._classRoarCD <= 0 && this.player && this.player.active) {
      const nearEnemies = this.animals.getChildren().filter(a => a.active && Phaser.Math.Distance.Between(this.player.x, this.player.y, a.x, a.y) < 100);
      if (nearEnemies.length > 0) {
        this._classRoarCD = 15; // 15s cooldown
        playClassSkill();
        this.showFloatingText(this.player.x, this.player.y - 40, 'ü™ì Ìè¨Ìö®!', '#FF4444');
        const roarFx = this.add.circle(this.player.x, this.player.y, 10, 0xFF4444, 0.4).setDepth(15);
        this.tweens.add({ targets: roarFx, scale: 10, alpha: 0, duration: 500, onComplete: () => roarFx.destroy() });
        nearEnemies.forEach(a => {
          a.body.setVelocity(0, 0); a.body.moves = false; a.setTint(0x888888);
          this.time.delayedCall(2000, () => { if (a.active) { a.body.moves = true; a.clearTint(); } });
        });
      }
    }
    // ‚ïê‚ïê‚ïê Class Ability: Mage Blizzard (auto on cooldown) ‚ïê‚ïê‚ïê
    if (this.upgradeManager._classMageBlizzard && this._classBlizzardCD <= 0) {
      const anyEnemy = this.animals.getChildren().some(a => a.active);
      if (anyEnemy) {
        this._classBlizzardCD = 30;
        playClassSkill();
        this.showFloatingText(this.player.x, this.player.y - 40, 'üßä ÏñºÏùå Ìè≠Ìíç!', '#88CCFF');
        this.cameras.main.flash(300, 100, 180, 255);
        this.animals.getChildren().forEach(a => {
          if (!a.active) return;
          a.body.setVelocity(0, 0); a.body.moves = false; a.setTint(0x88CCFF);
          this.time.delayedCall(1000, () => { if (a.active) { a.body.moves = true; a.clearTint(); } });
        });
      }
    }
    // ‚ïê‚ïê‚ïê Class Ability: Survivor Sprint (auto on cooldown when enemies near) ‚ïê‚ïê‚ïê
    if (this.upgradeManager._classSurvivorSprint && this._classSprintCD <= 0 && !this._classSprintActive && this.player && this.player.active) {
      const dangerClose = this.animals.getChildren().some(a => a.active && a.def && a.def.hostile && Phaser.Math.Distance.Between(this.player.x, this.player.y, a.x, a.y) < 80);
      if (dangerClose) {
        this._classSprintCD = 20;
        this._classSprintActive = true;
        this._classSprintTimer = 3;
        this.playerBaseSpeed *= 3;
        this.playerSpeed = this.playerBaseSpeed;
        this.player.setTint(0x44FF44);
        playClassSkill();
        this.showFloatingText(this.player.x, this.player.y - 40, 'üèÉ ÏßàÏ£º!', '#44FF44');
      }
    }

    // ‚ïê‚ïê‚ïê Shaman: Spirit Orb Collection ‚ïê‚ïê‚ïê
    if (this._playerClass === 'shaman' && this._spiritOrbs.length > 0) {
      for (let i = this._spiritOrbs.length - 1; i >= 0; i--) {
        const orb = this._spiritOrbs[i];
        orb.lifetime -= dt;
        if (orb.lifetime <= 0) {
          orb.orb.destroy(); orb.glow.destroy();
          this._spiritOrbs.splice(i, 1);
          continue;
        }
        const dist = Phaser.Math.Distance.Between(this.player.x, this.player.y, orb.x, orb.y);
        if (dist < 30) {
          this.playerHP = Math.min(this.playerMaxHP, this.playerHP + 5);
          this.showFloatingText(this.player.x, this.player.y - 30, 'üîÆ+5 HP', '#4488FF');
          orb.orb.destroy(); orb.glow.destroy();
          this._spiritOrbs.splice(i, 1);
        }
      }
    }

    // ‚ïê‚ïê‚ïê Shaman: Nature's Blessing (campfire proximity buff) ‚ïê‚ïê‚ïê
    if (this._playerClass === 'shaman') {
      this._natureBlessing = false;
      if (this.placedBuildings) {
        for (const b of this.placedBuildings) {
          if (b.type === 'campfire') {
            const pd = Phaser.Math.Distance.Between(this.player.x, this.player.y, b.x, b.y);
            if (pd < 150) { this._natureBlessing = true; break; }
          }
        }
      }
    }

    // ‚ïê‚ïê‚ïê Shaman: Summon Spirit (auto 30s cooldown) ‚ïê‚ïê‚ïê
    if (this.upgradeManager._classShamanSpirit && this._classSpiritCD <= 0 && !this._shamanSpirit && this.player && this.player.active) {
      const anyEnemy = this.animals.getChildren().some(a => a.active);
      if (anyEnemy) {
        this._classSpiritCD = 30;
        this._shamanSpiritTimer = 10;
        playClassSkill();
        this.showFloatingText(this.player.x, this.player.y - 40, 'üîÆ Ï†ïÎ†π ÏÜåÌôò!', '#9B59B6');
        const spirit = this.add.circle(this.player.x, this.player.y, 20, 0x4488FF, 0.4).setDepth(15);
        const spiritGlow = this.add.circle(this.player.x, this.player.y, 30, 0x4488FF, 0.15).setDepth(14);
        this.tweens.add({ targets: spiritGlow, scale: { from: 0.8, to: 1.3 }, alpha: { from: 0.2, to: 0.05 }, yoyo: true, repeat: -1, duration: 700 });
        this._shamanSpirit = { sprite: spirit, glow: spiritGlow, dmgTimer: 0 };
      }
    }
    // Update active spirit
    if (this._shamanSpirit) {
      this._shamanSpiritTimer -= dt;
      if (this._shamanSpiritTimer <= 0) {
        this._shamanSpirit.sprite.destroy(); this._shamanSpirit.glow.destroy();
        this._shamanSpirit = null;
      } else {
        // Follow player with slight offset
        const s = this._shamanSpirit;
        const tx = this.player.x + Math.cos(this.time.now / 500) * 35;
        const ty = this.player.y + Math.sin(this.time.now / 500) * 35;
        s.sprite.x += (tx - s.sprite.x) * 0.1; s.sprite.y += (ty - s.sprite.y) * 0.1;
        s.glow.x = s.sprite.x; s.glow.y = s.sprite.y;
        // DPS to nearby enemies
        s.dmgTimer -= dt;
        if (s.dmgTimer <= 0) {
          s.dmgTimer = 1; // every 1 second
          const spiritDmg = this._natureBlessing ? Math.round(15 * 1.15) : 15;
          const _spiritKills = [];
          this.animals.getChildren().forEach(a => {
            if (!a.active || a.hp <= 0) return;
            if (Phaser.Math.Distance.Between(s.sprite.x, s.sprite.y, a.x, a.y) < 100) {
              a.hp -= spiritDmg;
              this.showFloatingText(a.x, a.y - 15, '-' + spiritDmg, '#4488FF');
              if (a.hp <= 0) _spiritKills.push(a);
            }
          });
          _spiritKills.forEach(a => { if (a.active) this.killAnimal(a); });
        }
        // Auto-collect XP drops nearby
        if (this.drops) {
          this.drops.forEach(d => {
            if (d && d.sprite && d.sprite.active && Phaser.Math.Distance.Between(s.sprite.x, s.sprite.y, d.sprite.x, d.sprite.y) < 100) {
              // Move drop toward player
              d.sprite.x += (this.player.x - d.sprite.x) * 0.3;
              d.sprite.y += (this.player.y - d.sprite.y) * 0.3;
            }
          });
        }
      }
    }

    // ‚ïê‚ïê‚ïê Shaman: Spirit Storm (screen-wide roaming spirit) ‚ïê‚ïê‚ïê
    if (this.upgradeManager._classShamanStorm && this._classShamanStormCD <= 0 && this.player && this.player.active) {
      const anyEnemy = this.animals.getChildren().some(a => a.active);
      if (anyEnemy) {
        this._classShamanStormCD = 45;
        playClassSkill();
        this.showFloatingText(this.player.x, this.player.y - 50, 'üåÄ Ï†ïÎ†πÏùò Ìè≠Ìíç!', '#9B59B6');
        const storm = this.add.circle(this.player.x, this.player.y, 25, 0x9B59B6, 0.5).setDepth(16);
        const stormGlow = this.add.circle(this.player.x, this.player.y, 40, 0x9B59B6, 0.2).setDepth(15);
        let stormTimer = 30;
        let stormDmgTimer = 0;
        let stormAngle = 0;
        const stormUpdate = this.time.addEvent({ delay: 50, loop: true, callback: () => {
          stormTimer -= 0.05;
          if (stormTimer <= 0) {
            storm.destroy(); stormGlow.destroy(); stormUpdate.remove();
            return;
          }
          // Roam around map
          stormAngle += 0.05;
          const cx = this.player.x + Math.cos(stormAngle) * 200 + Math.sin(stormAngle * 0.7) * 100;
          const cy = this.player.y + Math.sin(stormAngle) * 200 + Math.cos(stormAngle * 0.7) * 100;
          storm.x += (cx - storm.x) * 0.08; storm.y += (cy - storm.y) * 0.08;
          stormGlow.x = storm.x; stormGlow.y = storm.y;
          stormDmgTimer -= 0.05;
          if (stormDmgTimer <= 0) {
            stormDmgTimer = 1;
            const _stormKills = [];
            this.animals.getChildren().forEach(a => {
              if (!a.active || a.hp <= 0) return;
              if (Phaser.Math.Distance.Between(storm.x, storm.y, a.x, a.y) < 120) {
                a.hp -= 50;
                this.showFloatingText(a.x, a.y - 15, '-50üåÄ', '#9B59B6');
                if (a.hp <= 0) _stormKills.push(a);
              }
            });
            _stormKills.forEach(a => { if (a.active) this.killAnimal(a); });
          }
        }});
      }
    }

    // ‚ïê‚ïê‚ïê Hunter: Trap Placement (every 15s) ‚ïê‚ïê‚ïê
    if (this._playerClass === 'hunter' && this.player && this.player.active) {
      this._hunterTrapTimer = (this._hunterTrapTimer || 0) + dt;
      if (this._hunterTrapTimer >= 15) {
        this._hunterTrapTimer = 0;
        const tx = this.player.x, ty = this.player.y;
        const trapGfx = this.add.circle(tx, ty, 60, 0xFF8800, 0.15).setDepth(3);
        const trapBorder = this.add.circle(tx, ty, 60).setDepth(3);
        trapBorder.setStrokeStyle(1, 0xFF8800, 0.3);
        this._hunterTraps.push({ x: tx, y: ty, gfx: trapGfx, border: trapBorder });
        if (this._hunterTraps.length > 3) {
          const old = this._hunterTraps.shift();
          old.gfx.destroy(); old.border.destroy();
        }
      }
      // Check trap collisions with enemies
      for (const trap of this._hunterTraps) {
        this.animals.getChildren().forEach(a => {
          if (!a.active || a._trapFrozen) return;
          if (Phaser.Math.Distance.Between(trap.x, trap.y, a.x, a.y) < 60) {
            a._trapFrozen = true;
            a.hp -= 50;
            this.showFloatingText(a.x, a.y - 20, 'ü™§ Ìï®Ï†ï! -50', '#FF8800');
            if (a.body) { a.body.setVelocity(0, 0); a.body.moves = false; a.setTint(0x88CCFF); }
            this.time.delayedCall(3000, () => { if (a.active) { a.body.moves = true; a.clearTint(); a._trapFrozen = false; } });
            if (a.hp <= 0) this.killAnimal(a);
          }
        });
      }
    }

    // ‚ïê‚ïê‚ïê Hunter: Poison DoT tick ‚ïê‚ïê‚ïê
    if (this._playerClass === 'hunter') {
      this.animals.getChildren().forEach(a => {
        if (!a.active || !a._poisonStacks || a._poisonStacks.length === 0) return;
        for (let i = a._poisonStacks.length - 1; i >= 0; i--) {
          a._poisonStacks[i].remaining -= dt;
          if (a._poisonStacks[i].remaining <= 0) { a._poisonStacks.splice(i, 1); continue; }
          a._poisonStacks[i]._tick = (a._poisonStacks[i]._tick || 0) + dt;
          if (a._poisonStacks[i]._tick >= 1) {
            a._poisonStacks[i]._tick -= 1;
            a.hp -= 10;
            this.showFloatingText(a.x, a.y - 15, '‚ò†Ô∏è-10', '#44FF00');
            if (a.hp <= 0) { this.killAnimal(a); break; }
          }
        }
      });
    }

    // ‚ïê‚ïê‚ïê Hunter: Focused Fire Volley (auto 25s cooldown) ‚ïê‚ïê‚ïê
    if (this.upgradeManager._classHunterVolley && this._classHunterVolleyCD <= 0 && this.player && this.player.active) {
      const enemies = this.animals.getChildren().filter(a => a.active);
      if (enemies.length > 0) {
        this._classHunterVolleyCD = 25;
        playClassSkill();
        this.showFloatingText(this.player.x, this.player.y - 50, 'üèπ ÏßëÏ§ë ÏÇ¨Í≤©!', '#FF8800');
        // Sort by distance, pick 5 closest
        enemies.sort((a, b) => Phaser.Math.Distance.Between(this.player.x, this.player.y, a.x, a.y) - Phaser.Math.Distance.Between(this.player.x, this.player.y, b.x, b.y));
        const targets = enemies.slice(0, 5);
        let volleyIdx = 0;
        const volleyTimer = this.time.addEvent({ delay: 100, repeat: 29, callback: () => {
          const target = targets[volleyIdx % targets.length];
          if (target && target.active) {
            const baseDmg = 60 + (this.upgradeManager.getLevel('DAMAGE_UP') || 0) * 5;
            // Draw arrow line
            const line = this.add.graphics().setDepth(15);
            line.lineStyle(2, 0xFF8800, 0.8);
            line.lineBetween(this.player.x, this.player.y, target.x, target.y);
            this.time.delayedCall(100, () => line.destroy());
            this.damageAnimal(target, baseDmg);
          }
          volleyIdx++;
        }});
      }
    }

    // ‚ïê‚ïê‚ïê Kill Combo Timer ‚ïê‚ïê‚ïê
    if (this.killComboTimer > 0) {
      this.killComboTimer -= dt;
      if (this.killComboTimer <= 0) {
        this.killCombo = 0;
        this.killComboTimer = 0;
        this.streakBuff = { dmgMul: 1, spdMul: 1, timer: 0, tier: 0 }; // reset buff on combo break
        this._updateComboDisplay();
      }
    }
    
    // ‚ïê‚ïê‚ïê Streak Buff Timer ‚ïê‚ïê‚ïê
    this._updateStreakBuff(dt);
    this._updateKillAura(dt);

    // ‚ïê‚ïê‚ïê Tutorial Hints ‚ïê‚ïê‚ïê
    if (!this.tutorialShown && this.gameElapsed > 0) {
      this._updateTutorial();
    }

    // ‚ïê‚ïê‚ïê FTUE Context Hints ‚ïê‚ïê‚ïê
    this._updateFTUEHints();

    // Mobile auto-attack
    if (this.attackCooldown <= 0) {
      let nearest = null, nearestDist = Infinity;
      this.animals.getChildren().forEach(a => {
        if (!a.active) return;
        const d = Phaser.Math.Distance.Between(this.player.x, this.player.y, a.x, a.y);
        if (d < 60 && d < nearestDist) { nearest = a; nearestDist = d; }
      });
      if (nearest) {
        this.attackCooldown = this.getAttackCooldown();
        this.player.setTexture('player_attack');
        this.time.delayedCall(150, () => { if(this.player.active) this.player.setTexture('player'); });
        this.damageAnimal(nearest, Math.round(this.playerDamage * (this.streakBuff?.dmgMul || 1))); playSlash();
        this.showAttackFX(nearest.x, nearest.y, true);
        this.cameras.main.shake(50, 0.003);
        this.upgradeManager.attackCounter++; // Increment attack counter for successful hit
      } else {
        let nearestNode = null, nearestND = Infinity;
        this.resourceNodes.forEach(n => {
          if (n.depleted) return;
          const d = Phaser.Math.Distance.Between(this.player.x, this.player.y, n.x, n.y);
          if (d < 60 && d < nearestND) { nearestNode = n; nearestND = d; }
        });
        if (nearestNode) {
          this.attackCooldown = this.getAttackCooldown();
          this.player.setTexture('player_attack');
          this.time.delayedCall(150, () => { if(this.player.active) this.player.setTexture('player'); });
          this.harvestNode(nearestNode);
          this.showAttackFX(nearestNode.x, nearestNode.y, true);
          this.upgradeManager.attackCounter++; // Increment attack counter for successful hit
        }
      }
    }

    // Player movement with smooth lerp
    if (this._smoothMove) {
      // Smooth lerp for virtual joystick
      const lerpSpeed = 8 * dt; // smooth interpolation
      this.moveDir.x += (this._smoothMove.x - this.moveDir.x) * Math.min(1, lerpSpeed);
      this.moveDir.y += (this._smoothMove.y - this.moveDir.y) * Math.min(1, lerpSpeed);
      // Dead zone cleanup
      if (Math.abs(this.moveDir.x) < 0.01) this.moveDir.x = 0;
      if (Math.abs(this.moveDir.y) < 0.01) this.moveDir.y = 0;
    } else {
      this.moveDir.x = 0;
      this.moveDir.y = 0;
    }
    // ‚ïê‚ïê‚ïê WASD + Arrow Key merge ‚ïê‚ïê‚ïê
    const wasd = this.wasd;
    const kx = (wasd.D.isDown||wasd.RIGHT.isDown ? 1 : 0) - (wasd.A.isDown||wasd.LEFT.isDown ? 1 : 0);
    const ky = (wasd.S.isDown||wasd.DOWN.isDown ? 1 : 0) - (wasd.W.isDown||wasd.UP.isDown ? 1 : 0);
    let finalMX = this.moveDir.x, finalMY = this.moveDir.y;
    if (kx !== 0 || ky !== 0) {
      finalMX = kx; finalMY = ky;
      // If joystick also active, sum them
      if (this.moveDir.x !== 0 || this.moveDir.y !== 0) {
        finalMX = this.moveDir.x + kx;
        finalMY = this.moveDir.y + ky;
      }
      // Normalize
      const mag = Math.sqrt(finalMX*finalMX + finalMY*finalMY);
      if (mag > 1) { finalMX /= mag; finalMY /= mag; }
    }
    const eqSpdMul = 1 + (this._equipBonuses ? this._equipBonuses.spdMul : 0);
    const hiddenBossSlowMul = this._hiddenBossSlowActive ? 0.6 : 1;
    const natureBlessingMul = this._natureBlessing ? 1.15 : 1;
    const effectiveSpeed = this.playerSpeed * (this.streakBuff?.spdMul || 1) * eqSpdMul * hiddenBossSlowMul * natureBlessingMul;
    this.player.body.setVelocity(finalMX*effectiveSpeed, finalMY*effectiveSpeed);
    // 4Î∞©Ìñ• Ïä§ÌîÑÎùºÏù¥Ìä∏ Ï†ÑÌôò (ÏÉÅÌïòÏ¢åÏö∞) + Îí∑Î™®Ïäµ
    const absX = Math.abs(finalMX);
    const absY = Math.abs(finalMY);
    if (absX > absY) {
      // Ï¢åÏö∞ Ïù¥Îèô ‚Üí ÏïûÎ™®Ïäµ
      if (finalMX > 0.1) { 
        this.player.setFlipX(false); 
        this.facingRight = true; 
        this.playerFacing = 'right';
        if (this.attackCooldown <= 0) this.player.setTexture('player');
      } else if (finalMX < -0.1) { 
        this.player.setFlipX(true); 
        this.facingRight = false; 
        this.playerFacing = 'left';
        if (this.attackCooldown <= 0) this.player.setTexture('player');
      }
    } else if (absY > 0.1) {
      // ÏÉÅÌïò Ïù¥Îèô
      if (finalMY < -0.1) {
        this.playerFacing = 'up';
        this.player.setFlipX(false);
        if (this.attackCooldown <= 0) this.player.setTexture('player_back');
      } else if (finalMY > 0.1) {
        this.playerFacing = 'down';
        if (this.attackCooldown <= 0) this.player.setTexture('player');
      }
    }

    // Upgrade: passive regen
    if (this.upgradeManager.regenPerSec > 0) {
      const healMul = (this.activeRandomEvents && this.activeRandomEvents.heal_boost) ? 5 : 1;
      this.playerHP = Math.min(this.playerMaxHP, this.playerHP + this.upgradeManager.regenPerSec * healMul * dt);
    }
    // Upgrade: sparkle on supply crates
    this.supplyCrates.forEach(c => {
      if (!c.active) return;
      c._sparkleTimer = (c._sparkleTimer || 0) + dt;
      if (c._sparkleTimer > 0.5) {
        c._sparkleTimer = 0;
        const sp = this.add.image(c.x + Phaser.Math.Between(-14, 14), c.y + Phaser.Math.Between(-12, 12), 'sparkle').setDepth(9).setScale(0.8);
        this.tweens.add({ targets: sp, alpha: 0, y: sp.y - 15, scale: 0, duration: 500, onComplete: () => sp.destroy() });
      }
      if (c._label && c._label.active) c._label.setPosition(c.x, c.y - 24);
    });

    this._updateBuffs(dt);
    this._updateEquipmentDrops(dt);
    this.updateAnimalAI(dt);
    this._updateIceBolts(dt);
    if (this.synergyManager) this.synergyManager.updateColdImmunity(dt, this);
    this.updateNPCs(dt);
    this.updateCampfireSystem(dt);
    this.updateSurvival(dt);

    this.resourceNodes.forEach(n => {
      if (!n.depleted) return;
      n.regenTimer -= dt;
      if (n.regenTimer <= 0) { n.depleted = false; n.nodeHP = n.nodeMaxHP; n.setAlpha(1); }
    });

    // ‚ïê‚ïê‚ïê Phase 2: Game Timer & Act ‚ïê‚ïê‚ïê
    this.gameElapsed += dt;
    // ‚ïê‚ïê‚ïê Wave Transition Warnings ‚ïê‚ïê‚ïê
    const _waveMin = this.gameElapsed / 60;
    if (!this._waveWarnings) this._waveWarnings = {};
    const waveAlerts = [
      { min: 4.5, key: 'w5', msg: '‚ö†Ô∏è 30Ï¥à ÌõÑ ÏÇ¨Ïä¥/Î¨ºÍ∞ú Îì±Ïû•!', color: '#88CCFF' },
      { min: 9.5, key: 'w10', msg: '‚ö†Ô∏è 30Ï¥à ÌõÑ ÎäëÎåÄ Îì±Ïû•!', color: '#FF8844' },
      { min: 14.5, key: 'w15', msg: '‚ö†Ô∏è 30Ï¥à ÌõÑ Í≥∞ Îì±Ïû•!', color: '#FF4444' },
      { min: 19.5, key: 'w20', msg: '‚ö†Ô∏è 30Ï¥à ÌõÑ Î≥¥Ïä§ Î†àÏù¥Îìú!', color: '#FF2222' },
    ];
    for (const wa of waveAlerts) {
      if (!this._waveWarnings[wa.key] && _waveMin >= wa.min) {
        this._waveWarnings[wa.key] = true;
        this.showCenterAlert(wa.msg, wa.color);
        this.cameras.main.shake(200, 0.005);
      }
    }

    const newAct = this.getCurrentAct();
    if (newAct !== this.currentAct) {
      this.currentAct = newAct;
      this.showCenterAlert(`üé¨ Act ${this.currentAct} ÏãúÏûë!`, '#FFD700');
      this.cameras.main.flash(500, 255, 255, 200);
      // Act story text
      const storyKeys = { 2: 'act2', 3: 'act3', 4: 'act4', 5: 'act5' };
      if (storyKeys[newAct]) this.showActStoryText(ACT_STORY[storyKeys[newAct]]);
    }

    // ‚ïê‚ïê‚ïê Boss Rush Mode Update ‚ïê‚ïê‚ïê
    if (this._bossRushMode) {
      this._updateBossRush(dt);
    }

    // ‚ïê‚ïê‚ïê Wave Spawn (dynamic interval) ‚ïê‚ïê‚ïê
    if (this._bossRushMode && !this._bossRushPrepPhase) { /* skip normal spawns in boss rush */ }
    else if (this._bossRushMode && this._bossRushPrepPhase) {
      // During prep phase, spawn a few weak enemies for XP
      this.waveTimer += dt;
      if (this.waveTimer >= 3) {
        this.waveTimer = 0;
        const currentCount = this.animals.getChildren().filter(a => !a.isBoss).length;
        if (currentCount < 5) {
          for (let i = 0; i < 3; i++) this.spawnAnimal('rabbit');
        }
      }
    }
    if (this._bossRushMode) { /* skip normal wave spawn below */ } else {
    this.waveTimer += dt;
    const spawnConfig = this.getSpawnConfig();
    const rushMul = (this.activeRandomEvents && this.activeRandomEvents.spawn_rush) ? 3 : 1;
    const challengeMul = this._challengeActive ? (this._challengeSpawnMul || 1) : 1;
    const diffSpawnMul = this._diffMode ? this._diffMode.spawnRate : 1;
    const endlessSpawnMul = this._endlessMultiplier || 1;
    const spawnIntervalSec = (spawnConfig.spawnInterval / 1000) / rushMul / challengeMul / diffSpawnMul / endlessSpawnMul;
    // ‚ïê‚ïê‚ïê Wave Warning Banner (5Ï¥à Ï†Ñ) ‚ïê‚ïê‚ïê
    const timeToWave = spawnIntervalSec - this.waveTimer;
    if (timeToWave <= 5 && timeToWave > 0 && !this._waveWarningActive && this.waveNumber >= 3) {
      this._waveWarningActive = true;
      this._showWaveWarning(spawnConfig);
    }
    if (this.waveTimer >= spawnIntervalSec) {
      this.waveTimer = 0;
      this._waveWarningActive = false;
      this.waveNumber++;
      const currentCount = this.animals.getChildren().length;
      const toSpawn = Math.max(0, Math.min(spawnConfig.maxCount - currentCount, 15));
      if (toSpawn > 0) {
        for (let i = 0; i < toSpawn; i++) {
          this.spawnAnimal(this.pickAnimalType(spawnConfig.weights));
        }
      }
    }
    } // end boss rush else block

    // ‚ïê‚ïê‚ïê Blizzard Visuals ‚ïê‚ïê‚ïê
    this.updateBlizzardVisuals(dt);

    // ‚ïê‚ïê‚ïê Snowball/Avalanche ‚ïê‚ïê‚ïê
    this.updateSnowballs(dt);

    // ‚ïê‚ïê‚ïê Act Miniboss Spawns ‚ïê‚ïê‚ïê
    if (!this._bossRushMode) {
    const _srT = this._speedrunMode ? 0.5 : 1; // speedrun: half timings
    if (!this.act2MinibossSpawned && this.gameElapsed >= 12 * 60 * _srT) {
      this.act2MinibossSpawned = true;
      this.spawnActMiniboss('alpha_wolf');
    }
    if (!this.act4MinibossSpawned && this.gameElapsed >= 40 * 60 * _srT) {
      this.act4MinibossSpawned = true;
      this.spawnActMiniboss('blizzard_bear');
    }

    // ‚ïê‚ïê‚ïê Phase 2: Boss Spawns ‚ïê‚ïê‚ïê
    const boss1Time = 20 * 60 * _srT; // 20Î∂Ñ (Î†àÎ≤®ÎîîÏûêÏù∏ Ï°∞Ï†ï)
    const boss2Time = 45 * 60 * _srT;
    if (!this.boss1Spawned && !this._boss1Warned && this.gameElapsed >= boss1Time - 10) {
      this._boss1Warned = true;
      playBossSpawn();
      this.showCenterAlert('‚ö†Ô∏è 10Ï¥à ÌõÑ Î≥¥Ïä§ Îì±Ïû•!', '#FF2222');
    }
    if (!this.boss1Spawned && this.gameElapsed >= boss1Time) {
      this.boss1Spawned = true;
      this.spawnBoss('first');
    }
    if (!this.boss2Spawned && this.gameElapsed >= boss2Time) {
      this.boss2Spawned = true;
      this.spawnBoss('final');
    }
    } // end !bossRushMode guard for act/boss spawns

    // ‚ïê‚ïê‚ïê Act 3: Timed Ice Golem / Snow Leopard Spawns ‚ïê‚ïê‚ïê
    const minNow = this.gameElapsed / 60;
    if (!this._bossRushMode && minNow >= 40) {
      this._iceGolemSpawnTimer += dt;
      if (this._iceGolemSpawnTimer >= 45) {
        this._iceGolemSpawnTimer = 0;
        this.spawnAnimal('ice_golem');
      }
    }
    if (!this._bossRushMode && minNow >= 45) {
      this._snowLeopardSpawnTimer += dt;
      if (this._snowLeopardSpawnTimer >= 30) {
        this._snowLeopardSpawnTimer = 0;
        this.spawnAnimal('snow_leopard');
        this.spawnAnimal('snow_leopard');
      }
    }

    // ‚ïê‚ïê‚ïê Elite Wave (15min intervals) ‚ïê‚ïê‚ïê
    if (!this._bossRushMode)
    [15, 30, 45].forEach(m => {
      if (!this._eliteWaveTriggered[m] && minNow >= m && minNow < m + 0.5 && !this._challengeActive) {
        this._eliteWaveTriggered[m] = true;
        this._eventCooldown = true;
        this.time.delayedCall(15000, () => { this._eventCooldown = false; });
        this.showCenterAlert('‚ö†Ô∏è ÏóòÎ¶¨Ìä∏ Î∂ÄÎåÄ Ï∂úÌòÑ!', '#FF8800');
        this.cameras.main.shake(400, 0.01);
        for (let i = 0; i < 5; i++) {
          const angle = Math.random() * Math.PI * 2;
          const dist = 200 + Math.random() * 150;
          const ex = Phaser.Math.Clamp(this.player.x + Math.cos(angle) * dist, 80, WORLD_W - 80);
          const ey = Phaser.Math.Clamp(this.player.y + Math.sin(angle) * dist, 80, WORLD_H - 80);
          const types = Object.keys(this.getSpawnConfig().weights);
          const etype = types[Math.floor(Math.random() * types.length)];
          const edef = ANIMALS[etype];
          if (!edef) return;
          const ea = this.physics.add.sprite(ex, ey, etype).setCollideWorldBounds(true).setDepth(5);
          ea.animalType = etype;
          ea.def = { ...edef, hp: Math.round(edef.hp * 1.5), speed: Math.round(edef.speed * 1.5) };
          ea.hp = ea.def.hp; ea.maxHP = ea.def.hp;
          ea.wanderTimer = 0; ea.wanderDir = {x:0,y:0}; ea.hitFlash = 0; ea.atkCD = 0; ea.fleeTimer = 0;
          ea.setTint(0xFFAA44); // orange tint for elite
          ea._isElite = true;
          if (ea.def.hp > 2) ea.hpBar = this.add.graphics().setDepth(6);
          ea.nameLabel = this.add.text(ex, ey - edef.size - 10, '‚≠ê' + edef.name, {
            fontSize: '11px', fontFamily: 'monospace', color: '#FFAA44', stroke: '#000', strokeThickness: 3
          }).setDepth(6).setOrigin(0.5);
          this.animals.add(ea);
        }
      }
    });

    // ‚ïê‚ïê‚ïê Siege Wave (25min, 50min) ‚ïê‚ïê‚ïê
    if (!this._bossRushMode)
    [25, 50].forEach(m => {
      if (!this._siegeWaveTriggered[m] && minNow >= m && minNow < m + 0.5) {
        this._siegeWaveTriggered[m] = true;
        this._siegeWaveActive = true;
        this._siegeWaveEndTime = this.gameElapsed + 60;
        this.showCenterAlert('üî¥ Ìè¨ÏúÑ Í≥µÍ≤©!', '#FF2222');
        this.cameras.main.shake(500, 0.015);
        // Spawn 2 from each direction (8 total)
        const dirs = [{x:-1,y:0},{x:1,y:0},{x:0,y:-1},{x:0,y:1}];
        dirs.forEach(d => {
          for (let i = 0; i < 2; i++) {
            const sx = d.x === 0 ? this.player.x + Phaser.Math.Between(-100,100) : (d.x < 0 ? 80 : WORLD_W - 80);
            const sy = d.y === 0 ? this.player.y + Phaser.Math.Between(-100,100) : (d.y < 0 ? 80 : WORLD_H - 80);
            const types = ['wolf', 'bear'];
            const st = types[Math.floor(Math.random() * types.length)];
            this.spawnAnimal(st);
          }
        });
      }
    });
    if (this._siegeWaveActive && this.gameElapsed >= this._siegeWaveEndTime) {
      this._siegeWaveActive = false;
    }

    // ‚ïê‚ïê‚ïê Survival Challenge (every 10min, 2min duration) ‚ïê‚ïê‚ïê
    if (this._bossRushMode) { /* skip challenges in boss rush */ } else {
    const challengeMin = Math.floor(minNow / 10) * 10;
    if (challengeMin >= 10 && challengeMin !== this._lastChallengeMin && minNow >= challengeMin && minNow < challengeMin + 2) {
      if (!this._challengeActive) {
        this._challengeActive = true;
        this._lastChallengeMin = challengeMin;
        this._challengeEndTime = challengeMin * 60 + 120; // 2 minutes
        this._challengeSpawnMul = 2;
        this._challengeHpMul = 1.3;
        this.showCenterAlert('üèÜ ÏÉùÏ°¥ Ï±åÎ¶∞ÏßÄ ÏãúÏûë! 2Î∂ÑÍ∞Ñ Î≤ÑÌÖ®Îùº!', '#FFD700');
      }
    }
    if (this._challengeActive) {
      const remaining = this._challengeEndTime - this.gameElapsed;
      if (remaining <= 0) {
        this._challengeActive = false;
        this._challengeSpawnMul = 1;
        this._challengeHpMul = 1;
        this.showCenterAlert('‚úÖ Ï±åÎ¶∞ÏßÄ ÌÅ¥Î¶¨Ïñ¥! ÏóÖÍ∑∏Î†àÏù¥Îìú Î≥¥ÎÑàÏä§', '#44FF44');
        this.levelUpQueue = (this.levelUpQueue || 0) + 1;
        this.pendingLevelUps = (this.pendingLevelUps || 0) + 1;
        if (this._challengeHUD) { this._challengeHUD.destroy(); this._challengeHUD = null; }
      } else {
        const rMin = Math.floor(remaining / 60);
        const rSec = Math.floor(remaining % 60);
        const txt = `ÏÉùÏ°¥ Ï±åÎ¶∞ÏßÄ: ${rMin}:${String(rSec).padStart(2, '0')} ÎÇ®Ïùå`;
        if (!this._challengeHUD) {
          this._challengeHUD = this.add.text(this.cameras.main.centerX, 60, txt, {
            fontSize: '16px', fontFamily: 'monospace', color: '#FFD700', stroke: '#000', strokeThickness: 4, fontStyle: 'bold'
          }).setDepth(100).setOrigin(0.5).setScrollFactor(0);
        } else {
          this._challengeHUD.setText(txt);
        }
      }
    }
    } // end boss rush challenge skip

    // ‚ïê‚ïê‚ïê Milestone Banners ‚ïê‚ïê‚ïê
    if (!this._milestone5Shown && this.gameElapsed >= 5 * 60) {
      this._milestone5Shown = true;
      this._showMilestoneBanner('‚ùÑÔ∏è Ï≤´ Î≤àÏß∏ ÌïúÌååÎ•º Î≤ÑÌÖºÎã§...', '#FFFFFF');
    }
    if (!this._milestone10Shown && this.gameElapsed >= 10 * 60) {
      this._milestone10Shown = true;
      this._showMilestoneBanner('üî• Î∂àÏî®Î•º ÏßÄÏº∞Îã§', '#FF8800');
    }
    if (!this._milestone20Shown && this.gameElapsed >= 20 * 60) {
      this._milestone20Shown = true;
      this._showMilestoneBanner('üê∫ ÏïºÏÉùÏù¥ ÎãπÏã†ÏùÑ ÎëêÎ†§ÏõåÌïúÎã§', '#FF2222');
      this.cameras.main.shake(300, 0.01);
    }
    if (!this._milestone30Shown && this.gameElapsed >= 30 * 60) {
      this._milestone30Shown = true;
      this.cameras.main.flash(800, 255, 215, 0, true);
      this._showMilestoneBanner('‚ö° Ï†ÑÏÑ§Ïù¥ ÏãúÏûëÎêúÎã§', '#FFD700', 3000);
      // Fullscreen golden flash
      const cam = this.cameras.main;
      const flashOverlay = this.add.rectangle(cam.width/2, cam.height/2, cam.width, cam.height, 0xFFD700, 0.4)
        .setScrollFactor(0).setDepth(300);
      this.tweens.add({ targets: flashOverlay, alpha: 0, duration: 1500, onComplete: () => flashOverlay.destroy() });
    }
    if (!this._milestone45Shown && this.gameElapsed >= 45 * 60) {
      this._milestone45Shown = true;
      this._showMilestoneBanner('‚ö° Í≥†ÏßÄÍ∞Ä ÎààÏïû!', '#FFD700');
    }

    // ‚ïê‚ïê‚ïê Speedrun Mode: Timer + Level 21 Victory ‚ïê‚ïê‚ïê
    if (this._speedrunMode && !this._speedrunCleared) {
      this._speedrunTimer -= dt;
      if (this._speedrunTimer <= 0) {
        this._speedrunTimer = 0;
        this.endGame(); // time's up = death
      }
      // Level 21 win condition
      if (this.playerLevel >= 21) {
        this._speedrunCleared = true;
        this._triggerSpeedrunVictory();
      }
      // Update HUD timer
      this._updateSpeedrunHUD();
    }

    // ‚ïê‚ïê‚ïê Handicap: Low Vision Fog of War ‚ïê‚ïê‚ïê
    if (this._handicap === 'low_vision') {
      this._fogFrameCount = (this._fogFrameCount || 0) + 1;
      if (this._fogFrameCount % 10 === 0) {
        if (!this._fogGraphics) {
          this._fogGraphics = this.add.graphics().setDepth(200).setScrollFactor(0);
        }
        const cam = this.cameras.main;
        const cW = cam.width, cH = cam.height;
        this._fogGraphics.clear();
        // Draw black rect with circle cutout using alpha mask approach
        this._fogGraphics.fillStyle(0x000000, 0.8);
        this._fogGraphics.fillRect(0, 0, cW, cH);
        // Clear circle around player (draw transparent circle by using blend)
        const px = (this.player ? this.player.x : WORLD_W/2) - cam.scrollX, py = (this.player ? this.player.y : WORLD_H/2) - cam.scrollY;
        this._fogGraphics.fillStyle(0x000000, 0);
        // Use erase approach: fill circle with 0 alpha won't work in Phaser graphics
        // Instead use a geometry mask
        if (!this._fogMask) {
          this._fogMaskShape = this.make.graphics();
          this._fogMask = this._fogMaskShape.createGeometryMask();
          this._fogMask.invertAlpha = true;
          this._fogGraphics.setMask(this._fogMask);
        }
        this._fogMaskShape.clear();
        this._fogMaskShape.fillStyle(0xffffff);
        this._fogMaskShape.fillCircle(px, py, 150);
      }
    }

    // ‚ïê‚ïê‚ïê Victory Condition: 60Î∂Ñ ÏÉùÏ°¥ ‚ïê‚ïê‚ïê
    if (!this._bossRushMode && !this.gameWon && this.gameElapsed >= 60 * 60) {
      this.gameWon = true;
      if (this._endlessMode) {
        // Endless mode: show banner and continue
        this._milestone60Shown = true;
        this.cameras.main.flash(500, 255, 215, 0, true); // golden flash
        this._showMilestoneBanner('üèÜ Ï†ÑÏÑ§Ïù¥ ÎêòÎã§!', '#FFD700', 3000);
        this.showActStoryText(ACT_STORY.win);
        this.time.delayedCall(3000, () => {
          this._showMilestoneBanner('üèÜ 60Î∂Ñ ÏÉùÏ°¥! Í≥ÑÏÜç ÏßÑÌñâ Ï§ë...', '#44FF44', 3000);
        });
        // Record the win but don't end
        const totalKills = Object.values(this.stats.kills || {}).reduce((a,b)=>a+b, 0);
        const diffBonus = this._diffMode ? this._diffMode.clearBonus : 10;
        RecordManager.recordRun(this.gameElapsed, totalKills, this.playerLevel, this.stats.maxCombo || 0, true, 0);
        if (this._dailyChallenge) {
          try { localStorage.setItem('daily_clear_' + getDailyChallengeKey(), 'true'); } catch(e) {}
        }
        playWinSound();
      } else {
        this.showActStoryText(ACT_STORY.win);
        this.time.delayedCall(3000, () => this.showVictory());
      }
    }

    // ‚ïê‚ïê‚ïê Endless Mode: Difficulty Escalation ‚ïê‚ïê‚ïê
    if (this._endlessMode && this.gameElapsed >= 60 * 60) {
      // Every 10 minutes after 60min, increase multiplier
      const minutesPast60 = (this.gameElapsed - 3600) / 60;
      const escalationSteps = Math.floor(minutesPast60 / 10);
      this._endlessMultiplier = Math.pow(1.1, escalationSteps);

      // Endless boss spawns at 70, 90, 110, 130, ... minutes
      const endlessBossTimes = [70, 90, 110, 130, 150, 170, 190, 210];
      const minNowE = this.gameElapsed / 60;
      endlessBossTimes.forEach((bossMin, idx) => {
        if (idx >= this._endlessBossCount && minNowE >= bossMin && minNowE < bossMin + 0.5) {
          this._endlessBossCount = idx + 1;
          this._spawnEndlessBoss(idx);
        }
      });

      // Spirit Bomb tick
      if (this.upgradeManager._spiritBombActive) {
        this.upgradeManager._spiritBombTimer = (this.upgradeManager._spiritBombTimer || 0) + dt;
        if (this.upgradeManager._spiritBombTimer >= 10) {
          this.upgradeManager._spiritBombTimer = 0;
          this.cameras.main.flash(200, 200, 100, 255, true);
          const _quakeKills = [];
          this.animals.getChildren().forEach(a => {
            if (!a.active || a.hp === undefined) return;
            a.hp -= 50;
            if (a.hp <= 0) _quakeKills.push(a);
          });
          _quakeKills.forEach(a => { if (a.active) this.killAnimal(a); });
        }
      }
    }

    // ‚ïê‚ïê‚ïê Phase 2: Rhythm System ‚ïê‚ïê‚ïê
    this.updateRhythm(dt);

    this.drops.getChildren().forEach(d => {
      if(!d.active) return;
      const dist = Phaser.Math.Distance.Between(this.player.x, this.player.y, d.x, d.y);
      if (dist < this.upgradeManager.magnetRange) {
        const a = Phaser.Math.Angle.Between(d.x, d.y, this.player.x, this.player.y);
        const speed = 220 * (1 - dist / this.upgradeManager.magnetRange);
        d.x += Math.cos(a) * speed * dt;
        d.y += Math.sin(a) * speed * dt;
        if (dist < 18) this.collectDrop(d);
      }
    });

    // ‚ïê‚ïê‚ïê Zone Alert System ‚ïê‚ïê‚ïê
    const newZone = this.getPlayerZone();
    if (newZone !== this.currentZone) {
      const oldZone = this.currentZone;
      this.currentZone = newZone;
      // ‚ïê‚ïê‚ïê Zone-specific background color ‚ïê‚ïê‚ïê
      const _zoneBgColors = { safe: '#0A0E1A', normal: '#0C1020', danger: '#10081A', extreme: '#1A0508' };
      this.cameras.main.setBackgroundColor(_zoneBgColors[newZone] || '#0A0E1A');
      const zoneAlerts = {
        normal: 'Ï£ºÏùò Íµ¨Ïó≠ ÏßÑÏûÖ',
        danger: '‚ö†Ô∏è ÏúÑÌóò Íµ¨Ïó≠ ÏßÑÏûÖ',
        extreme: '‚ò†Ô∏è Í∑πÏúÑÌóò Íµ¨Ïó≠ ‚Äî Ï¶âÏãú ÎåÄÌîº Í∂åÍ≥†',
      };
      if (zoneAlerts[newZone]) {
        this.showZoneAlert(zoneAlerts[newZone]);
      }
      // ‚ïê‚ïê‚ïê Zone Discovery Slide-up Banner (session 1Ìöå) ‚ïê‚ïê‚ïê
      if (!this._visitedZonesForBanner.has(newZone) && newZone !== 'safe') {
        this._visitedZonesForBanner.add(newZone);
        this._showZoneDiscoveryBanner(newZone);
      }
      // Region name banner + zone exploration milestone
      this.showRegionBanner(newZone);
      if (!this._visitedZones.has(newZone)) {
        this._visitedZones.add(newZone);
        this._questProgress.zones_visited = this._visitedZones.size;
        const rn = REGION_NAMES[newZone];
        if (rn) this._showMilestoneBanner('üó∫Ô∏è ' + rn.name + ' Î∞úÍ≤¨!', rn.color, 2000);
        if (this._visitedZones.size >= 4) {
          this.time.delayedCall(2200, () => {
            this._showMilestoneBanner('üèÜ ÌÉêÌóòÍ∞Ä! Î™®Îì† ÏßÄÏó≠ Î∞©Î¨∏ ‚Äî ÏóÖÍ∑∏Î†àÏù¥Îìú Ïπ¥Îìú +1', '#FFD700', 3000);
            this._pendingUpgrades = (this._pendingUpgrades || 0) + 1;
          });
        }
      }
    }

    // ‚ïê‚ïê‚ïê Region Name HUD (Ï¢åÏ∏° ÌïòÎã®) ‚ïê‚ïê‚ïê
    if (!this._regionHudText) {
      this._regionHudText = this.add.text(10, this.cameras.main.height - 30, '', {
        fontSize: '14px', fontFamily: 'monospace', color: '#44FF44',
        stroke: '#000', strokeThickness: 3
      }).setScrollFactor(0).setDepth(150);
    }
    const rInfo = REGION_NAMES[this.currentZone];
    if (rInfo) {
      this._regionHudText.setText(rInfo.name);
      this._regionHudText.setColor(rInfo.color);
    }

    // ‚ïê‚ïê‚ïê Day/Night color temperature (warm up after 20min) ‚ïê‚ïê‚ïê
    if (this._dayNightOverlay && this.gameElapsed > 1200) {
      const _dnAlpha = Math.min(0.04, (this.gameElapsed - 1200) / 6000 * 0.04);
      this._dayNightOverlay.setAlpha(_dnAlpha);
    }

    // ‚ïê‚ïê‚ïê NPC Proximity Speech Bubbles ‚ïê‚ïê‚ïê
    if (this.npcsOwned && this.player) {
      this.npcsOwned.forEach(npc => {
        if (!npc.active) return;
        const dist = Phaser.Math.Distance.Between(npc.x, npc.y, this.player.x, this.player.y);
        if (dist < 50 && !npc._bubbleActive && !npc._bubbleCooldown) {
          const bubbleText = NPC_BUBBLES[npc.npcType];
          if (bubbleText) {
            this.showNPCBubble(npc, bubbleText);
            npc._bubbleCooldown = true;
            this.time.delayedCall(15000, () => { npc._bubbleCooldown = false; });
          }
        }
      });
    }

    // ‚ïê‚ïê‚ïê Quest-based Wolf/Bear Spawn Guarantee ‚ïê‚ïê‚ïê
    this.questSpawnTimer += dt;
    if (this.questIndex < QUESTS.length) {
      const q = QUESTS[this.questIndex];
      const needsWolf = q.id === 'q5';
      const needsBear = q.id === 'q7';
      if (needsWolf || needsBear) {
        const targetType = needsWolf ? 'wolf' : 'bear';
        const nearbyCount = this.animals.getChildren().filter(a =>
          a.active && a.animalType === targetType &&
          Phaser.Math.Distance.Between(a.x, a.y, this.player.x, this.player.y) < 500
        ).length;
        // Every 15s, ensure at least 2 nearby
        if (this.questSpawnTimer >= 15 && nearbyCount < 2) {
          this.questSpawnTimer = 0;
          const toSpawn = 2 - nearbyCount;
          for (let i = 0; i < toSpawn; i++) {
            this.spawnAnimalNearPlayer(targetType, 300, 500);
          }
        }
      }
    }

    // ‚ïê‚ïê‚ïê üå¨Ô∏è WIND AMBIENCE UPDATE ‚ïê‚ïê‚ïê
    if(_windAmb&&soundEnabled){
      const inEZ=this.player&&this.player.x>WORLD_W*0.75&&this.player.y<WORLD_H*0.25;
      if(this.blizzardActive)setWindIntensity(3);
      else if(inEZ)setWindIntensity(2);
      else setWindIntensity(1);
    }

    // ‚ïê‚ïê‚ïê üëÅÔ∏è HIDDEN BOSS CHECK ‚ïê‚ïê‚ïê
    this._updateHiddenBoss(dt);

    // ‚ïê‚ïê‚ïê üé≠ SECRET EVENTS ‚ïê‚ïê‚ïê
    this._updateSecretEvents(dt);

    // ‚ïê‚ïê‚ïê üèÜ Achievement Check (1s throttle) ‚ïê‚ïê‚ïê
    this.achievementCheckTimer = (this.achievementCheckTimer || 0) + dt;
    if (this.achievementCheckTimer >= 1) {
      this.achievementCheckTimer = 0;
      this._checkAchievements();
    }

    // ‚ïê‚ïê‚ïê üé≤ Random Event System (3min interval, dedup with challenge/elite) ‚ïê‚ïê‚ïê
    this.randomEventTimer = (this.randomEventTimer || 0) + dt;
    if (this.randomEventTimer >= 180) {
      this.randomEventTimer = 0;
      // Skip if challenge active or event cooldown
      if (!this._challengeActive && !this._eventCooldown) {
        this._triggerRandomEvent();
        this._eventCooldown = true;
        this.time.delayedCall(15000, () => { this._eventCooldown = false; });
      }
    }
    // Clean up expired random events
    this._updateRandomEvents();

    // ‚ïê‚ïê‚ïê BOSS HP BAR + MINIMAP + VIGNETTE updates ‚ïê‚ïê‚ïê
    this._bossHPFrameCount = (this._bossHPFrameCount || 0) + 1;
    if (this._bossHPFrameCount % 3 === 0) this._updateBossHPBar();
    this._minimapFrameCount = (this._minimapFrameCount || 0) + 1;
    if (this._minimapFrameCount % 10 === 0) this._updateMinimap();
    this._updateVignette(dt);

    this.checkQuests();
    this._checkNewQuests();
    this.updateUI();

    // ‚ïê‚ïê‚ïê üåç WORLD OBJECTS UPDATE ‚ïê‚ïê‚ïê
    this._updateWorldObjects(dt);

    // ‚ïê‚ïê‚ïê PERF: FPS Debug Counter ‚ïê‚ïê‚ïê
    if (this._debugFPS) {
      this._fpsFrameCount++;
      const now = performance.now();
      const elapsed = now - this._fpsLastTime;
      if (elapsed >= 1000) {
        const fps = Math.round(this._fpsFrameCount * 1000 / elapsed);
        this._fpsHistory.push(fps);
        if (this._fpsHistory.length > 60) this._fpsHistory.shift();
        const avg = Math.round(this._fpsHistory.reduce((a,b) => a+b, 0) / this._fpsHistory.length);
        if (fps < 30) this._fpsSpikeCount++;
        this._fpsText.setText(`FPS: ${fps} | Avg: ${avg} | Spikes: ${this._fpsSpikeCount}\nEnemies: ${this.animals.getChildren().length} | Bolts: ${this._iceBolts.length}`);
        this._fpsFrameCount = 0;
        this._fpsLastTime = now;
      }
    }
  }

  // ‚ïê‚ïê‚ïê üåç WORLD OBJECTS METHODS ‚ïê‚ïê‚ïê
  _spawnWorldObjects() {
    const margin = 120;
    const rndPos = () => ({ x: Phaser.Math.Between(margin, WORLD_W - margin), y: Phaser.Math.Between(margin, WORLD_H - margin) });

    // üî• Campfires (4~6)
    const campCount = Phaser.Math.Between(4, 6);
    for (let i = 0; i < campCount; i++) {
      const pos = rndPos();
      const gfx = this.add.graphics().setDepth(3);
      // Draw campfire base (orange circle)
      gfx.fillStyle(0xFF6600, 0.8);
      gfx.fillCircle(pos.x, pos.y, 10);
      gfx.fillStyle(0xFF8800, 0.4);
      gfx.fillCircle(pos.x, pos.y, 18);
      const particles = [];
      this._worldObjects.campfires.push({ x: pos.x, y: pos.y, gfx, particles, _particleTimer: 0 });
    }

    // üì¶ Supply Crates (3~5)
    const crateCount = Phaser.Math.Between(3, 5);
    for (let i = 0; i < crateCount; i++) this._spawnCrate();

    // ‚ùÑÔ∏è Ice Walls (8~12)
    const wallCount = Phaser.Math.Between(8, 12);
    for (let i = 0; i < wallCount; i++) {
      const pos = rndPos();
      const w = Phaser.Math.Between(40, 70), h = Phaser.Math.Between(15, 25);
      const gfx = this.add.graphics().setDepth(3);
      gfx.fillStyle(0x66BBFF, 0.45);
      gfx.fillRoundedRect(pos.x - w/2, pos.y - h/2, w, h, 4);
      gfx.lineStyle(1, 0xAADDFF, 0.7);
      gfx.strokeRoundedRect(pos.x - w/2, pos.y - h/2, w, h, 4);
      const wallBaseHP = 50 * Math.pow(2, this.upgradeManager._glacialWallLevel || 0);
      this._worldObjects.iceWalls.push({ x: pos.x, y: pos.y, w, h, hp: wallBaseHP, maxHp: wallBaseHP, gfx, particles: [] });
    }
  }

  _spawnCrate() {
    const margin = 120;
    const pos = { x: Phaser.Math.Between(margin, WORLD_W - margin), y: Phaser.Math.Between(margin, WORLD_H - margin) };
    const gfx = this.add.graphics().setDepth(3);
    // Brown box with lid
    gfx.fillStyle(0x8B5E3C, 0.9);
    gfx.fillRect(pos.x - 12, pos.y - 8, 24, 16);
    gfx.fillStyle(0x6B3E1C, 0.9);
    gfx.fillRect(pos.x - 14, pos.y - 10, 28, 6);
    gfx.lineStyle(1, 0xFFD700, 0.6);
    gfx.strokeRect(pos.x - 12, pos.y - 8, 24, 16);
    this._worldObjects.crates.push({ x: pos.x, y: pos.y, gfx, particles: [] });
  }

  _spawnFlare() {
    const margin = 150;
    const pos = { x: Phaser.Math.Between(margin, WORLD_W - margin), y: Phaser.Math.Between(margin, WORLD_H - margin) };
    const gfx = this.add.graphics().setDepth(4);
    // Red triangle
    gfx.fillStyle(0xFF2222, 0.9);
    gfx.fillTriangle(pos.x, pos.y - 10, pos.x - 7, pos.y + 6, pos.x + 7, pos.y + 6);
    this._worldObjects.flares.push({ x: pos.x, y: pos.y, gfx, particles: [], _bob: 0 });
  }

  _updateWorldObjects(dt) {
    if (!this._worldObjects || !this.player || !this.player.active) return;
    const px = this.player.x, py = this.player.y;

    // üî• Campfires
    let nearCampfire = false;
    for (const cf of this._worldObjects.campfires) {
      const dist = Phaser.Math.Distance.Between(px, py, cf.x, cf.y);
      const cfRadius = 80 + (this.upgradeManager._campfireRadiusBonus || 0);
      if (dist < cfRadius) {
        nearCampfire = true;
        let healRate = this.blizzardActive ? 6 : 3;
        // HEARTH_MASTER: +50% per level
        if (this.upgradeManager._hearthMasterLevel > 0) healRate *= (1 + this.upgradeManager._hearthMasterLevel * 0.5);
        this.playerHP = Math.min(this.playerMaxHP, this.playerHP + healRate * dt);
      }
      // Fire particles
      cf._particleTimer -= dt;
      if (cf._particleTimer <= 0) {
        cf._particleTimer = 0.15;
        const colors = [0xFFCC00, 0xFF8800, 0xFF5500];
        const p = this.add.circle(
          cf.x + Phaser.Math.Between(-6, 6),
          cf.y + Phaser.Math.Between(-4, 2),
          Phaser.Math.Between(2, 4),
          Phaser.Math.RND.pick(colors), 0.8
        ).setDepth(4);
        this.tweens.add({ targets: p, y: p.y - Phaser.Math.Between(12, 25), alpha: 0, scale: 0.2, duration: Phaser.Math.Between(400, 700), onComplete: () => p.destroy() });
      }
    }
    // HUD for campfire
    if (nearCampfire) {
      if (!this._campfireHudText) {
        const healLabel = this.blizzardActive ? '+6HP/s' : '+3HP/s';
        this._campfireHudText = this.add.text(this.scale.width / 2, this.scale.height - 60, 'üî• Ïò®Í∏∞ ' + healLabel, {
          fontSize: '16px', fontFamily: 'monospace', color: '#FFB347', stroke: '#000', strokeThickness: 3
        }).setOrigin(0.5).setScrollFactor(0).setDepth(100);
      } else {
        this._campfireHudText.setText('üî• Ïò®Í∏∞ ' + (this.blizzardActive ? '+6HP/s' : '+3HP/s'));
      }
    } else if (this._campfireHudText) {
      this._campfireHudText.destroy();
      this._campfireHudText = null;
    }

    // üì¶ Supply Crates
    for (let i = this._worldObjects.crates.length - 1; i >= 0; i--) {
      const cr = this._worldObjects.crates[i];
      const dist = Phaser.Math.Distance.Between(px, py, cr.x, cr.y);
      if (dist < 50) {
        // Open crate
        const roll = Math.random();
        if (roll < 0.7) {
          // Meat +30 HP (SUPPLY_EXPERT: +50%)
          const meatHeal = this.upgradeManager._supplyExpertActive ? 45 : 30;
          this.playerHP = Math.min(this.playerMaxHP, this.playerHP + meatHeal);
          this.showFloatingText(cr.x, cr.y - 20, 'ü•© HP+' + meatHeal, '#FF8855');
        } else if (roll < 0.9) {
          // Equipment drop
          const drop = EquipmentManager.rollDrop(0);
          if (drop && drop.grade && drop.itemId) {
            const equipped = this.equipmentManager.tryEquip(drop.slot, drop.itemId, drop.grade);
            if (equipped) {
              this.showFloatingText(cr.x, cr.y - 20, (drop.icon||'‚öîÔ∏è') + ' ' + (drop.name||'Ïû•ÎπÑ') + ' Ïû•Ï∞©!', EQUIP_GRADE_COLORS[drop.grade] || '#9E9E9E');
              this._equipBonuses = this.equipmentManager.getTotalBonuses();
              this._updateEquipHUD();
            } else {
              this.equipmentManager.addToInventory(drop.slot, drop.itemId, drop.grade);
              this.showFloatingText(cr.x, cr.y - 20, (drop.icon||'‚öîÔ∏è') + ' Î≥¥Í¥Ä', '#AAAAAA');
            }
          } else {
            this.playerHP = Math.min(this.playerMaxHP, this.playerHP + 30);
            this.showFloatingText(cr.x, cr.y - 20, 'ü•© HP+30', '#FF8855');
          }
        } else {
          // Meta points +3
          const meta = MetaManager.load();
          meta.totalPoints += 3;
          MetaManager.save(meta);
          this.showFloatingText(cr.x, cr.y - 20, '‚≠ê Î©îÌÉÄÌè¨Ïù∏Ìä∏ +3', '#FFD700');
        }
        // Golden particles
        for (let p = 0; p < 8; p++) {
          const spark = this.add.circle(cr.x + Phaser.Math.Between(-10, 10), cr.y + Phaser.Math.Between(-10, 10), 3, 0xFFD700, 0.9).setDepth(5);
          this.tweens.add({ targets: spark, x: spark.x + Phaser.Math.Between(-30, 30), y: spark.y - Phaser.Math.Between(15, 35), alpha: 0, duration: 600, onComplete: () => spark.destroy() });
        }
        // SUPPLY_EXPERT: +30 XP on open
        if (this.upgradeManager._supplyExpertActive) {
          this.gainXP(30);
          this.showFloatingText(cr.x, cr.y - 35, 'üì¶ XP+30', '#44DD44');
        }
        playCoin();
        cr.gfx.destroy();
        this._worldObjects.crates.splice(i, 1);
      }
    }
    // Periodic crate spawn (every 10 min)
    this._worldObjCrateTimer += dt;
    if (this._worldObjCrateTimer >= 600 && this._worldObjects.crates.length < 8) {
      this._worldObjCrateTimer = 0;
      this._spawnCrate();
    }

    // ‚ùÑÔ∏è Ice Walls ‚Äî enemy collision
    const animals = this.animals.getChildren();
    for (let wi = this._worldObjects.iceWalls.length - 1; wi >= 0; wi--) {
      const wall = this._worldObjects.iceWalls[wi];
      const wl = wall.x - wall.w/2, wr = wall.x + wall.w/2, wt = wall.y - wall.h/2, wb = wall.y + wall.h/2;
      for (const a of animals) {
        if (!a.active || !a.body) continue;
        const ax = a.x, ay = a.y;
        // Simple AABB overlap check
        if (ax > wl - 12 && ax < wr + 12 && ay > wt - 12 && ay < wb + 12) {
          // Push enemy away from wall
          const ang = Phaser.Math.Angle.Between(wall.x, wall.y, ax, ay);
          a.x += Math.cos(ang) * 3;
          a.y += Math.sin(ang) * 3;
          // Enemy attacks wall
          if (!a._wallAttackCD) a._wallAttackCD = 0;
          a._wallAttackCD -= dt;
          if (a._wallAttackCD <= 0) {
            a._wallAttackCD = 1;
            wall.hp -= (a.def && a.def.damage ? a.def.damage : 5);
          }
        }
      }
      // Redraw wall based on HP
      if (wall.hp <= 0) {
        // Destroy with ice shard particles
        for (let p = 0; p < 6; p++) {
          const shard = this.add.circle(wall.x + Phaser.Math.Between(-15, 15), wall.y + Phaser.Math.Between(-8, 8), Phaser.Math.Between(2, 5), 0x88CCFF, 0.8).setDepth(5);
          this.tweens.add({ targets: shard, x: shard.x + Phaser.Math.Between(-40, 40), y: shard.y + Phaser.Math.Between(-30, 30), alpha: 0, duration: 500, onComplete: () => shard.destroy() });
        }
        wall.gfx.destroy();
        this._worldObjects.iceWalls.splice(wi, 1);
      } else {
        // Update opacity based on remaining HP
        const ratio = wall.hp / wall.maxHp;
        wall.gfx.clear();
        wall.gfx.fillStyle(0x66BBFF, 0.45 * ratio);
        wall.gfx.fillRoundedRect(wall.x - wall.w/2, wall.y - wall.h/2, wall.w, wall.h, 4);
        wall.gfx.lineStyle(1, 0xAADDFF, 0.7 * ratio);
        wall.gfx.strokeRoundedRect(wall.x - wall.w/2, wall.y - wall.h/2, wall.w, wall.h, 4);
      }
    }

    // üß≤ Signal Flares
    this._worldObjFlareTimer -= dt;
    if (this._worldObjFlareTimer <= 0 && this._worldObjects.flares.length < 2) {
      this._worldObjFlareTimer = Phaser.Math.Between(300, 420);
      this._spawnFlare();
    }
    for (let i = this._worldObjects.flares.length - 1; i >= 0; i--) {
      const fl = this._worldObjects.flares[i];
      // Bob animation
      fl._bob += dt * 2;
      fl.gfx.clear();
      const bobY = Math.sin(fl._bob) * 4;
      const alpha = 0.6 + Math.sin(fl._bob * 1.5) * 0.3;
      fl.gfx.fillStyle(0xFF2222, alpha);
      fl.gfx.fillTriangle(fl.x, fl.y - 10 + bobY, fl.x - 7, fl.y + 6 + bobY, fl.x + 7, fl.y + 6 + bobY);

      const dist = Phaser.Math.Distance.Between(px, py, fl.x, fl.y);
      if (dist < 50) {
        // Activate 2x XP for 30s (FLARE_EXPERT: +15s per level)
        const flareDur = 30 + (this.upgradeManager._flareExpertLevel || 0) * 15;
        this._flareXpBuff = flareDur;
        this.showFloatingText(fl.x, fl.y - 20, 'üß≤ XP 2Î∞∞! ' + flareDur + 'Ï¥à', '#FF6600');
        // FLARE_EXPERT: +20% attack speed for 15s
        if (this.upgradeManager._flareExpertLevel > 0) {
          this._flareAtkSpeedBuff = 15;
          this.baseAttackSpeed *= 0.8;
          this.showFloatingText(fl.x, fl.y - 35, '‚ö° Í≥µÏÜç+20% 15Ï¥à', '#FFAA00');
        }
        fl.gfx.destroy();
        this._worldObjects.flares.splice(i, 1);
      }
    }

    // Flare XP buff countdown
    if (this._flareXpBuff > 0) {
      this._flareXpBuff -= dt;
      // Orange aura around player
      if (!this._flareAura) {
        this._flareAura = this.add.graphics().setDepth(9);
      }
      this._flareAura.clear();
      this._flareAura.lineStyle(2, 0xFF8800, 0.4 + Math.sin(Date.now() * 0.005) * 0.2);
      this._flareAura.strokeCircle(px, py, 30);
      // HUD countdown
      if (!this._flareHudText) {
        this._flareHudText = this.add.text(this.scale.width / 2, this.scale.height - 80, '', {
          fontSize: '14px', fontFamily: 'monospace', color: '#FF8800', stroke: '#000', strokeThickness: 3
        }).setOrigin(0.5).setScrollFactor(0).setDepth(100);
      }
      this._flareHudText.setText('üß≤ XP 2Î∞∞ ' + Math.ceil(this._flareXpBuff) + 'Ï¥à');
      if (this._flareXpBuff <= 0) {
        this._flareXpBuff = 0;
        if (this._flareAura) { this._flareAura.destroy(); this._flareAura = null; }
        if (this._flareHudText) { this._flareHudText.destroy(); this._flareHudText = null; }
      }
    }
    // FLARE_EXPERT: attack speed buff countdown
    if (this._flareAtkSpeedBuff > 0) {
      this._flareAtkSpeedBuff -= dt;
      if (this._flareAtkSpeedBuff <= 0) {
        this._flareAtkSpeedBuff = 0;
        this.baseAttackSpeed /= 0.8; // restore
      }
    }
  }

  // ‚ïê‚ïê‚ïê üèÜ ACHIEVEMENT METHODS ‚ïê‚ïê‚ïê
  // ‚ïê‚ïê‚ïê New Quest System (5 additional quest types) ‚ïê‚ïê‚ïê
  _checkNewQuests() {
    if (!this._questProgress) return;
    const NEW_QUESTS = [
      { id: 'q_equip_collect', text: 'Ïû•ÎπÑ 3Í∞ú ÏàòÏßë', target: 3, type: 'equipment_collected', reward: { xp: 200, points: 5 } },
      { id: 'q_boss_damage', text: 'Î≥¥Ïä§ÏóêÍ≤å 500 Îç∞ÎØ∏ÏßÄ', target: 500, type: 'boss_damage_dealt', reward: { xp: 300, points: 10 } },
      { id: 'q_synergy', text: 'ÏãúÎÑàÏßÄ 1Í∞ú Î∞úÎèô', target: 1, type: 'synergy_activated', reward: { xp: 150, points: 8 } },
      { id: 'q_critical', text: 'ÌÅ¨Î¶¨Ìã∞Ïª¨ ÌûàÌä∏ 10Ìöå', target: 10, type: 'critical_hits', reward: { xp: 100, points: 5 } },
      { id: 'q_zone_explore', text: 'Î™®Îì† ÏßÄÏó≠ Î∞©Î¨∏', target: 4, type: 'zones_visited', reward: { xp: 200, points: 8 } },
    ];
    NEW_QUESTS.forEach(q => {
      if (this._newQuestsDone.has(q.id)) return;
      if ((this._questProgress[q.type] || 0) >= q.target) {
        this._newQuestsDone.add(q.id);
        this.playerXP = (this.playerXP || 0) + q.reward.xp;
        const cam = this.cameras.main;
        const t = this.add.text(cam.width / 2, cam.height * 0.25, '‚úÖ ' + q.text + ' ÏôÑÎ£å!\n+' + q.reward.xp + ' XP', {
          fontSize: '18px', fontFamily: 'monospace', color: '#00FF88', stroke: '#000', strokeThickness: 4, align: 'center'
        }).setScrollFactor(0).setDepth(250).setOrigin(0.5);
        this.tweens.add({ targets: t, y: t.y - 30, alpha: 0, duration: 2500, delay: 500, onComplete: () => t.destroy() });
        playQuest();
      }
    });
  }

  _togglePause() {
    if (this.gameOver) return;
    this._gamePaused = !this._gamePaused;
    if (this._gamePaused) {
      this.physics.pause();
      const cam = this.cameras.main;
      const overlay = this.add.rectangle(cam.centerX, cam.centerY, cam.width, cam.height, 0x000000, 0.7).setScrollFactor(0).setDepth(500);
      const cardW = Math.min(320, cam.width - 40), cardH = 280;
      const cx = cam.centerX, cy = cam.centerY;
      const card = this.add.graphics().setScrollFactor(0).setDepth(501);
      card.fillStyle(0x0D1117, 0.95); card.fillRoundedRect(cx - cardW/2, cy - cardH/2, cardW, cardH, 12);
      card.lineStyle(1, 0x334455, 0.6); card.strokeRoundedRect(cx - cardW/2, cy - cardH/2, cardW, cardH, 12);
      const title = this.add.text(cx, cy - cardH/2 + 30, '‚è∏Ô∏è ÏùºÏãúÏ†ïÏßÄ', {
        fontSize: '24px', fontFamily: 'monospace', color: '#FFFFFF', stroke: '#000', strokeThickness: 3
      }).setOrigin(0.5).setScrollFactor(0).setDepth(502);
      const keys = [
        'WASD / Î∞©Ìñ•ÌÇ§ ‚Äî Ïù¥Îèô',
        'ESC / P      ‚Äî ÏùºÏãúÏ†ïÏßÄ',
        'M            ‚Äî ÎØ∏ÎãàÎßµ ÌÜ†Í∏Ä',
        '1/2/3/4      ‚Äî ÏïÑÏù¥ÌÖú ÏÇ¨Ïö©',
        '‚Üë‚Üë‚Üì‚Üì‚Üê‚Üí‚Üê‚ÜíBA ‚Äî ???'
      ];
      const keysText = this.add.text(cx, cy - 20, '‚å®Ô∏è Îã®Ï∂ïÌÇ§:\n' + keys.join('\n'), {
        fontSize: '12px', fontFamily: 'monospace', color: '#8899AA', stroke: '#000', strokeThickness: 2, lineSpacing: 4, align: 'left'
      }).setOrigin(0.5).setScrollFactor(0).setDepth(502);
      const btnBg = this.add.graphics().setScrollFactor(0).setDepth(502);
      btnBg.fillStyle(0x2255aa, 0.9); btnBg.fillRoundedRect(cx - 60, cy + cardH/2 - 50, 120, 34, 6);
      const btnText = this.add.text(cx, cy + cardH/2 - 33, '‚ñ∂ Í≥ÑÏÜçÌïòÍ∏∞', {
        fontSize: '14px', fontFamily: 'monospace', color: '#FFFFFF'
      }).setOrigin(0.5).setScrollFactor(0).setDepth(503);
      const btnHit = this.add.rectangle(cx, cy + cardH/2 - 33, 120, 34, 0, 0).setScrollFactor(0).setDepth(504).setInteractive({ useHandCursor: true });
      btnHit.on('pointerdown', () => this._togglePause());
      this._pauseOverlay = [overlay, card, title, keysText, btnBg, btnText, btnHit];
    } else {
      this.physics.resume();
      if (this._pauseOverlay) { this._pauseOverlay.forEach(e => e.destroy()); this._pauseOverlay = null; }
    }
  }

  _checkAllEpicEquip() {
    try {
      const eqRaw = localStorage.getItem(EquipmentManager.STORAGE_KEY);
      if (!eqRaw) return false;
      const eqData = JSON.parse(eqRaw);
      const slots = Object.keys(SLOT_ICONS);
      for (const slot of slots) {
        if (!eqData[slot]) return false;
        const item = EQUIPMENT_TABLE[slot]?.find(i => i.id === eqData[slot].itemId);
        if (!item || (item.tier !== 'epic' && item.tier !== 'legendary')) return false;
      }
      return true;
    } catch(e) { return false; }
  }

  _checkAchievements() {
    const kills = this.upgradeManager ? this.upgradeManager.totalKills : 0;
    const elapsed = this.gameElapsed || 0;
    const combo = this.killCombo || 0;
    const maxCombo = Math.max(combo, this.stats.maxCombo || 0);
    const lv = this.playerLevel || 1;
    const eq = { rare: this.gotRareEquip, epic: this.gotEpicEquip };
    const bossK = this.bossKillCount || 0;
    const craftC = this.stats.crafted || 0;

    const checks = {
      first_blood:    kills >= 1,
      survivor_5:     elapsed >= 300,
      combo_10:       maxCombo >= 10,
      level_10:       lv >= 10,
      equipment_rare: eq.rare,
      equipment_epic: eq.epic,
      boss_kill:      bossK >= 1,
      craft_1:        craftC >= 1,
      survivor_30:    elapsed >= 1800,
      kills_100:      kills >= 100,
      secret_hidden_boss: this._hiddenBossDefeated === true,
      secret_konami:      this._konamiActivated === true,
      secret_survive_zone: (this._extremeZoneTotalTime || 0) >= 300,
      // ÌÅ¥ÎûòÏä§ ÎßàÏä§ÌÑ∞Î¶¨
      class_warrior:   (() => { try { return JSON.parse(localStorage.getItem('whiteout_class_wins') || '{}').warrior; } catch(e) { return false; } })(),
      class_mage:      (() => { try { return JSON.parse(localStorage.getItem('whiteout_class_wins') || '{}').mage; } catch(e) { return false; } })(),
      class_survivor:  (() => { try { return JSON.parse(localStorage.getItem('whiteout_class_wins') || '{}').survivor; } catch(e) { return false; } })(),
      class_shaman:    (() => { try { return JSON.parse(localStorage.getItem('whiteout_class_wins') || '{}').shaman; } catch(e) { return false; } })(),
      class_hunter:    (() => { try { return JSON.parse(localStorage.getItem('whiteout_class_wins') || '{}').hunter; } catch(e) { return false; } })(),
      // ÎèÑÏ†Ñ Î™®Îìú
      boss_rush_clear: (() => { try { return RecordManager.load().bossRushClears >= 1; } catch(e) { return false; } })(),
      ng_plus_clear:   (() => { try { return RecordManager.load().ngPlusClears >= 1; } catch(e) { return false; } })(),
      endless_30:      (() => { try { return RecordManager.load().longestEndlessSurvival >= 5400; } catch(e) { return false; } })(),
      hard_clear:      (() => { try { return RecordManager.load().hardClears >= 1; } catch(e) { return false; } })(),
      // ÏàòÏßë/ÌÉêÌóò
      all_equipment:   this._checkAllEpicEquip ? this._checkAllEpicEquip() : false,
      all_zones:       (this._visitedZones && this._visitedZones.size >= 4),
      all_synergies:   (this.synergyManager && this.synergyManager.activeSynergies && this.synergyManager.activeSynergies.size >= 5),
    };

    for (const ach of ACHIEVEMENTS) {
      if (this.achievementUnlocked[ach.id]) continue;
      if (this._savedAchievements[ach.id]) { this.achievementUnlocked[ach.id] = true; continue; }
      if (checks[ach.id]) {
        this.achievementUnlocked[ach.id] = true;
        this._savedAchievements[ach.id] = true;
        try { localStorage.setItem('achievements_whiteout', JSON.stringify(this._savedAchievements)); } catch(e) {}
        this._showAchievementBanner(ach);
      }
    }
  }

  _showAchievementBanner(ach) {
    playAchievement();
    // üéÅ Achievement rewards
    const reward = ACHIEVEMENT_REWARDS[ach.id];
    let rewardText = '';
    if (reward) {
      if (reward.type === 'meta_points') {
        const meta = MetaManager.load();
        meta.totalPoints += reward.amount;
        MetaManager.save(meta);
        rewardText = `+${reward.amount} Ìè¨Ïù∏Ìä∏`;
      } else if (reward.type === 'skin_unlock') {
        rewardText = 'üé® Ïä§ÌÇ® Ïû†Í∏àÌï¥Ï†ú!';
      }
    }

    const cam = this.cameras.main;
    const W = cam.width;
    const cardW = Math.min(280, W * 0.6);
    const cardH = rewardText ? 95 : 80;
    const startX = W + cardW / 2;
    const endX = W - cardW / 2 - 10;
    const yPos = 60;

    const container = this.add.container(startX, yPos).setScrollFactor(0).setDepth(500);

    // Card background
    const bg = this.add.graphics();
    bg.fillStyle(0x1a1a2e, 0.95);
    bg.fillRoundedRect(-cardW/2, -cardH/2, cardW, cardH, 10);
    bg.lineStyle(2, 0xDAA520, 1);
    bg.strokeRoundedRect(-cardW/2, -cardH/2, cardW, cardH, 10);
    container.add(bg);

    const title = this.add.text(0, -cardH/2 + 14, 'üèÜ ÏÑ±Ï∑® Îã¨ÏÑ±!', {
      fontSize: '12px', fontFamily: 'monospace', color: '#DAA520', fontStyle: 'bold'
    }).setOrigin(0.5);
    container.add(title);

    const body = this.add.text(0, rewardText ? 0 : 6, `${ach.icon} ${ach.name}`, {
      fontSize: '16px', fontFamily: 'monospace', color: '#FFFFFF', fontStyle: 'bold'
    }).setOrigin(0.5);
    container.add(body);

    const desc = this.add.text(0, rewardText ? 16 : cardH/2 - 14, ach.desc, {
      fontSize: '11px', fontFamily: 'monospace', color: '#AAAAAA'
    }).setOrigin(0.5);
    container.add(desc);

    if (rewardText) {
      const rwdTxt = this.add.text(0, cardH/2 - 12, `üéÅ ${rewardText}`, {
        fontSize: '12px', fontFamily: 'monospace', color: '#44FF88', fontStyle: 'bold'
      }).setOrigin(0.5);
      container.add(rwdTxt);
    }

    // Slide in
    this.tweens.add({ targets: container, x: endX, duration: 500, ease: 'Back.Out' });
    // Slide out after 3s
    this.tweens.add({
      targets: container, x: startX + 50, duration: 400, ease: 'Quad.In', delay: 3000,
      onComplete: () => container.destroy()
    });
  }

  // ‚ïê‚ïê‚ïê üé≤ RANDOM EVENT METHODS ‚ïê‚ïê‚ïê
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // üëÅÔ∏è HIDDEN BOSS SYSTEM: Î∞±ÏÉâ Íµ∞Ï£º
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  _updateHiddenBoss(dt) {
    if (this._hiddenBossSpawned || this._hiddenBossDefeated || !this.player || this.gameOver) return;

    // Extreme zone = top-right corner (x > WORLD_W * 0.75, y < WORLD_H * 0.25)
    const inExtremeZone = this.player.x > WORLD_W * 0.75 && this.player.y < WORLD_H * 0.25;

    // Track total extreme zone time for achievement
    if (inExtremeZone) this._extremeZoneTotalTime = (this._extremeZoneTotalTime || 0) + dt;

    // Hidden boss requires 20min survival + 30s in extreme zone
    if (this.gameElapsed < 1200) return; // 20 minutes

    if (inExtremeZone) {
      this._extremeZoneTimer += dt;
      if (this._extremeZoneTimer >= 30) {
        this._spawnHiddenBoss();
      }
    } else {
      this._extremeZoneTimer = 0;
    }
  }

  _spawnHiddenBoss() {
    if (this._hiddenBossSpawned) return;
    this._hiddenBossSpawned = true;

    // Phase 1: Ominous text
    const cam = this.cameras.main;
    const warn1 = this.add.text(cam.width / 2, cam.height / 2, '‚ùÑÔ∏è Î¨¥Ïñ∏Í∞Ä Ïù¥ÏÉÅÌïòÎã§...', {
      fontSize: '22px', fontFamily: 'monospace', color: '#AADDFF', stroke: '#000', strokeThickness: 4
    }).setOrigin(0.5).setScrollFactor(0).setDepth(500);
    this.tweens.add({ targets: warn1, alpha: 0, duration: 2000, delay: 500, onComplete: () => warn1.destroy() });

    // Phase 2: Boss announcement after 5s
    this.time.delayedCall(5000, () => {
      if (this.gameOver) return;
      const warn2 = this.add.text(cam.width / 2, cam.height / 2, 'üëÅÔ∏è Î∞±ÏÉâ Íµ∞Ï£ºÍ∞Ä Íπ®Ïñ¥ÎÇ¨Îã§!', {
        fontSize: '24px', fontFamily: 'monospace', color: '#FFD700', stroke: '#000', strokeThickness: 5, fontStyle: 'bold'
      }).setOrigin(0.5).setScrollFactor(0).setDepth(500);
      this.tweens.add({ targets: warn2, alpha: 0, duration: 2000, delay: 500, onComplete: () => warn2.destroy() });

      // Spawn the boss
      this.time.delayedCall(1000, () => {
        if (this.gameOver) return;
        this._createHiddenBoss();
      });
    });
  }

  _createHiddenBoss() {
    const bossHP = 6000; // 1.5x of final boss (4000) ‚Äì ~20s fight at max DPS
    const bossScale = 3.2;
    const bossDmg = 40;
    const bossSpeed = 60;
    const bossName = 'üëÅÔ∏è Î∞±ÏÉâ Íµ∞Ï£º';

    const angle = Math.random() * Math.PI * 2;
    const dist = 350;
    const bx = Phaser.Math.Clamp(this.player.x + Math.cos(angle) * dist, 80, WORLD_W - 80);
    const by = Phaser.Math.Clamp(this.player.y + Math.sin(angle) * dist, 80, WORLD_H - 80);

    const boss = this.physics.add.sprite(bx, by, 'bear').setCollideWorldBounds(true).setDepth(5);
    boss.setScale(bossScale);
    boss.setTint(0xEEEEFF);
    boss.animalType = 'boss';
    boss.def = { hp: bossHP, speed: bossSpeed, damage: bossDmg, drops: { meat: 40, leather: 20 }, size: 26 * bossScale, behavior: 'chase', name: bossName, aggroRange: 600, fleeRange: 0, fleeDistance: 0, color: 0xEEEEFF };
    boss.hp = bossHP;
    boss.maxHP = bossHP;
    boss.wanderTimer = 0;
    boss.wanderDir = { x: 0, y: 0 };
    boss.hitFlash = 0;
    boss.atkCD = 0;
    boss.fleeTimer = 0;
    boss.isBoss = true;
    boss.isFinalBoss = false;
    boss.isHiddenBoss = true;
    boss.bossPatternTimer = 0;
    boss.bossEnraged = false;
    boss.bossMinionSpawned = false;
    boss.slowAuraRadius = 150;
    boss.slowAuraFactor = 0.6; // -40% speed
    boss.hpBar = this.add.graphics().setDepth(6);
    boss.nameLabel = this.add.text(bx, by - boss.def.size - 10, bossName, {
      fontSize: '18px', fontFamily: 'monospace', color: '#FFD700', stroke: '#000', strokeThickness: 4, fontStyle: 'bold'
    }).setDepth(6).setOrigin(0.5);
    this.animals.add(boss);

    // Camera shake
    this.cameras.main.shake(800, 0.02);
    try { playBossSpawn(); } catch(e) {}
    this._triggerBossEntrance(bossName);
  }

  _onHiddenBossKilled() {
    this._hiddenBossDefeated = true;
    try { localStorage.setItem('whiteout_hidden_boss_defeated', 'true'); } catch(e) {}

    // Drop 3 epic+ equipment
    for (let i = 0; i < 3; i++) {
      const slots = Object.keys(EQUIPMENT_TABLE);
      const slot = slots[Math.floor(Math.random() * slots.length)];
      const items = EQUIPMENT_TABLE[slot];
      const item = items[Math.floor(Math.random() * items.length)];
      const grade = Math.random() < 0.3 ? 'legendary' : 'epic';
      this.equipmentManager.tryEquip(slot, item.id, grade);
    }

    // +500 XP
    this.playerXP += 500;

    // Banner
    const cam = this.cameras.main;
    const txt = this.add.text(cam.width / 2, cam.height / 2 - 40, 'üëÅÔ∏è Î∞±ÏÉâ Íµ∞Ï£ºÎ•º Ï≤òÏπòÌñàÎã§!\nÏóêÌîΩ Ïû•ÎπÑ 3Í∞ú + 500 XP', {
      fontSize: '20px', fontFamily: 'monospace', color: '#FFD700', stroke: '#000', strokeThickness: 4, align: 'center'
    }).setOrigin(0.5).setScrollFactor(0).setDepth(500);
    this.tweens.add({ targets: txt, alpha: 0, duration: 3000, delay: 2000, onComplete: () => txt.destroy() });
  }

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // üé≠ SECRET EVENTS
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  _updateSecretEvents(dt) {
    if (this.gameOver || !this.player) return;

    this._secretEventTimer += dt;

    // Check every 30 seconds
    if (this._secretEventTimer >= 30) {
      this._secretEventTimer = 0;

      // Skip secret events during challenge or event cooldown
      if (this._challengeActive || this._eventCooldown) return;

      // Ghost Merchant: 15% chance, after 10 min
      if (this.gameElapsed >= 600 && !this._ghostMerchantUsed && !this._ghostMerchantActive && Math.random() < 0.15) {
        this._triggerGhostMerchant();
        return; // one secret event per check
      }

      // Shooting Star: 5% chance, anytime
      if (Math.random() < 0.05) {
        this._triggerShootingStar();
      }
    }

    // Update ghost merchant proximity
    if (this._ghostMerchantActive && this._ghostMerchantSprite && this._ghostMerchantSprite.active) {
      const dist = Phaser.Math.Distance.Between(this.player.x, this.player.y, this._ghostMerchantSprite.x, this._ghostMerchantSprite.y);
      if (dist < 60) {
        this._ghostMerchantActive = false;
        this._ghostMerchantUsed = true;
        if (this._ghostMerchantSprite) { this._ghostMerchantSprite.destroy(); this._ghostMerchantSprite = null; }
        if (this._ghostMerchantLabel) { this._ghostMerchantLabel.destroy(); this._ghostMerchantLabel = null; }
        // Reward: 2 extra upgrade picks
        this.pendingLevelUps += 2;
        if (!this.upgradeUIActive) { this.pendingLevelUps--; this.triggerLevelUp(); }
      }
    }

    // Hidden boss slow aura
    if (this.player && this.animals) {
      this.animals.getChildren().forEach(a => {
        if (a.isHiddenBoss && a.active && a.hp > 0) {
          const dist = Phaser.Math.Distance.Between(this.player.x, this.player.y, a.x, a.y);
          if (dist < a.slowAuraRadius) {
            this._hiddenBossSlowActive = true;
          } else {
            this._hiddenBossSlowActive = false;
          }
        }
      });
    }
  }

  _triggerGhostMerchant() {
    this._ghostMerchantActive = true;
    const cam = this.cameras.main;

    // Spawn near player
    const angle = Math.random() * Math.PI * 2;
    const mx = Phaser.Math.Clamp(this.player.x + Math.cos(angle) * 200, 80, WORLD_W - 80);
    const my = Phaser.Math.Clamp(this.player.y + Math.sin(angle) * 200, 80, WORLD_H - 80);

    this._ghostMerchantSprite = this.add.circle(mx, my, 12, 0xAAAAFF, 0.7).setDepth(10);
    this._ghostMerchantLabel = this.add.text(mx, my - 20, 'üëª', { fontSize: '20px' }).setOrigin(0.5).setDepth(10);

    // Banner
    const banner = this.add.text(cam.width / 2, 80, 'üëª Ïú†Î†π ÏÉÅÏù∏Ïù¥ ÏßÄÎÇòÍ∞ëÎãàÎã§...', {
      fontSize: '16px', fontFamily: 'monospace', color: '#CCCCFF', stroke: '#000', strokeThickness: 3
    }).setOrigin(0.5).setScrollFactor(0).setDepth(500);
    this.tweens.add({ targets: banner, alpha: 0, duration: 1000, delay: 3000, onComplete: () => banner.destroy() });

    // Disappear after 5s
    this.time.delayedCall(5000, () => {
      this._ghostMerchantActive = false;
      if (this._ghostMerchantSprite && this._ghostMerchantSprite.active) { this._ghostMerchantSprite.destroy(); this._ghostMerchantSprite = null; }
      if (this._ghostMerchantLabel && this._ghostMerchantLabel.active) { this._ghostMerchantLabel.destroy(); this._ghostMerchantLabel = null; }
    });
  }

  _triggerShootingStar() {
    const cam = this.cameras.main;
    const W = cam.width, H = cam.height;

    // Diagonal star movement
    const star = this.add.text(0, 0, 'üå†', { fontSize: '24px' }).setScrollFactor(0).setDepth(500);
    this.tweens.add({
      targets: star, x: W, y: H, duration: 500,
      onComplete: () => star.destroy()
    });

    // Apply random upgrade
    const available = this.upgradeManager.getAvailableUpgrades(this._playerClass);
    if (available.length > 0) {
      const pick = available[Math.floor(Math.random() * available.length)];
      const upg = UPGRADES[pick];
      this.upgradeManager.apply(pick, this);

      this.time.delayedCall(600, () => {
        const txt = this.add.text(cam.width / 2, cam.height / 2, `üå† ÏÜåÏõêÏùÑ ÎπåÎ©¥...\n‚ú® ${upg.icon} ${upg.name} ÌöçÎìù!`, {
          fontSize: '18px', fontFamily: 'monospace', color: '#FFDD44', stroke: '#000', strokeThickness: 4, align: 'center'
        }).setOrigin(0.5).setScrollFactor(0).setDepth(500);
        this.tweens.add({ targets: txt, alpha: 0, duration: 2000, delay: 1500, onComplete: () => txt.destroy() });
      });
    }
  }

  onEnemyKilled_secretCheck() {
    // Snow Leopard Pack: 2% per 10 kills
    this._secretKillCounter = (this._secretKillCounter || 0) + 1;
    if (this._secretKillCounter >= 10) {
      this._secretKillCounter = 0;
      if (Math.random() < 0.02) {
        this._triggerSnowLeopardPack();
      }
    }
  }

  _triggerSnowLeopardPack() {
    const cam = this.cameras.main;
    // Banner
    const banner = this.add.text(cam.width / 2, 80, 'üêÜüêÜüêÜ ÎààÌëúÎ≤î Î¨¥Î¶¨!', {
      fontSize: '18px', fontFamily: 'monospace', color: '#FF8C00', stroke: '#000', strokeThickness: 4
    }).setOrigin(0.5).setScrollFactor(0).setDepth(500);
    this.tweens.add({ targets: banner, alpha: 0, duration: 1000, delay: 2500, onComplete: () => banner.destroy() });

    // Spawn 3 snow leopards
    for (let i = 0; i < 3; i++) {
      this.spawnAnimal('snow_leopard');
    }
  }

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // üéÆ KONAMI CODE EASTER EGG
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  _activateKonamiCode() {
    const cam = this.cameras.main;

    // Equip epic items in all slots
    const slots = Object.keys(EQUIPMENT_TABLE);
    for (const slot of slots) {
      const items = EQUIPMENT_TABLE[slot];
      const bestItem = items[items.length - 1]; // last = best
      this.equipmentManager.tryEquip(slot, bestItem.id, 'epic');
    }

    // Banner
    const txt = this.add.text(cam.width / 2, cam.height / 2, 'üéÆ ÏπòÌä∏ Î∞úÎèô!', {
      fontSize: '28px', fontFamily: 'monospace', color: '#FF44FF', stroke: '#000', strokeThickness: 5, fontStyle: 'bold'
    }).setOrigin(0.5).setScrollFactor(0).setDepth(600);
    this.tweens.add({ targets: txt, alpha: 0, duration: 2000, delay: 1500, onComplete: () => txt.destroy() });

    // Camera flash
    this.cameras.main.flash(500, 255, 200, 255);
  }

  _triggerRandomEvent() {
    const evt = RANDOM_EVENTS[Math.floor(Math.random() * RANDOM_EVENTS.length)];
    this._showEventBanner(evt);

    switch (evt.action) {
      case 'spawn_chest':
        this.spawnSupplyCrate();
        break;
      case 'blizzard_double':
        this.activeRandomEvents.blizzard_double = { endTime: this.gameElapsed + (evt.duration || 30), origMul: this.blizzardMultiplier };
        this.blizzardMultiplier = Math.max(this.blizzardMultiplier, 1) * 2;
        break;
      case 'spawn_rush':
        this.activeRandomEvents.spawn_rush = { endTime: this.gameElapsed + (evt.duration || 30) };
        // Immediately spawn a wave of enemies
        for (let i = 0; i < 10; i++) {
          const spawnConfig = this.getSpawnConfig();
          this.spawnAnimal(this.pickAnimalType(spawnConfig.weights));
        }
        break;
      case 'drop_fever':
        this.activeRandomEvents.drop_fever = { endTime: this.gameElapsed + (evt.duration || 30) };
        break;
      case 'heal_boost':
        this.activeRandomEvents.heal_boost = { endTime: this.gameElapsed + (evt.duration || 30) };
        break;
      case 'equip_bonus_5x':
        this.activeRandomEvents.equip_bonus_5x = { endTime: this.gameElapsed + (evt.duration || 30) };
        break;
      case 'xp_triple':
        this.activeRandomEvents.xp_triple = { endTime: this.gameElapsed + (evt.duration || 30) };
        break;
      case 'damage_reduce':
        this.activeRandomEvents.damage_reduce = { endTime: this.gameElapsed + (evt.duration || 30) };
        // ‚ïê‚ïê‚ïê Shield bubble effect ‚ïê‚ïê‚ïê
        if (this.player && this.player.active) {
          const _shieldBubble = this.add.circle(this.player.x, this.player.y, 30, 0x4488FF, 0.15).setDepth(14);
          const _shieldRing = this.add.circle(this.player.x, this.player.y, 30, 0x4488FF, 0).setDepth(14);
          _shieldRing.setStrokeStyle(2, 0x66AAFF, 0.6);
          this.tweens.add({ targets: [_shieldBubble, _shieldRing], scale: { from: 0.5, to: 1.2 }, duration: 400, ease: 'Back.Out' });
          this.tweens.add({ targets: _shieldBubble, alpha: { from: 0.3, to: 0.05 }, yoyo: true, repeat: -1, duration: 1000 });
          // Follow player
          const _shieldUpdate = this.time.addEvent({ delay: 16, loop: true, callback: () => {
            if (!this.player || !this.player.active || this.gameElapsed >= this.activeRandomEvents.damage_reduce?.endTime) {
              _shieldBubble.destroy(); _shieldRing.destroy(); _shieldUpdate.remove(); return;
            }
            _shieldBubble.setPosition(this.player.x, this.player.y);
            _shieldRing.setPosition(this.player.x, this.player.y);
          }});
        }
        break;
      case 'combo_xp':
        this.activeRandomEvents.combo_xp = { charges: evt.charges || 10 };
        break;
      case 'class_cd_zero':
        this.activeRandomEvents.class_cd_zero = { endTime: this.gameElapsed + (evt.duration || 30) };
        break;
    }
  }

  _showEventBanner(evt) {
    const cam = this.cameras.main;
    const W = cam.width;
    const bannerW = Math.min(400, W * 0.85);
    const bannerH = 70;

    const container = this.add.container(W / 2, -bannerH).setScrollFactor(0).setDepth(500);

    const bg = this.add.graphics();
    bg.fillStyle(0x1a0a00, 0.92);
    bg.fillRoundedRect(-bannerW/2, -bannerH/2, bannerW, bannerH, 12);
    bg.lineStyle(2, 0xFF8C00, 1);
    bg.strokeRoundedRect(-bannerW/2, -bannerH/2, bannerW, bannerH, 12);
    container.add(bg);

    const title = this.add.text(0, -12, evt.name, {
      fontSize: '16px', fontFamily: 'monospace', color: '#FF8C00', fontStyle: 'bold'
    }).setOrigin(0.5);
    container.add(title);

    const desc = this.add.text(0, 14, evt.desc, {
      fontSize: '11px', fontFamily: 'monospace', color: '#FFDDAA'
    }).setOrigin(0.5);
    container.add(desc);

    // Slide down
    this.tweens.add({ targets: container, y: 50, duration: 400, ease: 'Back.Out' });
    // Slide up after 3s
    this.tweens.add({
      targets: container, y: -bannerH - 10, duration: 400, ease: 'Quad.In', delay: 3000,
      onComplete: () => container.destroy()
    });
  }

  _updateRandomEvents() {
    const now = this.gameElapsed || 0;
    const active = this.activeRandomEvents;
    if (!active) return;

    // Blizzard double
    if (active.blizzard_double && now >= active.blizzard_double.endTime) {
      this.blizzardMultiplier = active.blizzard_double.origMul || 1;
      delete active.blizzard_double;
    }

    // Spawn rush ended (no cleanup needed, was instant burst)
    if (active.spawn_rush && now >= active.spawn_rush.endTime) {
      delete active.spawn_rush;
    }

    // Drop fever - applied in _tryDropEquipment
    if (active.drop_fever && now >= active.drop_fever.endTime) {
      delete active.drop_fever;
    }

    // Heal boost - applied in regen section
    if (active.heal_boost && now >= active.heal_boost.endTime) {
      delete active.heal_boost;
    }

    // Equip bonus 5x
    if (active.equip_bonus_5x && now >= active.equip_bonus_5x.endTime) {
      delete active.equip_bonus_5x;
    }
    // XP triple
    if (active.xp_triple && now >= active.xp_triple.endTime) {
      delete active.xp_triple;
    }
    // Damage reduce
    if (active.damage_reduce && now >= active.damage_reduce.endTime) {
      delete active.damage_reduce;
    }
    // Class CD zero
    if (active.class_cd_zero && now >= active.class_cd_zero.endTime) {
      delete active.class_cd_zero;
    }
    // Combo XP (charge-based, no time cleanup needed)
  }

  showZoneAlert(text) {
    const cam = this.cameras.main;
    const alert = this.add.text(cam.width / 2, cam.height / 2 - 50, text, {
      fontSize: '28px', fontFamily: 'monospace', color: '#FF3333',
      stroke: '#000000', strokeThickness: 4, align: 'center',
    }).setScrollFactor(0).setDepth(200).setOrigin(0.5).setAlpha(1);
    this.tweens.add({
      targets: alert, alpha: 0, duration: 2000, delay: 500,
      onComplete: () => alert.destroy(),
    });
  }

  // ‚ïê‚ïê‚ïê Wave Warning Banner System ‚ïê‚ïê‚ïê
  _showWaveWarning(spawnConfig) {
    const cam = this.cameras.main;
    const min = this.gameElapsed / 60;
    // Determine wave type
    const isColdWave = this.coldWaveActive;
    const isBossNear = (!this.boss1Spawned && this.gameElapsed >= 24 * 60) || (!this.boss2Spawned && this.gameElapsed >= 54 * 60);
    // Enemy type hint
    const topWeights = Object.entries(spawnConfig.weights).sort((a,b) => b[1] - a[1]).slice(0, 2);
    const enemyNames = { rabbit: 'üê∞ÌÜ†ÎÅº', deer: 'ü¶åÏÇ¨Ïä¥', penguin: 'üêßÌé≠Í∑Ñ', wolf: 'üê∫ÎäëÎåÄ', bear: 'üêªÍ≥∞', seal: 'ü¶≠Î¨ºÎ≤î', ice_golem: 'üßäÍ≥®Î†ò', snow_leopard: 'üêÜÌëúÎ≤î' };
    const hint = topWeights.map(([t]) => enemyNames[t] || t).join(' ');
    // Banner color
    const bgColor = isBossNear ? 0xFFD700 : isColdWave ? 0x2244CC : 0xCC2222;
    const bgAlpha = 0.7;
    // Create banner
    const bannerBg = this.add.rectangle(cam.width / 2, 30, cam.width + 200, 40, bgColor, bgAlpha)
      .setScrollFactor(0).setDepth(280).setOrigin(0.5).setX(-cam.width);
    const bannerText = this.add.text(cam.width / 2, 30, '', {
      fontSize: '16px', fontFamily: 'monospace', color: '#FFFFFF',
      stroke: '#000', strokeThickness: 3, fontStyle: 'bold'
    }).setScrollFactor(0).setDepth(281).setOrigin(0.5).setX(-cam.width);
    // Slide in
    this.tweens.add({ targets: [bannerBg, bannerText], x: cam.width / 2, duration: 300, ease: 'Power2' });
    // Countdown
    let countdown = 5;
    const updateText = () => {
      bannerText.setText(`‚ö†Ô∏è Ï†Å Î¨¥Î¶¨Í∞Ä Î™∞Î†§Ïò®Îã§! (${countdown}Ï¥à) ‚Äî ${hint}`);
    };
    updateText();
    const countdownEvent = this.time.addEvent({
      delay: 1000, repeat: 4, callback: () => {
        countdown--;
        if (countdown <= 0) {
          // Slide out
          this.tweens.add({ targets: [bannerBg, bannerText], x: cam.width + cam.width, duration: 300, ease: 'Power2',
            onComplete: () => { bannerBg.destroy(); bannerText.destroy(); }
          });
        } else { updateText(); }
      }
    });
  }

  // ‚ïê‚ïê‚ïê Killstreak Drama: RAMPAGE / UNSTOPPABLE / GODLIKE ‚ïê‚ïê‚ïê
  _updateKillstreakDrama() {
    const combo = this.killCombo;
    let tier = 0;
    if (combo >= 30) tier = 3;
    else if (combo >= 20) tier = 2;
    else if (combo >= 10) tier = 1;

    if (tier > this._lastKillstreakTier && tier > 0) {
      this._lastKillstreakTier = tier;
      const cam = this.cameras.main;
      const labels = ['RAMPAGE!', 'UNSTOPPABLE!', 'GODLIKE!'];
      const colors = ['#FF2222', '#FF8800', '#FFD700'];
      const label = labels[tier - 1];
      const color = colors[tier - 1];
      // Destroy previous
      if (this._killstreakText) this._killstreakText.destroy();
      this._killstreakText = this.add.text(cam.width / 2, cam.height * 0.3, label, {
        fontSize: tier >= 3 ? '48px' : '40px', fontFamily: 'monospace', color,
        stroke: '#000', strokeThickness: 7, fontStyle: 'bold'
      }).setScrollFactor(0).setDepth(260).setOrigin(0.5).setAlpha(0);
      this.tweens.add({ targets: this._killstreakText, alpha: 1, scale: { from: 0.3, to: 1.2 }, duration: 400, ease: 'Back.Out',
        onComplete: () => this.tweens.add({ targets: this._killstreakText, scale: 1, duration: 200 })
      });
      // Tier 2+: screen shake
      if (tier >= 2) cam.shake(300, 0.02);
      // Tier 3: particle explosion + flash
      if (tier >= 3) {
        cam.flash(300, 255, 215, 0, true);
        playBossDefeated(); // repurpose victory sound for epic moment
        const particleCount = Math.min(30, 200 - (this._activeParticles || 0));
        for (let i = 0; i < particleCount; i++) {
          const px = cam.centerX + Phaser.Math.Between(-200, 200);
          const py = cam.centerY + Phaser.Math.Between(-100, 100);
          const c = [0xFFD700, 0xFF4400, 0xFF0044][Math.floor(Math.random() * 3)];
          const p = this.add.circle(px, py, Phaser.Math.Between(2, 6), c).setDepth(259).setScrollFactor(0).setAlpha(1);
          this.tweens.add({
            targets: p, y: py - Phaser.Math.Between(40, 120), x: px + Phaser.Math.Between(-60, 60),
            alpha: 0, duration: 800 + Math.random() * 600, onComplete: () => p.destroy()
          });
        }
      }
    }
    // Reset when combo breaks
    if (combo === 0 && this._lastKillstreakTier > 0) {
      this._lastKillstreakTier = 0;
      if (this._killstreakText) {
        this.tweens.add({ targets: this._killstreakText, alpha: 0, duration: 800,
          onComplete: () => { if (this._killstreakText) { this._killstreakText.destroy(); this._killstreakText = null; } }
        });
      }
    }
  }

  // ‚ïê‚ïê‚ïê Zone Discovery Slide-up Banner ‚ïê‚ïê‚ïê
  _showZoneDiscoveryBanner(zone) {
    const cam = this.cameras.main;
    const dangerLevels = { normal: 'ÏúÑÌóòÎèÑ: ‚òÖ‚òÜ‚òÜ', danger: 'ÏúÑÌóòÎèÑ: ‚òÖ‚òÖ‚òÜ', extreme: 'ÏúÑÌóòÎèÑ: ‚òÖ‚òÖ‚òÖ' };
    const zoneNames = { normal: 'Ï£ºÏùò Íµ¨Ïó≠', danger: 'ÏúÑÌóò Íµ¨Ïó≠', extreme: 'Í∑πÏúÑÌóò Íµ¨Ïó≠' };
    const colors = { normal: '#FFDD44', danger: '#FF6644', extreme: '#FF2222' };
    const name = zoneNames[zone] || zone;
    const danger = dangerLevels[zone] || '';
    const displayText = `[ ${name} ÏßÑÏûÖ ]  ${danger}`;
    const banner = this.add.text(cam.width / 2, cam.height + 30, displayText, {
      fontSize: '18px', fontFamily: 'monospace', color: colors[zone] || '#FFFFFF',
      stroke: '#000', strokeThickness: 4, fontStyle: 'bold'
    }).setScrollFactor(0).setDepth(250).setOrigin(0.5);
    // Slide up from bottom
    this.tweens.add({ targets: banner, y: cam.height - 50, duration: 500, ease: 'Power2',
      onComplete: () => this.tweens.add({ targets: banner, alpha: 0, duration: 1000, delay: 2000, onComplete: () => banner.destroy() })
    });
  }

  spawnAnimalNearPlayer(type, minDist, maxDist) {
    const def = ANIMALS[type];
    if (!def || !this.player) return;
    const angle = Math.random() * Math.PI * 2;
    const dist = Phaser.Math.Between(minDist, maxDist);
    const x = Phaser.Math.Clamp(this.player.x + Math.cos(angle) * dist, 60, WORLD_W - 60);
    const y = Phaser.Math.Clamp(this.player.y + Math.sin(angle) * dist, 60, WORLD_H - 60);
    const a = this.physics.add.sprite(x, y, type).setCollideWorldBounds(true).setDepth(5);
    a.animalType = type; a.def = def;
    this._applyDifficultyToAnimal(a, def);
    a.wanderTimer = 0; a.wanderDir = {x:0,y:0}; a.hitFlash = 0; a.atkCD = 0; a.fleeTimer = 0;
    if (a.maxHP > 2) a.hpBar = this.add.graphics().setDepth(6);
    const lc = def.behavior === 'chase' ? '#FF4444' : def.behavior === 'flee' ? '#88DDFF' : '#AADDFF';
    a.nameLabel = this.add.text(x, y - def.size - 10, def.name, {
      fontSize: '11px', fontFamily: 'monospace', color: lc, stroke: '#000', strokeThickness: 3
    }).setDepth(6).setOrigin(0.5);
    this.animals.add(a);
  }
}

const config = {
  type: Phaser.AUTO,
  parent: 'game-container',
  width: window.innerWidth,
  height: window.innerHeight,
  backgroundColor: '#1a1a2e',
  physics: { default: 'arcade', arcade: { gravity:{y:0}, debug:false } },
  scale: { mode: Phaser.Scale.RESIZE, autoCenter: Phaser.Scale.CENTER_BOTH },
  scene: [TitleScene, BootScene, GameScene],
  input: { activePointers: 3 },
};

new Phaser.Game(config);
